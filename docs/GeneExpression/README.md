# Gene Expression Similarity

This is an implementation of the the concepts outlined in
```
  A simple and robust method for connecting small-molecule drugs using gene-expression signatures
  Shu-Dong Zhang* and Timothy W Gant*      BMC Bioinformatics 2008, 9:258 doi:10.1186/1471-2105-9-258
```

## The Task
The task is to compare one or more query structures (needles) against a large
collection of gene expression data (haystack), identifying those members of the
haystack that are closest to the needle(s), as measured by the Zhang and Grant
similarity measure.

## Architecture
The data needs to be transformed into serialized protocol buffer forms. The
tool `gene_expression_to_proto` can be used to perform this task. The input 
file(s) must be of the form
```
gene_id,Z_score_robust
29082,-7.43514680862427
10528,5.61989164352417
5111,-5.17184543609619
60528,-4.9140830039978
26520,-4.69979190826416
4582,4.6722207069397
```
where the first column is the gene id, and the second column a sorted list of
gene expresson values. Sorting must have been by absolute value. Note that
the tool does not check that the input has been sorted, although if needed
that functionality could be added. Any extra columns are ignored.

For the gene expression data we used for the initial implementation, the haystack
consisted of 473k individual .csv files as above. That took about 272GB on disk,
with each file containing about 12k records.

Converion of the full dataset to serialized protocol buffer form took over an
hour, but resulted in a file of 58GB.

As an aside the output file generated by `gene_expression_to_proto` is actually
a TFDataRecord file
[TensorFlow](https://www.tensorflow.org/api_docs/python/tf/data/TFRecordDataset)
holding a simple serialized protcol buffer.

This 58GB haystack file can be searched in about 30 minutes.

## Optimization
The algorithm described by Zhang and Grant includes a parameter that limits
the number of expression values considered. If we are only going to compare
the top 200 genes in the expression data, it does not make sense to store
and process all 12k of them. Therefore `gene_expression_to_proto` to has a
`-maxrank` parameter that allows specification of the maximum rank to be
stored in the haystack file. If that is restricted to 500, the resulting
file is only 2.4GB, and if only the 200 highest scoring expression values
are stored, the file is 960MB. These files can be searched in under a
minute.

## HowTo
To convert a directory of gene expression data files to a haystack file try
```
gene_expression_to_proto -d .csv -maxrank 200 -rpt 10000 -fname -S haystack200.dat -v /
        path/to/dir
```
This says to process all files that end in .csv that are found in /path/to/dir.
Only store the 200 highest ranked expression data. If you are curious
about how fast the job is progressing, add the -rpt option, and in this
case, it will emit a status message every 10,000 items processed.
Adding `-fname` means use the file name (rather than the full path name)
of the name associated with each file.

This might take 10 minutes or more.

Alternatively, you can provide the tool with a list of files to process and then
pass that to gene_expression_to_proto as `F:files`. It knows that if its argument
starts with "F:" that means it is a file containing a list of files to process.

The needle(s) must be converted in a similar way. This time omit the maxrank
parameter so that all the genes in the needle are stored. The algorithm works
by looking up all the genes in the needle in the (possibly truncated) list
stored with each member of the haystack.

Once both the haystack and the needles have been converted to serialized
proto form, nearneighbours can be found with `gene_expression_near_neighbours`.

```
gene_expression_nearneighbours -maxrank 200 -n 10 -p needles.dat -rpt 100000 -v haystack.dat
```

Finds, for every item in `needles.dat` the 10 nearest neighbours in
`haystack.dat` using the top ranked 200 genes in the comparison. Again,
if you are curious about progress, the -rpt option can be used.

Output will be three columns, the id of the needle in column 1, the
id of the a neighbour from the haystack and the last column is the score.
This will be ordered by decreasing score.

