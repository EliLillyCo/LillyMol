# GFP
Within LillyMol the GFP framework is used for similarity computations.

One of the unusual features of GFP is the idea that similarity is
a composite measure, derived from one or more fingerprints. Also
unusual is the use of molecular properties as a component of
similarity.

All fingerprints have advantages and disadvantages, and what we have
found is that combining fingerprint types can offer significant
advantages.

## Theory
There are an unlimited number of ways in which molecular similarity
can be measured. Much of drug discovery can be boiled down to a quest
to replicate similarity as perceived by a biological target. If we have
a similarity measure that is closely aligned with how a target perceives
similarity, we may be able to reliably identify active molecules.

Possible similarity measures might include things like

* 3D shape similarity
* 3D charge distribution.
* 3D pharmacaphore score
* Docking score.
* Molecular dynamics trajectory
* Custom 3D scoring function
* Distance in a molecular descriptor space
* Distance in a learned embedding space
* 2D molecular fingerprints.
* Innumerable other things not mentioned above.

In general, it will be hard to predict which of these methods will be
most useful - if you have a 3D enabled target, you should consider using
that information. But in general, starting with a new problem, it is
hard to predict which similarity based methodology will work best.

Here we focus on one item, 2D molecular fingerprints.

### Fingerprints
Molecular fingerprints have a well known history in Cheminformatics. They can
work very well, and are a generally accepted methodology. They can be fast to
compute and fast to use. There are many examples of 2D fingerprint based methods
out-performing more expensive 3D methods, although there are also plenty of
examples where targeted 3D methods are demonstrably superior.

The most common kinds of fingerprints are

* Linear path based fingerprints
* Extended connectivity shell based fingerprints
* Atom pair fingerprints
* Reduced graph fingerprints
* Dictionary based fingerprints

Many other forms are possible, as will be seen below.

Generally fingerprints are based on subsets of the atoms in a molecule. These may
be contiguous sets of atoms, or disconnected forms - atom pairs.

#### Binary vs Counted
Completely separate from the shape of the atomic subsets that define the features
of a fingerprint is whether to compute presence or absence of these features or to
keep track of the number of instances in each molecule. Certainly binary fingerprints
have a significant advantage in terms of speed, since they can be evaluated using
popcount hardware instructions. Several publications have studied differences in
performance between counted and binary fingerprints, and most have reported in
favor of binary. That is different from the experience at Lilly, where for model
building, counted fingerprints generally perform better. But there is a major
run-time performance penalty for using counted fingerprints - depending on the
application.

We will see that the GFP framework can deal equally with counted and binary fingerprints.

### gfp_make
This tool is used for generating fingerprints. See [gfp_make](gfp_make.md). All
gfp tools require fingerprint input, and usually those are generated by gfp_make.
By convention, fingerprint files have the suffix `.gfp`, so a typical invocation
will usually look like
```
gfp_make file.smi > file.gfp
```
and the resulting file can then be used by any of the `gfp_*` tools. Mostly the
`gfp_*` tools have no idea they are dealing with molecules, they just process
fingerprints.

### Fingerprint Files
The default format for a fingerprint file is a Thor DataTree (TDT) form as
defined by Daylight. Today this is an archaic file format, but works well
in this use case. It is an ASCII format, which enables use of various text
based tools. Parsing the fingerprint file is seldom a rate limiting step,
although there are exceptions to that....

If `gfp_make` is invoked with no arguments, the resulting fingerprint file might look like
```
$SMI<N1C=NC=C1CCCOC(C)(C)C>
FPIW<bzV.6.0..c....c..U.+...80........  omitted  2.E..U00E...V.28.....U2.GU....1;2048;148;2048;148;1>
FPMK<YWU..U.2.0+c9l.kU6q9lVVi+NkZ...U3;192;49;192;49;1>
FPMK2<Y0U..U....+U6+..U.m6FUV2+F......3;192;23;192;23;1>
PCN<CHEMBL1179664>
MPR<1EI++EI..k..2;64;12;64;12;1>
|
```
The `$SMI<` token is the smiles of the molecule, and `PCN<` is the name. These
are only ever treated as text by GFP tools, the smiles is included just as a
convenience for subsequent processing.

Generally smiles files must include a name, in order to populate `PCN`. Many
gfp tools will run if the name is empty, but generally this will cause problems.
All molecules should have names!

There are several tools that can help process TDT type files, these include
```
tdt_join
tdt_merge
tdt_sort
tdt_stats
```
those will be covered elsewhere.

The default fingerprint, above, consists of 4 components.

#### FPIW
A linear path based fingerprint. Conceptually similar to the Daylight fingerprint,
or RDKit linear fingerprint. A default atom typing is used, and paths up to length
7 are perceived. The fingerprint is 2048 bits.

This is a binary, fixed width fingerprint. By convention, all fixed width, binary
fingerprints start with 'FP'.

#### FPMK FPMK2
LillyMol contains an implementation of the MACCS keys, although the current
implementation has diverged considerably from the original definition, currently generating
192 features. While FPMK is a traditional dictionary based fingerprint,
recording the presence or absence of each of the 192 features in the dictionary, FPMK2
is slightly different.

A well known shortcoming of binary fingerprints is their insensitivity to repeated
features. This can lead to what to us look like significantly different molecules
being classified as similar - because the measure of similarity does not
recognised differing numbers of a feature. In order to help mitigate this, the MK2
fingerprint is a binary fingerprint that is only set if the number of features
is above some threshold. That threshold is determined by profiling a large
collection of molecules, and figuring out, for those molecules when the feature
is present, how many times is average. Once that is known, the feature will only
be set if the number of instances is above that threshold. Median might be a better
measure than average...

#### MPR
In a further attempt to deal with repeated features, the MPR fingerprint component
encodes 8 molecular properties that are incorporated into the overall measure
of similarity. This is NOT a binary fingerprint, but contains encoded values for
the following features

1. Number heavy atoms
2. Largest ring size
3. Number of rings
4. Number of ring atoms
5. Number of aromatic atoms
6. Number of fused ring atoms
7. Number of heteroatoms
8. Number of unsaturated atoms.

These are combined as ratios. For example if molecule 1 contains

* natoms = 20
* largest_ring = 6

and molecule 2 contains

* natoms = 10
* largest_ring = 7

That component of the similarity calculation is `10/20 + 6/7`. Across all
properties, the min is divided by the max, generating a number that is always
in the range [0,1].

There are of course an unlimited number of molecular properties that could be
used for this purpose. Other properties that would seem like very good candidates
include

* longest path
* atoms in scaffold
* size of largest ring system
* number linker atoms
* rotatable bonds

Although clearly some of these would be more expensive to compute than the current
set of features.

These have just been added as an optional usage in gfp_make.
```
gfp_make -MPR=none,natoms,nrings,rotbond ...
```

See the section below for an expanded discussion of molecular properties in gfp.

## Other Fingerprints
gfp_make can generate a very large number of fingerprints. There may be one
or more versions of
* Linear Fingerprints
* EC fingerprints
* Atom Pair fingerprints
* Topological Torsion fingerprints 
* Molecular Property fingerprints
* MACCS keys fingerprints
* PUBCHEM fingerprints
* clogp, BioByte (Vendor), alogp or xlogp.
* PSA
* ErG
* Other reduced graph forms.
* CATS
* iwdescr properties
* Structural abstraction fingerprints (via molecular_abstraction)
* Fingerprints of the scaffold, graph, largest ring system, rings
* Ghose Crippen fingerprints
* Ring fingerprints
* Ring substituion fingerprints
* A fingerprint defined by tsubstructure matches
* Fingerprints derived from 3d structures (needs corina).

Many of these fingerprints can be further modified by atom type and whether they are
fixed binary forms, or sparse, non-colliding forms. Just taking all pairwise
combinations of the 19 types mentioned above yields 171 diffrent fingerprints. See
[atom typing](/docs/Molecule_Lib/atom_typing.md) for information on atom typing in LillyMol
and how use of multiple atomic properties could explode the number of possibilies.

gfp_make is separately documented [gfp_make](gfp_make.md).

### Multiple Fingerprints
One of the hallmark features of gfp is the use of multiple fingerprints. All
gfp tools are designed to examine their input file(s) and determine which fingerprints
are present, and to use those fingerprints for the calculation. This can be any
number of fingerprints. If molecular properties are present, they will be used
as just another 'fingerprint'.

When there are multiple fingerprints in a file, the default similarity measure is
the average of the components. You can usually override that on the command line. For
example if you had a file with two fingerprints
```
gfp_make -FPAB -FPXY file.smi > file.gfp
```
and wanted to find the nearest neighbours within that file, but you wanted
to provide a higher weight to the AB fingerprint.
```
gfp_nearneighbours_single_file -F FPAB,w=0.8 -F FPXY,w=0.2 file.gfp > file.nn
```
would do that. Note that the 'FPAB' and 'FPXY' are *not* the same as the options
given on the command line, they must be the same as the tags placed in the file.
So, specifying -FPAB on the command line might result in a fingerprint tag 'FPAB2'
which might be the result of some default condition having been applied. The
only way to know for sure is to look in the fingerprint file.

This mechanism gets more complicated if sparse, non colliding fingerprints are
involved. Let's imagine in the case above that FPXY produces a non colliding
fingerprint. By convention, these start with 'NC'. But if you specify weights
on the command line, all conventions are discarded, and you are in complete
control. Imagine that specifying -FPXY to gfp_make results in a fingerprint
with tag 'NCXY' in the fingerprint file.
```
gfp_nearneighbours_single_file -F FPAB,w=0.8 -F NCXY,w=0.2,nc file.gfp > file.nn
```
you need to tell it that NCXY is a non colliding fingerprint.

If molecular properties are present, a weight can be specified via the -P
option, `-P 0.1` or `-P none` to not use the molecular properties that might
be in the fingerprint file.

Many tools consume multiple fingerprint files. It is essential that a
common set of fingerprints be in both files. Generally the order of the
fingerprints for each molecule does not matter, so something like
```
$SMI<C>
PCN<methane>
FP1<....>
NC2<.............>
MPR<...>
|
```
and
```
$SMI<C>
PCN<methane>
MPR<...>
NC2<.............>
FP1<....>
|
```
can usually be compared. When multiple files are being processed, the
first file read will define what fingerprints must be present in all
subsequent files. There can be extra fingerprints in those other files,
but those found in the first one must be present. Across tools it is
unpredictable as to which file is opened first.

Bottom line - make things easy for yourself and use fingerprint files
both generated by the same options to gfp_make.

### Other Fingerprint Forms
The default encoding used for fingerprints is something defined by Daylight.
GFP tools can consume fingerprints encoded in several different forms. For example
if you have hex encoded bits, `-F FPHS9,hex` means that the fingerprint tag
'FPHS9` is a fixed width fingerprint, lowercase hex encoded. Adding 'HEX' means
it is uppercase hex encoded. Adding 'ascii' means it is the most verbose of
all forms '00011101'.

Dense fingerprints can be read from a sparse representation by adding '-F FPAB,sparse'
```
FPAB<3,4,7-10,15:64>
```
where the ':64' specifies that the number of bits in this fingerprint is
64.

Libsvm fingerprints can be read as sparse fingerprints via
```
-F NCFP,sparse,nc
```
where the input file might look like
```
NCFP<3:1 10:7 20:1 31:4>
```
for a fingerprint with 4 features. The features, 3, 10, 20, 31 must be in order.

The gfp framework also has a fixed width, counted fingerprint form, with the
counts encoded as bytes. This is not often used, but processing these fingerprints
can be a lot faster than processing sparse fingerprints.

## Distance measures.
For all fingerprints, the default similarity measure is Tanimoto, but it is
possible to apply different similarity metrics to individual fingerprints.

For example if you wished to apply a cosine similarity measure to fingerprint
`FPXYZ` and a regular Tanimoto to `NCAB3`, that would be specified as
```
-F FPXYZ,cosine -F NCAB3
```
and of course all previously mentioned tokens can be appended as needed. The
following tokens at the end of a fingerprint tag specification are recognised

* w=weight
* fold=nfold   fold a binary fingerprint `nfold` times
* nc    fingerprint is sparse, non colliding form
* hex   lowercase hex form
* HEX   uppercase hex form
* ascii   '01' form for binary fingerprints
* sparse  libsvm form for sparse fingerprints
* counted       fixed size counted fingerprints
* cosine        use cosine similarity
* fvb        Flinger, Verducci and Blower modified Tversky
* rr            Russel Rao similarity
* forbes            Forbes similarity
* sm            Simple Matching
* manh          Manhattan distance
* soergel, soergelv     Soergel - and variant
* ctan  continuous Tanimoto
* dice  Dice similarity
* overlap       overlap distance

Most of these have been added for a specific project and are seldom used. They
are not fully described here. Most are well known.

There are also other fingerprints related to a failed multi-valued fingerprint idea,
initially intended to deal with conformers. Do not even think about
trying to use those. Other features in the code, do not use, they should be
removed.

It is possible that, for any given project, one or more of these other
distance measure might be better than Tanimoto. We seldom take the time to 
explore that.

### Molecular Properties.
The most commonly used molecular propties, those activated with the
defalt -MPR option were discussed above. There is however a great deal more
flexibility available with molecular features in the GFP framework.

Molecular properties can be of either integer, or floating point forms. The
default set is integer form, and those are typically used via the ratio
scheme previously outlined.

Adding '-P dice' will result in the Dice similarity measure being used
for the integer molecular properties.

Continuous molecular properties can be specified via '-P desc=...'. These must be
encoded as
```
DSC<0.1 3.14 8 0 4.8>
```
where the tag can be anything, although DSC is used by convention - but not
implicitly recognised by GFP.

Several -P possibilities are recognised. The first component of the flag should
start with the tag of the descriptors, 'DSC' above. Somewhere within the tag
there must be a 'desc=' directive.

* -P tag,desc=   specify the TDT tag containing molecular descriptors (DSC above). All
the features in the input are used.

* -P tag,desc=all       Same as the previous, all features used.

* -P tag,desc=n     Only use the first 'n' descriptors in the input

* -P tag,desc=5,w=0.1,cartesian     tag, use first 5 descriptors, use Cartesian distance.
But beware, unless the values are unit vectors, this will result in invalid distances.

* -P tag,desc=5,w=0.1,dice     tag, use first 5 descriptors, use Dice distance.

* -P tag,desc=,w=0.1,scale=0.1     tag, all descriptors, weight, scale all values on input.

* -P tag,desc=all,w=0.2,exp1=

* -P tag,desc=10,w=0.1,exp2=

The usual way in which molecular descriptors are added to a gfp file is via
`gfp_add_descriptors` which takes as arguments a descriptor file and a gfp
file and will match up the files via the identifiers, and insert an extra
dataitem in each fingerprint.

Note that computationsl involving molecular properties tend to be quite
slow compared with bit comparison operations.

### Tversky
Many tools support a '-V' option, which allows specification of Tversky
parameters. It is always super confusion which way the parameters go, and
it is often easiest to try ot both ways and see.

For example, start with benzene and do a similarity search into a larger
set with the opposite Tversky settings.
```
gfp_make -NCIW benzene.smi > benzene.gfp
gfp_make -NCIW haystack.smi > haystack.gfp
gfp_lnearneighbours -n 10 -p benzene.smi -V a=2 -V b=0 haystack > benzene.nn
```
we find that any molecule that contains a benzene atom matches with
zero distance. These might include
```
COC1=C2C(=CC(=C1)N)SC(N)=N2 CHEMBL587076
C1=C(O)C=CC(=C1)[C@H]1C[C@@H]1CN CHEMBL492304
C(=N)(N)NN=CC1=CC=CC=C1 CHEMBL1183425
N(C)(C1=CC=CC=C1)CCCBr CHEMBL2380319
C1CC2=CC(=CC=C2C(=O)C1)O CHEMBL3288306
C1(=CC=CC(=C1C(=O)CC)O)O CHEMBL3274338
C1=CC=C2C(=C1)[C@@H]1C(C2)[C@H]1N CHEMBL4302026
N(=O)(=O)C1=C(N)C=CC=C1N CHEMBL167321
N(O)(C1=CC=CC=C1)CCC CHEMBL358605
C1=CC=C2C(=C1)NC(N)S2 CHEMBL568765
```
Essentially we are doing a substructure search for benzene.

If on the other hand we reverse the parameters,  we might find as matches


## Tools
All programmes that deal with gfp fingerprint files are prefixed with 'gfp_',
so tab completion is your friend.

The tool families include:

* gfp_make      makes fingerprint files
* gfp_distance_matrix   compute a distance matrix
* gfp_distance_filter   filter fingerprints by similarity to another set
* gfp_flatten_counted   turn counted bits to a max of 1
* gfp_leader    sphere exclusion clustering
* gfp_incremental_diversity     how does a collection evolve
* gfp_lnearneighbours finds nearest neighbours between two fingerprint files.
* gfp_naive_bayesian    Naive Bayesian models - sometimes pretty good!
* gfp_pairwise_distances        Pairwise distances from a larger set.
* gfp_profile_activity_by_bits  Compare bit presence against activity
* gfp_single_linkage    Single linkage clustering
* gfp_spread* maximum diversity selection
* gfp_standalone        operates on a smiles file, computing fp's on the fly
* gfp_to_descriptors*   convert gfp files to descriptor form.
* gfp_svmfp_score*      scores an svmfp model.
* gfp_to_svm_lite       converts gfp files to svm_learn input
* evidence      builds local knn models to examine activity consisteny.

These tools are described separately. Many have multiple variants. Where there
is a '_standard' variant, that is a special purpose tool that only operates
on fingerprints produced by `gfp_make -STD` and most are multi-threaded.
By dropping the complexity of dealing with arbitrary fingerprint forms,
efficiency is gained. Over time, the more flexible forms have closed that
performance gap.

