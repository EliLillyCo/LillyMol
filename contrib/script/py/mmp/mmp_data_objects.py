###################################################################
""" Summary: Class and Methods to get MMP differences from input CSV data

About: The class is an extension of the class mmp_objects.  The base
class only deals with molecule data and pair generation.  This class
adds objects to handle associated molecule data and generate data 
differences or deltas between molecules as well as the raw molecule pairs

Example usage:
    
    my_mmp_data_object = MMPDataObjectClass(mmplogger)
    
    # parse CSV
    my_mmp_data_object.csv_sniffer(in_file, smi_col, molid_col)
    my_mmp_data_object.csv_to_data_objects(in_file, smi_col, molid_col)
    
    # add dicer fragments to create pair dicts
    tmp_dicer_file = my_mmp_data_object.write_mol_smi_dict_tofile()
    my_mmp_data_object.build_from_dicer(tmp_dicer_file, cut_type, filter_type)
    
    # get pairs
    my_mmp_data_object.get_pairs_and_diffs(out_fi, cut_type)

Warnings: This class assumes the input smiles are already salt stripped
and that their identifiers and convertable to a valid integer value. Input
smiles of the type "c1ccccc1[N+].[Cl-] CHEMBL9876" will fail for both reasons
"""
###################################################################
import logging
import csv
import os
import sys
# things needed for unit testing only
import unittest
import tempfile
import copy

from mmp.mmp_objects import MMPObjectClass

# later clogp method can be licensed biobyte clogp
# or opensourced abraham's alogp depending on environment var
if 'LILLYMOL_HOME' in os.environ:
    import pybase.pyopmo as pymo
else:
    import pybase.pymo as pymo

class MMPDataObjectClass(MMPObjectClass):

    def __init__(self, logger_object):
        """
        Example usage:
            mmplogger = logging.getLogger('lillymol_file_logger')
            logging.disable(logging.CRITICAL)
            my_mmp_data_object = MMPDataObjectClass(mmplogger)

        Due to the large number of repeat smiles generated by dicer fragmentation,
        normalisation is applied to the final single and double cut matched pairs
        objects.  The actual MMP data objects single_pairs_dict and double_pairs_dict
        simply contain numerical id's for every smiles. The smiles are stored in
        refsmi_dict and data for each smiles stored in real_data_dict
        """

        MMPObjectClass.__init__(self, logger_object)

        self.logger = logger_object
        if len(logging.Logger.manager.loggerDict) < 1:
            # exit with system status 1 and custom error
            sys.exit("Invalid or no logger object passed to MMPObjectClass.  Please create \
                    and pass a logger and set to use logging.disable if you don't want logging")

        # setup temp smiles file for dicer to use
        self.suffix = '.smi'  # iwdescr needs this .smi suffix to work
        self.temp_dicer_smifi = tempfile.NamedTemporaryFile(delete=False, suffix=self.suffix,
                                                            encoding='utf-8', mode='wt')

        # object level flag to determine if we will add MWT / CLP data to the output
        self.add_prop_data = 0
        
        # becomes dict of smi => [array, of, real, data]
        # currently code will drop or ignore any data given 
        # on input that is not of type real (or smiles/mol_id)
        self.mol_data_dict = {}

        self.mol_props_dict = {}
        self.mol_props_headers = []
        self.mol_props_headers_numeric_position = {}

        # for comparison SMI sets
        self.mol_smi_comparison_dict = {}

        self.mol_props_comparison_dict = {}
        self.mol_props_comparison_headers = []
        self.mol_props_comparison_headers_numeric_position = {}

        # other vars to help us process the CSV file
        self.csv_dialect = ''
        self.headers = []
        self.headers_nosmi = []
        self.headers_numeric_position = {}
        self.csv_items_per_line = 0
        self.smi_col_num = ''
        self.molid_col_num = ''

        # Bug Fix: this var is needed to keep track of -t option in wrapper script where we write out a second header
        # line in CSV containing the column types.  This flag and header can screw up aggregation
        # in the method pd_read_csv so we drop this line on read of CSV.  It gets set in the method get_pairs_and_diffs
        # but is never really used unless inherit this from mmp_pairs_object where it's essential
        self.types_header = False

    def clean_out_data(self):
        """Method to clean out all objects in class"""

        self.logger.debug('mem_trace refsmi_dict entries entries: %s, mem usage: %s kB' % (
            len(self.refsmi_dict), sys.getsizeof(self.refsmi_dict)/1000))
        self.logger.debug('mem_trace single_pairs_dict entries: %s, mem usage: %s kB' % (
            len(self.single_pairs_dict), sys.getsizeof(self.single_pairs_dict)/1000))
        self.logger.debug('mem_trace double_pairs_dict entries: %s, mem usage: %s kB' % (
            len(self.double_pairs_dict), sys.getsizeof(self.double_pairs_dict)/1000))
        self.logger.debug('mem_trace mol_data_dict entries: %s, mem usage: %s kB' % (
            len(self.mol_data_dict), sys.getsizeof(self.mol_data_dict)/1000))
        self.logger.debug('mem_trace mol_smi_dict entries: %s, mem usage: %s kB' % (
            len(self.mol_smi_dict), sys.getsizeof(self.mol_smi_dict)/1000))
        self.logger.info("Cleaning out all objects")

        # just clean out all the dicts
        self.refsmi_dict.clear()
        self.single_pairs_dict.clear()
        self.double_pairs_dict.clear()
        self.add_prop_data = 0
        self.mol_data_dict.clear()
        self.mol_smi_dict.clear()
        self.mol_smi_comparison_dict.clear()
        self.mol_props_dict.clear()
        self.mol_props_headers = []
        self.mol_props_headers_numeric_position.clear()

        # and reset csv stuff
        self.csv_dialect = ''
        self.headers = []
        self.headers_nosmi = []
        self.headers_numeric_position = {}
        self.csv_items_per_line = 0
        self.smi_col_num = ''
        self.molid_col_num = ''
        
        self.logger.debug('mem_trace refsmi_dict entries entries: %s, mem usage: %s kB' % (
            len(self.refsmi_dict), sys.getsizeof(self.refsmi_dict)/1000))
        self.logger.debug('mem_trace single_pairs_dict entries: %s, mem usage: %s kB' % (
            len(self.single_pairs_dict), sys.getsizeof(self.single_pairs_dict)/1000))
        self.logger.debug('mem_trace double_pairs_dict entries: %s, mem usage: %s kB' % (
            len(self.double_pairs_dict), sys.getsizeof(self.double_pairs_dict)/1000))
        self.logger.debug('mem_trace mol_data_dict entries: %s, mem usage: %s kB' % (
            len(self.mol_data_dict), sys.getsizeof(self.mol_data_dict)/1000))
        self.logger.debug('mem_trace mol_smi_dict entries: %s, mem usage: %s kB' % (
            len(self.mol_smi_dict), sys.getsizeof(self.mol_smi_dict)/1000))

    def write_mol_smi_dict_tofile(self, use_comparison_dict = False):
        """Method to write out the mol_smi_dict to a flatfile for use by dicer 
        fragmentation. Could later extend this to any fragment dict if useful!
        Returns the name of the temp file that has been used.
        """

        if len(self.mol_smi_dict) < 1:
            sys.exit("You are trying to write a zero sized mol_smi_dict to file")
        
        self.logger.info("writing smiles to temp file for dicer fragmentation: %s" % self.temp_dicer_smifi.name)
        
        if use_comparison_dict is False:
            query_dict = self.mol_smi_dict

        else:
            query_dict = self.mol_smi_comparison_dict

        # write smi/id to temp file in std smiles format for dicer
        with open(self.temp_dicer_smifi.name, "w") as f:
            for id_, smi in query_dict.items():
                if type(id_) == int:
                    f.write(smi+" "+str(id_)+"\n")

        return self.temp_dicer_smifi.name

    def build_comparison_smidict(self, comparison_smi_fi, add_prop_data=0):
        """Utility method for other programs to use such as mmp_predict that need smiles of a comparison SMI set"""

        # ensure we're consistent
        if add_prop_data == 0 and self.add_prop_data != 0:
            add_prop_data = self.add_prop_data
           
        with open(comparison_smi_fi, "r+t") as csmifile:
            
            for line in csmifile:
                line = line.rstrip('\r')
                line = line.rstrip('\n')
                line_list = line.split()
               
                if len(line_list) != 2:
                    sys.exit("This comparison SMI file has >2 columns, expecting only smiles and id, please check")
                try:
                    csmi = str(line_list[0])
                    cid = int(line_list[1])
                except:
                    sys.exit("This SMI file has non numeric or non integer ID's which I can't handle, please change")

                self.mol_smi_comparison_dict[cid] = csmi

                self.logger.info("Completed build of Comparison SMI Dict with %d smiles" % (
                    len(self.mol_smi_comparison_dict)))

        # now add the property data
        if add_prop_data == 1:

            self.generate_clogp(input_smi=comparison_smi_fi, comparison_dict=True)
            self.generate_mwt(input_smi=comparison_smi_fi, comparison_dict=True)

        if add_prop_data == 2:

            self.generate_clogp(input_smi=comparison_smi_fi, comparison_dict=True)
            self.generate_all_props(input_smi=comparison_smi_fi, comparison_dict=True)

    def csv_sniffer(self, csv_file, smi_col, molid_col, skip_num_check=False):
        """Method to take input CSV and populate smi data in mol_smi_dict, and all other
        data in self.real_data_dict, expects csv file name as input as well as column header
        for SMI and MOL_ID columns.
        """

        # check the csv file has headers, exit if it does not
        sniffer = csv.Sniffer()
        if sniffer.has_header(csv_file) == 0:
            sys.exit("Sniffer module did not detect a header in your CSV file, please check!")

        # now open csv file and start to use it
        with open(csv_file, "rt", newline='') as csvfile:
            
            # use sniffer to detect dialet
            self.csv_dialect = sniffer.sniff(csvfile.read(65536))
            csvfile.seek(0)
            # create reader object 
            reader = csv.reader(csvfile, self.csv_dialect, skipinitialspace=True)
            # get headers
            self.headers = next(reader)
            self.headers_nosmi = copy.deepcopy(self.headers)
            self.logger.info("Got headers from CSV: %s" % self.headers)
            # get expected line length
            self.csv_items_per_line = len(self.headers)
            self.logger.info("Expected number of items per line: %s" % self.csv_items_per_line)

            # get the index or column id for the smi and id columns and assign to vars
            for i in range(len(self.headers)):
                if self.headers[i].upper() == smi_col.upper():
                    self.smi_col_num = i
                if self.headers[i].upper() == molid_col.upper():
                    self.molid_col_num = i

            # check they are assigned or fail completely as we will not be able to write smiles file
            if self.smi_col_num == '':
                sys.exit('Could not detect SMI column %s in CSV file headers %s' % (smi_col, self.headers))
            elif self.molid_col_num == '':
                sys.exit('Could not detect MOL_ID column %s in CSV file headers %s' % (molid_col, self.headers))
            self.logger.info("The MOL_ID and SMI columns are at indexs: %d, %d" % (
                self.molid_col_num, self.smi_col_num))
            
            # clean up headers_nosmi
            if self.molid_col_num > self.smi_col_num:
                self.headers_nosmi.pop(self.molid_col_num)
                self.headers_nosmi.pop(self.smi_col_num)
            else:
                self.headers_nosmi.pop(self.smi_col_num)
                self.headers_nosmi.pop(self.molid_col_num)

            # scan first 30 or less lines of file to determine data types for each column
            # if you find a real or int value then add column position/index to headers_numeric_position
            row_iterator = 0
            self.logger.info("Initialising prescan of CSV")

            if skip_num_check:
                self.logger.debug("Skipping pre-scan of CSV and will operate on all columns")
                row = next(reader)
                for idx, val in enumerate(row):
                    self.headers_numeric_position[idx] = self.headers[idx]
                del self.headers_numeric_position[self.smi_col_num]

            else:
                for row in reader:

                    row_iterator += 1
                    self.logger.debug("Prescan of CSV row: %d" % row_iterator)

                    # if first data row, capture position of all numeric columns
                    if row_iterator == 1:
                        self.logger.debug("Evaluating all columns for numeric values")
                        for idx, val in enumerate(row):
                            try:
                                float(val)
                                self.headers_numeric_position[idx] = self.headers[idx]
                                self.logger.debug("This value %s with index %d is numeric: " % (val, idx))
                            except:
                                self.logger.debug("This value %s with index %d is not numeric: " % (val, idx))

                    # for all other rows, remove entry from headers_numeric_position if not numeric
                    # but only do this for first 30 rows
                    if row_iterator < 30:
                        for idx, val in enumerate(row):
                            if idx in self.headers_numeric_position:
                                try:
                                    float(val)
                                except:
                                    del self.headers_numeric_position[idx]
                                    self.logger.debug("I had to remove this value %s with index %s: " % (idx, val))

                    # more than 30 rows so quit loop
                    else:
                        break

        # now remove the id column from self.headers_numeric_position as we
        # don't want to do math on this column when calculating pair data diffs
        del self.headers_numeric_position[self.molid_col_num]
        
        self.logger.info("These are the columns I will do maths on for pair diffs: %s" % self.headers_numeric_position)

        # close csv file handle
        csvfile.close()
    
    def csv_to_data_objects(self, csv_file, smi_col, molid_col, act_data_col=None, add_prop_diff=0, std_smi=False):
        """
        Method to take input CSV and populate smi data in mol_smi_dict, and all other
        data in self.real_data_dict, expects a number of variables set at the class level
        to be populated or it will fail and exit
        :param csv_file: CSV file name to read / parse
        :param smi_col: column name for smiles data column
        :param molid_col: column name for mol_id data column
        :param act_data_col: column name for activity data column
        :param add_prop_diff: set to 1 if you want to add clogp, mwt and other property data
        :param std_smi: Standardise smiles stored in self.mol_smi_dict
        :return:
        """
        
        if (self.csv_dialect == '' or
                self.headers == [] or
                self.headers_nosmi == [] or
                self.headers_numeric_position == {} or
                self.csv_items_per_line == 0):
            sys.exit("Can't proceed with CSV parsing as the CSV file did not contain anything "
                     "other than SMI and ID columns. Script needs further data columns to "
                     "calculate differences on")
        
        self.logger.info("Size of mol_data_dict, mol_smi_dict, refsmi_dict, single_pairs_dict, double_pairs_dict: \
                %d, %d, %d, %d, %d" % (len(self.mol_data_dict), len(self.mol_smi_dict), len(self.refsmi_dict),
                                       len(self.single_pairs_dict), len(self.double_pairs_dict)))

        if add_prop_diff == 1:
            self.add_prop_data = 1

        elif add_prop_diff == 2:
            self.add_prop_data = 2

        if act_data_col is not None:
            # injected this code to force a given column name to be the only column we do diffs on.
            # This iterates over self.headers_numeric_position and removes all items if not 'act_data_col'
            # then adjust self.headers_numeric_position accordingly
            temp_dict = {}
            
            for key, value in self.headers_numeric_position.items():
                if value == act_data_col:
                    temp_dict[key] = value
            
            if len(temp_dict) == 0:
                sys.exit("Please specify a valid column name, %s not found in CSV columns" % act_data_col)

            self.headers_numeric_position = temp_dict

        with open(csv_file, "rt") as csvfile:
            
            # iterate over filelines and add to data dict
            # first reset the file iterator then skip the header
            # then do fresh iteration to read data
            self.logger.info("Now populating mol_data_dict and mol_smi_dict")
            reader = csv.reader(csvfile, self.csv_dialect, skipinitialspace=True)
            next(reader)
            for row in reader:
                data_row = []
                for key in sorted(self.headers_numeric_position.keys()):
                    # try to grab the numerical data and add to array
                    try:
                        data_row.append(float(row[key]))
                    except:
                        data_row.append('null')
                
                # add to mol_data_dict as mol_id => [the,numerical,data,as,array,with,mol_id,smi,removed]
                if int(row[self.molid_col_num]) in self.mol_data_dict:
                    self.logger.debug("Duplicate data found for mol_id: %s" % (row[self.molid_col_num]))
                else:
                    self.mol_data_dict[int(row[self.molid_col_num])] = data_row
                    self.logger.debug("Added real data array for mol_id %s: %s" % (row[self.molid_col_num], data_row))
                    
                # add to the mol_smi_dict as mol_id => smiles
                self.mol_smi_dict[int(row[self.molid_col_num])] = row[self.smi_col_num]
            
                self.logger.debug("Done populating mol_data_dict to %s rows and mol_smi_dict to %s rows" % (
                    len(self.mol_data_dict), len(self.mol_smi_dict)))

        # now write to file and get back the temp file object
        smifi_for_dicer = self.write_mol_smi_dict_tofile()

        # standardise smiles
        if std_smi:
            self.mol_smi_dict = copy.deepcopy(self.generate_std_smiles(smifi_for_dicer, smi_id_map='both'))

        # now validate smiles in smi file
        self.scan_input_smiles(smifi_for_dicer)

        # now add the property data, after act_data_col dealt with
        if self.add_prop_data == 1:

            self.generate_clogp()
            self.generate_mwt()

        if self.add_prop_data == 2:

            self.generate_clogp()
            self.generate_all_props()

        self.logger.info('Done parsing CSV to data objects')
        self.logger.info('mem_trace refsmi_dict entries: %s, mem usage: %s kB' % (
            len(self.refsmi_dict), sys.getsizeof(self.refsmi_dict)/1000))
        self.logger.info('mem_trace single_pairs_dict entries: %s, mem usage: %s kB' % (
            len(self.single_pairs_dict), sys.getsizeof(self.single_pairs_dict)/1000))
        self.logger.info('mem_trace double_pairs_dict entries: %s, mem usage: %s kB' % (
            len(self.double_pairs_dict), sys.getsizeof(self.double_pairs_dict)/1000))
        self.logger.info('mem_trace mol_data_dict entries: %s, mem usage: %s kB' % (
            len(self.mol_data_dict), sys.getsizeof(self.mol_data_dict)/1000))
        self.logger.info('mem_trace mol_smi_dict entries: %s, mem usage: %s kB' % (
            len(self.mol_smi_dict), sys.getsizeof(self.mol_smi_dict)/1000))
        
        # close csv file handle
        csvfile.close()

    def generate_std_smiles(self, smiles_file, smi_id_map='both'):
        """
        Method to standardise the input smiles stored in given dictionary.  This was added for the matched
        series work where enumerated product molecules need to be checked to ensure they are novel and this
        is done via string comparison on standardised smiles.
        :param smiles_dict: the dictionary structure containing the smiles and ids
        :param smi_id_map: the direction to add smi and id to the dict, uni or bidirectional
        :param existing_smifi: name of the file containing smiles to standardise, or None if it does not exist
        """
        # are we creating/storing dict as smi => id or id +. smi or both ways?
        smi_id_map_opt = ['both', 'id_smi', 'smi_id']
        if smi_id_map not in smi_id_map_opt:
            raise Exception('Error, invalid param for smi_id_map in generate_std_smiles')

        return_dict = {}
        return_out_tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".smi", encoding='utf-8', mode='wt')
        return_out = tempfile.NamedTemporaryFile(delete=False, suffix=".smi", encoding='utf-8', mode='wt')

        # run standardise smiles
        self.logger.debug("Running standardise smiles with in: %s, out: %s" % (smiles_file, return_out.name))
        exit_status_a = pymo.fileconv(smiles_file,
                                    outfile=return_out_tmp.name,
                                    params_dict={'-i': 'rmhknown',
                                                ' -i': 'mdlD',
                                                '  -i': 'mdlT',
                                                '   -i': 'mdlquiet',
                                                '    -i': 'ignore_bad_chiral',
                                                '     -i': 'ignore_bad_m',
                                                '      -i': 'firstsdftag',
                                                '-A': 'D',
                                                ' -A': 'I',
                                                '-E': 'autocreate',
                                                '-V': '',
                                                '-S': '-',
                                                '-g': 'all',
                                                '-B': '9999',
                                                '-c': '5',
                                                '-C': '200',
                                                '-s': 'rmbad',
                                                '-Y': 'ftn',
                                                '-I': 'change',
                                                '-O': 'none',
                                                '-f': 'lod'},
                                    loggero=self.logger)
        self.logger.debug("standardise smiles return code was: %s" % exit_status_a)

        # run standardise smiles
        self.logger.debug("Running preferred smiles with in: %s, out: %s" % (return_out_tmp.name, return_out.name))
        exit_status = pymo.preferred_smiles(return_out_tmp.name,
                                            outfile=return_out.name,
                                            params_dict={},
                                            loggero=self.logger)
        self.logger.debug("preferred smiles return code was: %s" % exit_status)

        # load the results
        with open(return_out.name, "rt") as csv_file:

            reader = csv.reader(csv_file, delimiter=' ')
            for row in reader:
                try:
                    id_ = int(row[1])
                    smi_ = row[0]
                except:
                    self.logger.debug('Unable to parse line from standardise smiles:\n %s' % str(row))
                    continue

                if smi_id_map == 'both' or smi_id_map == 'id_smi':
                    return_dict[id_] = smi_

                if smi_id_map == 'both' or smi_id_map == 'smi_id':
                    return_dict[smi_] = id_

        return return_dict

    def generate_clogp(self, input_smi=False, comparison_dict=False):
        """Use pymo.cmi to generate CLP data for all mols
           Original implementation uses Biobyte clogP
           Opensource implmentation uses Abrahams """

        if input_smi is False:
            input_smi = self.temp_dicer_smifi.name

        temp_clp_out = tempfile.NamedTemporaryFile(encoding='utf-8', mode='wt', delete=False)

        # run cmi
        self.logger.info("Running cmi with in: %s, out: %s" % (input_smi, temp_clp_out.name))

        #
        use_alogp = False

        if 'LILLYMOL_HOME' in os.environ:

            use_alogp = True
            exit_status = pymo.alogp(input_smi,
                                   outfile=temp_clp_out.name,
                                   loggero=self.logger)
            self.logger.debug("alogp return code was: %s" % exit_status)

        else:

            exit_status = pymo.cmi(input_smi, outfile=temp_clp_out.name,
                                   params_dict={}, loggero=self.logger)
            self.logger.debug("cmi return code was: %s" % exit_status)


        # append header
        if comparison_dict:
            self.mol_props_comparison_headers.append('MOL_CLP')
            self.mol_props_comparison_headers_numeric_position[self.mol_props_comparison_headers.index('MOL_CLP')] = \
                'MOL_CLP'
            mol_props_dict_touse = self.mol_props_comparison_dict
            self.logger.debug("Using comparison dict for property data")

        else:
            self.mol_props_headers.append('MOL_CLP')
            self.mol_props_headers_numeric_position[self.mol_props_headers.index('MOL_CLP')] = 'MOL_CLP'
            mol_props_dict_touse = self.mol_props_dict

        clp_col = None
        id_col = None

        # load the csv file
        with open(temp_clp_out.name, "rt") as csv_file:
            
            reader = csv.reader(csv_file, delimiter=' ')
            i = -1
            for row in reader:

                # ignore the header row, but capture position of logp
                i += 1
                if i == 0:
                    if use_alogp:
                        clp_col = row.index('abr_Logp')
                        id_col = row.index('Name')
                    else:
                        clp_col = 1
                        id_col = 0
                    continue

                my_id = int(row[id_col])
                val = float(row[clp_col])

                if my_id in mol_props_dict_touse:
                    self.logger.warn("Duplicate ID seen, overwrite of property data for id: %s" % my_id)

                if my_id in mol_props_dict_touse:
                    mol_props_dict_touse[my_id].append(val)

                else:
                    mol_props_dict_touse[my_id] = []
                    mol_props_dict_touse[my_id].append(val)

        temp_clp_out.close()

        self.logger.info("Loaded %d CLP values from file" % i)

    def generate_mwt(self, input_smi=False, comparison_dict=False):
        """Use pymo.iwdescr to generate MWT data"""

        if input_smi is False:
            input_smi = self.temp_dicer_smifi.name

        temp_mwt_out = tempfile.NamedTemporaryFile(encoding='utf-8', mode='wt')

        # run pymo.iwdescr
        self.logger.info("Running pymo.iwdescr for MWT with in:%s, out:%s" % (input_smi, temp_mwt_out.name))
        exit_status = pymo.iwdescr(input_smi, temp_mwt_out.name,
                                 params_dict={'-l': '', '-v': ''}, loggero=self.logger)
        self.logger.debug("Ran iwdescr with exit status %s" % exit_status)

        # append header
        if comparison_dict:
            self.mol_props_comparison_headers.append('MOL_MWT')
            self.mol_props_comparison_headers_numeric_position[self.mol_props_comparison_headers.index('MOL_MWT')] = \
                'MOL_MWT'
            mol_props_dict_touse = self.mol_props_comparison_dict
            self.logger.debug("Using comparison dict for property data")

        else:
            self.mol_props_headers.append('MOL_MWT')
            self.mol_props_headers_numeric_position[self.mol_props_headers.index('MOL_MWT')] = 'MOL_MWT'
            mol_props_dict_touse = self.mol_props_dict
        
        # set the mwt
        with open(temp_mwt_out.name, "rt") as csv_file:

            reader = csv.reader(csv_file, delimiter=' ')
            i = -1
            for row in reader:
                
                # ignore header row
                i += 1
                
                if i == 0:
                    # TODO: pick the column location dynamically, don't hard code the loc
                    if row[4] != 'w_amw':
                        self.logger.warn("When this was written, MWT was in array position 4 (zero indexed) with "
                                         "column title w_amw.  Now it's not, it's: %s" % row[4])
                        sys.exit("When this was written, MWT was in array position 4 (zero indexed) with column "
                                 "title w_amw.  Now it's not, it's: %s" % row[4])
                    continue
                
                if int(row[0]) in mol_props_dict_touse:
                    mol_props_dict_touse[int(row[0])].append(float(row[4]))
                
                else:
                    mol_props_dict_touse[int(row[0])] = []
                    mol_props_dict_touse[int(row[0])].append(float(row[4]))
        
        csv_file.close()

        self.logger.info("Loaded %d MWT values from file" % i)

    def generate_all_props(self, input_smi=False, comparison_dict=False):
        """Use pymo.iwdescr to generate excessive amounts of property data"""

        if input_smi is False:
            input_smi = self.temp_dicer_smifi.name

        temp_mwt_out = tempfile.NamedTemporaryFile(encoding='utf-8', mode='wt')

        # run pymo.iwdescr
        self.logger.info("Running pymo.iwdescr with in:%s, out:%s" % (input_smi, temp_mwt_out.name))
        exit_status = pymo.iwdescr(input_smi, temp_mwt_out.name,
                                 params_dict={'-l': '', '-v': ''}, loggero = self.logger)
        self.logger.debug("Ran iwdescr with exit status %s" % exit_status)

        if comparison_dict:
            mol_props_dict_touse = self.mol_props_comparison_dict
            self.logger.debug("Using comparison dict for property data")

        else:
            mol_props_dict_touse = self.mol_props_dict
        
        # parse output
        with open(temp_mwt_out.name, "rt") as csv_file:

            reader = csv.reader(csv_file, delimiter=' ')
            i = -1
            for row in reader:
                
                i += 1

                # if header row, append headers
                if i == 0:

                    for header_raw in row:
                        header_str = str(header_raw).upper()

                        if comparison_dict:
                            self.mol_props_comparison_headers.append(header_str)
                            self.mol_props_comparison_headers_numeric_position[
                                self.mol_props_comparison_headers.index(header_str)] = header_str

                        else:
                            self.mol_props_headers.append(header_str)
                            self.mol_props_headers_numeric_position[self.mol_props_headers.index(header_str)] =\
                                header_str

                    continue

                # or add data
                tmp_row = []
                for val_ in row:
                    try:
                        tmp_row.append(float(val_))
                    except:
                        tmp_row.append(val_)
                row = tmp_row
                mol_props_dict_touse[int(row[0])] = row

        temp_mwt_out.close()

        self.logger.info("Parsed property data for %d molecules from file" % i)

    def get_data_diffs(self, molid_L, molid_R):
        """Method to generate an array of differences between
        two entries or arrays in the mol_data_dict
        """

        difference_array = []
        
        for idx, val in enumerate(self.mol_data_dict[molid_L]):

            try:
                temp_diff = '{:0.3e}'.format(self.mol_data_dict[molid_R][idx] - val)
            except:
                temp_diff = 'NaN'
            difference_array.append(temp_diff)
        
        return difference_array

    def get_prop_diffs(self, molid_L, molid_R):
        """Method to generate an array of differences between
        two entries or arrays in the mol_props_dict. Could consolidate
        this with get_data_diffs() but called so many times it's kept
        separate for now
        """
        difference_array = []

        for idx, val in enumerate(self.mol_props_dict[molid_L]):

            try:
                temp_diff = '{:0.3e}'.format(self.mol_props_dict[molid_R][idx] - val)
            except:
                temp_diff = 'NaN'
            difference_array.append(temp_diff)

        return difference_array

    def get_folddata_diffs(self, molid_L, molid_R):
        """Method to generate an array of differences between
        two entries or arrays in the mol_data_dict, we do not
        implement this for property data
        """

        difference_array = []

        for idx, val in enumerate(self.mol_data_dict[molid_L]):
            try:
                # fold diff
                temp_diff = self.mol_data_dict[molid_R][idx] / val
            except:
                temp_diff = 'n/a'
            difference_array.append(temp_diff)
                    
        return difference_array
    
    def get_pairs_and_diffs(self, out_file, cut_type, fold_diff=False,
                            inc_types_header=False, numeric_ids=False,
                            add_qmetric=False):
        """Method to print out the pairs from the input CSV with data differences

        out_file:
          The user specified output file
        
        cut_type:
          Specifies the type of fragmentation required.  Allowed values are SINGLE,
          DOUBLE or BOTH.  Currently this class does not support anything greater than
          double cut fragmentation
        
        Example usage:

            # give me a CSV named my_output.pairs of all the pairs:
            my_mmp_object.get_pairs_and_diffs('myoutput.csv', 'BOTH')

            # give me a CSV of only the DOUBLE cut pairs:
            my_mmp_object.get_pairs_and_diffs('myoutput.csv', 'DOUBLE')
        """

        if add_qmetric is True and self.add_prop_data == 0:
            raise Exception('Must specify prop_data=True when requesting add_qmetric as Quality metric needs CLP data')

        # check file write possible before start
        self.logger.info('Opening output file for write: %s' % out_file)

        # check cut_type, convert to int
        if cut_type.upper() == 'DOUBLE':
            # confusing but faster later
            cut_type_id = 3
        elif cut_type.upper() == 'BOTH':
            # confusing but faster later
            cut_type_id = 2
        elif cut_type.upper() == 'SINGLE':
            cut_type_id = 1
        else:
            self.logger.warn('cut_type specification is incorrect, using single cut: %s' % cut_type.upper())
            cut_type_id = 1

        # Quality metric needs clp data
        if add_qmetric:
            # remind ourselves where the clp data will be in a molecule property list
            clp_col_idx = self.mol_props_headers.index('MOL_CLP')

        # fail if both single_pairs_dict and double_pairs_dict are empty
        if (len(self.single_pairs_dict) == 0) and (len(self.double_pairs_dict) == 0):
            self.logger.debug('No data found in single_pairs_dict and/or double_pairs_dict, expect no results')
            # sys.exit("Error: no data found in single_pairs_dict and/or double_pairs_dict, nothing to find and write")
        
        # Now start processing the data structures to write the pairs
        with open(out_file, "w") as f:
            
            # write headers to CSV
            f.write("CUT,MOLID_L,MOLID_R,CONTEXT,FRAG_L,FRAG_R,ATTCHPT_CTX_L,ATTCHPT_FRAG_L,ATTCHPT_CTX_R,ATTCHPT_FRAG_R,")
            
            num_items = len(self.headers_numeric_position)
            idx = 0

            for item in self.headers_nosmi:
                if item in list(self.headers_numeric_position.values()):
                    idx += 1
                    if idx == num_items:
                        item += '_DIFF'
                        f.write(item)
                    else:
                        item += '_DIFF,'
                        f.write(item)

            num_items = len(self.mol_props_headers)
            idx = 0

            if self.add_prop_data != 0:
                for item in self.mol_props_headers:
                    idx += 1
                    if idx == 1:
                        item = "," + item + '_DIFF,'
                        f.write(item)
                    elif idx == num_items:
                        item += '_DIFF'
                        f.write(item)
                    else:
                        item += '_DIFF,'
                        f.write(item)

            if add_qmetric:
                f.write(',MOL_L_CLP,MOL_R_CLP')

            f.write('\n')

            num_items = len(self.headers_numeric_position)
            idx = 0

            if inc_types_header is True:

                # This is a bug fix for later mmp_pairs_object data aggregation, see comments in pd_read_cdv method
                self.types_header = True

                f.write("STRING,STRING,STRING,SMILES,SMILES,SMILES,STRING,STRING,STRING,STRING,")
                
                for item in self.headers_nosmi:
                    if item in list(self.headers_numeric_position.values()):
                        idx += 1
                        if idx == num_items:
                            f.write("REAL")
                        else:
                            f.write("REAL,")
                
                idx = 0
                if self.add_prop_data != 0:
                    for item in self.mol_props_headers:
                        idx += 1
                        if idx == 1:
                            f.write(",REAL,")
                        elif idx == num_items:
                            f.write("REAL")
                        else:
                            f.write("REAL,")

                f.write('\n')

            # print pairs for single
            if cut_type_id <= 2:
                # first get pairs via iterator_single_pairs_dict...
                if numeric_ids:
                    for molid_L, molid_R, ctx, frag_L, frag_R, fa_L, ca_L, fa_R, ca_R in \
                            self.iterator_single_pairs_dict_numeric(inc_attachpt=True):
                        if fold_diff:
                            diff_array = self.get_folddata_diffs(molid_L, molid_R)
                            if self.add_prop_data:
                                diff_array = diff_array + self.get_folddata_diffs(molid_L, molid_R)
                            # Quality metric needs clp data
                            if add_qmetric:
                                diff_array.extend([self.mol_props_dict[molid_L][clp_col_idx],
                                                   self.mol_props_dict[molid_R][clp_col_idx]])
                        else:
                            diff_array = self.get_data_diffs(molid_L, molid_R)
                            if self.add_prop_data:
                                diff_array = diff_array + self.get_prop_diffs(molid_L, molid_R)
                            # Quality metric needs clp data
                            if add_qmetric:
                                diff_array.extend([self.mol_props_dict[molid_L][clp_col_idx],
                                                   self.mol_props_dict[molid_R][clp_col_idx]])

                        num_items = len(diff_array) - 1
                        f.write('single,%d,%d,%s,%s,%s,%s,%s,%s,%s,' % (molid_L, molid_R, ctx, frag_L,
                                                                        frag_R, fa_L, ca_L, fa_R, ca_R))
                        for idx, val in enumerate(diff_array):
                            if idx == num_items:
                                f.write('%s\n' % val)
                            else:
                                f.write('%s,' % val)
                
                else:
                    for molid_L, molid_R, ctx, frag_L, frag_R, fa_L, ca_L, fa_R, ca_R in \
                            self.iterator_single_pairs_dict():
                        # ...now add the data differences
                        if fold_diff:
                            diff_array = self.get_folddata_diffs(molid_L, molid_R)
                            if self.add_prop_data:
                                diff_array = diff_array + self.get_prop_diffs(molid_L, molid_R)
                            # Quality metric needs clp data
                            if add_qmetric:
                                diff_array.extend([self.mol_props_dict[molid_L][clp_col_idx],
                                                   self.mol_props_dict[molid_R][clp_col_idx]])
                        else:
                            diff_array = self.get_data_diffs(molid_L, molid_R)
                            if self.add_prop_data:
                                diff_array = diff_array + self.get_prop_diffs(molid_L, molid_R)
                            # Quality metric needs clp data
                            if add_qmetric:
                                diff_array.extend([self.mol_props_dict[molid_L][clp_col_idx],
                                                   self.mol_props_dict[molid_R][clp_col_idx]])

                        num_items = len(diff_array) - 1
                        f.write('single,%d,%d,%s,%s,%s,%s,%s,%s,%s,' % (molid_L, molid_R, ctx, frag_L,
                                                                        frag_R, fa_L, ca_L, fa_R, ca_R))
                        for idx, val in enumerate(diff_array):
                            if idx == num_items:
                                f.write('%s\n' % val)
                            else:
                                f.write('%s,' % val)
            
            # print pairs for double
            if cut_type_id >= 2:
                # first get pairs via iterator_double_pairs_dict...
                if numeric_ids:
                    self.logger.warn('The use of numeric_ids with cut_type 2 (double cuts) is not yet supported')

                else:
                    for molid_L, molid_R, ctx, frag_L, frag_R, fa_L, ca_L, fa_R, ca_R in \
                            self.iterator_double_pairs_dict():
                        # ...now add the data differences
                        if fold_diff:
                            diff_array = self.get_folddata_diffs(molid_L, molid_R)
                            if self.add_prop_data:
                                diff_array = diff_array + self.get_prop_diffs(molid_L, molid_R)
                            # Quality metric needs clp data
                            if add_qmetric:
                                diff_array.extend([self.mol_props_dict[molid_L][clp_col_idx],
                                                   self.mol_props_dict[molid_R][clp_col_idx]])
                        else:
                            diff_array = self.get_data_diffs(molid_L, molid_R)
                            if self.add_prop_data:
                                diff_array = diff_array + self.get_prop_diffs(molid_L, molid_R)
                            # Quality metric needs clp data
                            if add_qmetric:
                                diff_array.extend([self.mol_props_dict[molid_L][clp_col_idx],
                                                   self.mol_props_dict[molid_R][clp_col_idx]])

                        num_items = len(diff_array) - 1
                        f.write('double,%d,%d,%s,%s,%s,%s,%s,%s,%s,' % (molid_L, molid_R, ctx, frag_L,
                                                                        frag_R, fa_L, ca_L, fa_R, ca_R))
                        for idx, val in enumerate(diff_array):
                            if idx == num_items:
                                f.write('%s\n' % val)
                            else:
                                f.write('%s,' % val)

        # close the file handle
        f.close()


class _TestMMPDataObjectClass(unittest.TestCase):
    """Test class for MMPDataObjectClass(object) written to use pythons unittest

    Example usage:

     python mmp_data_objects.py

     coverage run mmp_data_objects.py
     coverage report mmp_data_objects.py

    """

    def setUp(self):
        """Instantiate"""

        self.maxDiff = None

        self.temp_file_input_smi_01 = tempfile.NamedTemporaryFile(delete=False,
                                                                  suffix=".smi",
                                                                  encoding='utf-8',
                                                                  mode='wt')
        self.temp_file_input_smi_01b = tempfile.NamedTemporaryFile(delete=False,
                                                                   suffix=".smi",
                                                                   encoding='utf-8',
                                                                   mode='wt')
        self.temp_file_input_smi_02 = tempfile.NamedTemporaryFile(delete=False,
                                                                  suffix=".smi",
                                                                  encoding='utf-8',
                                                                  mode='wt')
        self.temp_file_input_csv = tempfile.NamedTemporaryFile(delete=False,
                                                               encoding='utf-8',
                                                               mode='wt')
        self.temp_file_output_pairs = tempfile.NamedTemporaryFile(delete=False,
                                                                  encoding='utf-8',
                                                                  mode='wt')

        self.mmplogger = logging.getLogger('mmpobjectclass_testlogger')
        # logging.disable(logging.CRITICAL)

        self.test_mmp_data_object = MMPDataObjectClass(self.mmplogger)

        # The following represent synthetic data, analogues of CHEMBL1382609
        # https://www.ebi.ac.uk/chembl/compound_report_card/CHEMBL1382609/
        # 1. substituents are added to the pyrazole ring to generate side chain MMPs
        #    H on CHEMBL1382609 between two methyls is changed to Br, F, C, I to
        #    visually see the change in the smiles string (avoiding Cl as already present)
        #    e.g.: N1C(=C(Br)C(=N1)C)C
        # 2. core ring system is modified (phenyl to pyridine) to see ring switch MMP's
        #    Presence/Absence of Pyridine-N and N-positional isomerism in Cl-Ph ring
        #    e.g.: C2=NC(=CS2)C2=CC=C(Cl)C=C2 + addition of N ->
        #          C2=NC(=CS2)C2=CN=C(Cl)C=C2 + move N around ring ->
        #          C2=NC(=CS2)C2=NC=C(Cl)C=C2

        self.test_dataset_goldeninput_smi_01 = {
            '001': 'N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
            '002': 'N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(F)C(=N1)C)C',
            '003': 'N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
            '004': 'N1(C2=NC(=CS2)C2=NC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
            '005': 'N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(F)C(=N1)C)C'
        }

        self.test_dataset_goldeninput_smi_01b = {
            '006': 'N1(C2=NC(=CS2)C2=NC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
            '007': 'N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(I)C(=N1)C)C',
            '008': 'N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(C)C(=N1)C)C'
        }

        self.test_dataset_goldeninput_smi_02 = {
            80: 'N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(I)C(=N1)C)C',
            81: 'N1(C2=NC(=CS2)C2=NC=C(Cl)C=C2)C(=C(I)C(=N1)C)C',
            82: 'N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(C)C(=N1)C)C',
            83: 'N1(C2=NC(=CS2)C2=NC=C(Cl)C=C2)C(=C(C)C(=N1)C)C'
        }

        self.test_dataset_goldeninput_csv_headers = \
            ['ID,SMILES,ACT_A,ACT_B,OTHER_INFO,CATEGORICAL_DATA_1,CATEGORICAL_DATA_2']

        self.test_dataset_goldeninput_csv_data = {
            '001,N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C,30.0,25.0,25,0,0': None,
            '002,N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(F)C(=N1)C)C,20.0,25.0,string,1,0': None,
            '003,N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(Br)C(=N1)C)C,10.0,15.0,25,1,1': None,
            '005,N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(F)C(=N1)C)C,20.0,30.0,text,1,1': None,
            '004,N1(C2=NC(=CS2)C2=NC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C,50.0,60.0,blah,0,1': None
        }

        self.test_dataset_list_of_context_smi = ['Brc1c([n][n](c2sc[1cH][n]2)c1C)C',
                                                 '[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1']

        # output results data for test comparison - actualy MMP's between above CHEML compounds
        self.test_dataset_goldenoutput_pairs_and_diffs = {
            'CUT,MOLID_L,MOLID_R,CONTEXT,FRAG_L,FRAG_R,ATTCHPT_CTX_L,ATTCHPT_FRAG_L,ATTCHPT_CTX_R,ATTCHPT_FRAG_R,ACT_A_DIFF,ACT_B_DIFF,CATEGORICAL_DATA_1_DIFF,CATEGORICAL_DATA_2_DIFF': None,
            'single,1,2,Clc1ccc(c2[n][1cH]sc2)cc1,Brc1c([1nH][n]c1C)C,Fc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'single,2,1,Clc1ccc(c2[n][1cH]sc2)cc1,Fc1c([1nH][n]c1C)C,Brc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'single,1,2,Clc1ccc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1BrH],[1FH],[1:C2],[1:BR],[1:C2],[1:F],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'single,2,1,Clc1ccc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1FH],[1BrH],[1:C2],[1:F],[1:C2],[1:BR],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'single,1,3,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1cc[1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],-2.000e+01,-1.000e+01,1.000e+00,1.000e+00': None,
            'single,1,4,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1cc[1cH]cc1,Clc1c[n][1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],2.000e+01,3.500e+01,0.000e+00,1.000e+00': None,
            'single,3,1,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1[n]c[1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],2.000e+01,1.000e+01,-1.000e+00,-1.000e+00': None,
            'single,3,4,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1[n]c[1cH]cc1,Clc1c[n][1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],4.000e+01,4.500e+01,-1.000e+00,0.000e+00': None,
            'single,4,1,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1c[n][1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],-2.000e+01,-3.500e+01,0.000e+00,-1.000e+00': None,
            'single,4,3,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1c[n][1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],-4.000e+01,-4.500e+01,1.000e+00,0.000e+00': None,
            'single,2,5,Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,Clc1cc[1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.000e+00,5.000e+00,0.000e+00,1.000e+00': None,
            'single,5,2,Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,Clc1[n]c[1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.000e+00,-5.000e+00,0.000e+00,-1.000e+00': None,
            'single,3,5,Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1c([1nH][n]c1C)C,Fc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'single,5,3,Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1c([1nH][n]c1C)C,Brc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'single,3,5,Clc1[n]cc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1BrH],[1FH],[1:C2],[1:BR],[1:C2],[1:F],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'single,5,3,Clc1[n]cc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1FH],[1BrH],[1:C2],[1:F],[1:C2],[1:BR],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,0.000e+00,1.000e+00,0.000e+00': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,0.000e+00,-1.000e+00,0.000e+00': None,
            'double,1,3,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[1cH]1cc[2cH]cc1,[n]1[1cH]cc[2cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],-2.000e+01,-1.000e+01,1.000e+00,1.000e+00': None,
            'double,1,3,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[2cH]1cc[1cH]cc1,[n]1[2cH]cc[1cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],-2.000e+01,-1.000e+01,1.000e+00,1.000e+00': None,
            'double,1,4,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[1cH]1cc[2cH]cc1,[n]1[2cH]cc[1cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[2:C2|1:CL],[1:CAR|2:CAR],2.000e+01,3.500e+01,0.000e+00,1.000e+00': None,
            'double,1,4,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[2cH]1cc[1cH]cc1,[n]1[1cH]cc[2cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[1:C2|2:CL],[2:CAR|1:CAR],2.000e+01,3.500e+01,0.000e+00,1.000e+00': None,
            'double,3,1,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[1cH]1cc[2cH]cc1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],2.000e+01,1.000e+01,-1.000e+00,-1.000e+00': None,
            'double,3,1,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[2cH]1cc[1cH]cc1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],2.000e+01,1.000e+01,-1.000e+00,-1.000e+00': None,
            'double,3,4,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[n]1[2cH]cc[1cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[2:C2|1:CL],[1:CAR|2:CAR],4.000e+01,4.500e+01,-1.000e+00,0.000e+00': None,
            'double,3,4,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[n]1[1cH]cc[2cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[1:C2|2:CL],[2:CAR|1:CAR],4.000e+01,4.500e+01,-1.000e+00,0.000e+00': None,
            'double,4,1,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[1cH]1cc[2cH]cc1,[2:C2|1:CL],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],-2.000e+01,-3.500e+01,0.000e+00,-1.000e+00': None,
            'double,4,1,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[2cH]1cc[1cH]cc1,[1:C2|2:CL],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],-2.000e+01,-3.500e+01,0.000e+00,-1.000e+00': None,
            'double,4,3,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[n]1[1cH]cc[2cH]c1,[2:C2|1:CL],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],-4.000e+01,-4.500e+01,1.000e+00,0.000e+00': None,
            'double,4,3,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[n]1[2cH]cc[1cH]c1,[1:C2|2:CL],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],-4.000e+01,-4.500e+01,1.000e+00,0.000e+00': None,
            'double,2,5,[1ClH].Fc1c([n](c2sc[2cH][n]2)[n]c1C)C,[1cH]1cc[2cH]cc1,[n]1[1cH]cc[2cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.000e+00,5.000e+00,0.000e+00,1.000e+00': None,
            'double,2,5,[2ClH].Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,[2cH]1cc[1cH]cc1,[n]1[2cH]cc[1cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.000e+00,5.000e+00,0.000e+00,1.000e+00': None,
            'double,5,2,[1ClH].Fc1c([n](c2sc[2cH][n]2)[n]c1C)C,[n]1[1cH]cc[2cH]c1,[1cH]1cc[2cH]cc1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.000e+00,-5.000e+00,0.000e+00,-1.000e+00': None,
            'double,5,2,[2ClH].Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,[n]1[2cH]cc[1cH]c1,[2cH]1cc[1cH]cc1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.000e+00,-5.000e+00,0.000e+00,-1.000e+00': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01,1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01,-1.500e+01,0.000e+00,0.000e+00': None}

        self.test_dataset_goldenoutput_pairs_and_diffs2 = copy.deepcopy(self.test_dataset_goldenoutput_pairs_and_diffs)
        self.test_dataset_goldenoutput_pairs_and_diffs2[
            'STRING,STRING,STRING,SMILES,SMILES,SMILES,STRING,STRING,STRING,STRING,REAL,REAL,REAL,REAL'] = None

        self.test_dataset_goldenoutput_pairs_and_diffs3 = {
            'CUT,MOLID_L,MOLID_R,CONTEXT,FRAG_L,FRAG_R,ATTCHPT_CTX_L,ATTCHPT_FRAG_L,ATTCHPT_CTX_R,ATTCHPT_FRAG_R,ACT_A_DIFF': None,
            'single,1,2,Clc1ccc(c2[n][1cH]sc2)cc1,Brc1c([1nH][n]c1C)C,Fc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],-1.000e+01': None,
            'single,2,1,Clc1ccc(c2[n][1cH]sc2)cc1,Fc1c([1nH][n]c1C)C,Brc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],1.000e+01': None,
            'single,1,2,Clc1ccc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1BrH],[1FH],[1:C2],[1:BR],[1:C2],[1:F],-1.000e+01': None,
            'single,2,1,Clc1ccc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1FH],[1BrH],[1:C2],[1:F],[1:C2],[1:BR],1.000e+01': None,
            'single,1,3,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1cc[1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],-2.000e+01': None,
            'single,1,4,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1cc[1cH]cc1,Clc1c[n][1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],2.000e+01': None,
            'single,3,1,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1[n]c[1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],2.000e+01': None,
            'single,3,4,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1[n]c[1cH]cc1,Clc1c[n][1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],4.000e+01': None,
            'single,4,1,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1c[n][1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],-2.000e+01': None,
            'single,4,3,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1c[n][1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],-4.000e+01': None,
            'single,2,5,Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,Clc1cc[1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.000e+00': None,
            'single,5,2,Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,Clc1[n]c[1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.000e+00': None,
            'single,3,5,Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1c([1nH][n]c1C)C,Fc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],1.000e+01': None,
            'single,5,3,Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1c([1nH][n]c1C)C,Brc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],-1.000e+01': None,
            'single,3,5,Clc1[n]cc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1BrH],[1FH],[1:C2],[1:BR],[1:C2],[1:F],1.000e+01': None,
            'single,5,3,Clc1[n]cc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1FH],[1BrH],[1:C2],[1:F],[1:C2],[1:BR],-1.000e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,1,3,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[1cH]1cc[2cH]cc1,[n]1[1cH]cc[2cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],-2.000e+01': None,
            'double,1,3,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[2cH]1cc[1cH]cc1,[n]1[2cH]cc[1cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],-2.000e+01': None,
            'double,1,4,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[1cH]1cc[2cH]cc1,[n]1[2cH]cc[1cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[2:C2|1:CL],[1:CAR|2:CAR],2.000e+01': None,
            'double,1,4,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[2cH]1cc[1cH]cc1,[n]1[1cH]cc[2cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[1:C2|2:CL],[2:CAR|1:CAR],2.000e+01': None,
            'double,3,1,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[1cH]1cc[2cH]cc1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],2.000e+01': None,
            'double,3,1,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[2cH]1cc[1cH]cc1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],2.000e+01': None,
            'double,3,4,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[n]1[2cH]cc[1cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[2:C2|1:CL],[1:CAR|2:CAR],4.000e+01': None,
            'double,3,4,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[n]1[1cH]cc[2cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[1:C2|2:CL],[2:CAR|1:CAR],4.000e+01': None,
            'double,4,1,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[1cH]1cc[2cH]cc1,[2:C2|1:CL],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],-2.000e+01': None,
            'double,4,1,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[2cH]1cc[1cH]cc1,[1:C2|2:CL],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],-2.000e+01': None,
            'double,4,3,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[n]1[1cH]cc[2cH]c1,[2:C2|1:CL],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],-4.000e+01': None,
            'double,4,3,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[n]1[2cH]cc[1cH]c1,[1:C2|2:CL],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],-4.000e+01': None,
            'double,2,5,[1ClH].Fc1c([n](c2sc[2cH][n]2)[n]c1C)C,[1cH]1cc[2cH]cc1,[n]1[1cH]cc[2cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.000e+00': None,
            'double,2,5,[2ClH].Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,[2cH]1cc[1cH]cc1,[n]1[2cH]cc[1cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.000e+00': None,
            'double,5,2,[1ClH].Fc1c([n](c2sc[2cH][n]2)[n]c1C)C,[n]1[1cH]cc[2cH]c1,[1cH]1cc[2cH]cc1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.000e+00': None,
            'double,5,2,[2ClH].Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,[n]1[2cH]cc[1cH]c1,[2cH]1cc[1cH]cc1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.000e+00': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.000e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.000e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],-1.000e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],-1.000e+01': None}

        self.test_dataset_goldenoutput_pairs_and_diffs4 = {
            'CUT,MOLID_L,MOLID_R,CONTEXT,FRAG_L,FRAG_R,ATTCHPT_CTX_L,ATTCHPT_FRAG_L,ATTCHPT_CTX_R,ATTCHPT_FRAG_R,ACT_A_DIFF,MOL_CLP_DIFF,MOL_MWT_DIFF': None,
            'single,1,2,Clc1ccc(c2[n][1cH]sc2)cc1,Brc1c([1nH][n]c1C)C,Fc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'single,2,1,Clc1ccc(c2[n][1cH]sc2)cc1,Fc1c([1nH][n]c1C)C,Brc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],1.5,6.697e-01,6.091e+01': None,
            'single,1,2,Clc1ccc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1BrH],[1FH],[1:C2],[1:BR],[1:C2],[1:F],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'single,2,1,Clc1ccc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1FH],[1BrH],[1:C2],[1:F],[1:C2],[1:BR],1.5,6.697e-01,6.091e+01': None,
            'single,1,3,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1cc[1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.3333333333333333,-1.348e+00,9.900e-01': None,
            'single,1,4,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1cc[1cH]cc1,Clc1c[n][1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],1.6666666666666667,-1.348e+00,9.900e-01': None,
            'single,3,1,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1[n]c[1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],3.0,1.348e+00,-9.900e-01': None,
            'single,3,4,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1[n]c[1cH]cc1,Clc1c[n][1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],5.0,1.000e-06,0.000e+00': None,
            'single,4,1,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1c[n][1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.6,1.348e+00,-9.900e-01': None,
            'single,4,3,Brc1c([n][n](c2sc[1cH][n]2)c1C)C,Clc1c[n][1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],0.2,-1.000e-06,0.000e+00': None,
            'single,2,5,Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,Clc1cc[1cH]cc1,Clc1[n]c[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],1.0,-1.348e+00,9.900e-01': None,
            'single,5,2,Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,Clc1[n]c[1cH]cc1,Clc1cc[1cH]cc1,[1:C2],[1:CAR],[1:C2],[1:CAR],1.0,1.348e+00,-9.900e-01': None,
            'single,3,5,Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1c([1nH][n]c1C)C,Fc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'single,5,3,Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1c([1nH][n]c1C)C,Brc1c([1nH][n]c1C)C,[1:C2],[1:NPL3],[1:C2],[1:NPL3],0.5,6.697e-01,6.091e+01': None,
            'single,3,5,Clc1[n]cc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1BrH],[1FH],[1:C2],[1:BR],[1:C2],[1:F],2.0,-6.697e-01,-6.091e+01': None,
            'single,5,3,Clc1[n]cc(c2csc([n]3[n]c([1cH]c3C)C)[n]2)cc1,[1FH],[1BrH],[1:C2],[1:F],[1:C2],[1:BR],0.5,6.697e-01,6.091e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,1,2,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.6666666666666666,-6.697e-01,-6.091e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[1CH4].Clc1ccc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,2,1,[2CH4].Clc1ccc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],1.5,6.697e-01,6.091e+01': None,
            'double,1,3,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[1cH]1cc[2cH]cc1,[n]1[1cH]cc[2cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.3333333333333333,-1.348e+00,9.900e-01': None,
            'double,1,3,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[2cH]1cc[1cH]cc1,[n]1[2cH]cc[1cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.3333333333333333,-1.348e+00,9.900e-01': None,
            'double,1,4,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[1cH]1cc[2cH]cc1,[n]1[2cH]cc[1cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[2:C2|1:CL],[1:CAR|2:CAR],1.6666666666666667,-1.348e+00,9.900e-01': None,
            'double,1,4,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[2cH]1cc[1cH]cc1,[n]1[1cH]cc[2cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[1:C2|2:CL],[2:CAR|1:CAR],1.6666666666666667,-1.348e+00,9.900e-01': None,
            'double,3,1,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[1cH]1cc[2cH]cc1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],3.0,1.348e+00,-9.900e-01': None,
            'double,3,1,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[2cH]1cc[1cH]cc1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],3.0,1.348e+00,-9.900e-01': None,
            'double,3,4,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[n]1[2cH]cc[1cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[2:C2|1:CL],[1:CAR|2:CAR],5.0,1.000e-06,0.000e+00': None,
            'double,3,4,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[n]1[1cH]cc[2cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[1:C2|2:CL],[2:CAR|1:CAR],5.0,1.000e-06,0.000e+00': None,
            'double,4,1,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[1cH]1cc[2cH]cc1,[2:C2|1:CL],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.6,1.348e+00,-9.900e-01': None,
            'double,4,1,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[2cH]1cc[1cH]cc1,[1:C2|2:CL],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.6,1.348e+00,-9.900e-01': None,
            'double,4,3,[1ClH].Brc1c([n][n](c2sc[2cH][n]2)c1C)C,[n]1[2cH]cc[1cH]c1,[n]1[1cH]cc[2cH]c1,[2:C2|1:CL],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],0.2,-1.000e-06,0.000e+00': None,
            'double,4,3,[2ClH].Brc1c([n][n](c2sc[1cH][n]2)c1C)C,[n]1[1cH]cc[2cH]c1,[n]1[2cH]cc[1cH]c1,[1:C2|2:CL],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],0.2,-1.000e-06,0.000e+00': None,
            'double,2,5,[1ClH].Fc1c([n](c2sc[2cH][n]2)[n]c1C)C,[1cH]1cc[2cH]cc1,[n]1[1cH]cc[2cH]c1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],1.0,-1.348e+00,9.900e-01': None,
            'double,2,5,[2ClH].Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,[2cH]1cc[1cH]cc1,[n]1[2cH]cc[1cH]c1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],1.0,-1.348e+00,9.900e-01': None,
            'double,5,2,[1ClH].Fc1c([n](c2sc[2cH][n]2)[n]c1C)C,[n]1[1cH]cc[2cH]c1,[1cH]1cc[2cH]cc1,[1:CL|2:C2],[1:CAR|2:CAR],[1:CL|2:C2],[1:CAR|2:CAR],1.0,1.348e+00,-9.900e-01': None,
            'double,5,2,[2ClH].Fc1c([n](c2sc[1cH][n]2)[n]c1C)C,[n]1[2cH]cc[1cH]c1,[2cH]1cc[1cH]cc1,[2:CL|1:C2],[2:CAR|1:CAR],[2:CL|1:C2],[2:CAR|1:CAR],1.0,1.348e+00,-9.900e-01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][n][2nH]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][n][1nH]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Brc1[1cH][2nH][n]c1C,Fc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,3,5,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Brc1[2cH][1nH][n]c1C,Fc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],2.0,-6.697e-01,-6.091e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][n][2nH]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][n][1nH]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][n][2nH]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][n][1nH]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[1CH4].Clc1[n]cc(c2[n][2cH]sc2)cc1,Fc1[1cH][2nH][n]c1C,Brc1[1cH][2nH][n]c1C,[1:C3|2:C2],[1:C2|2:NPL3],[1:C3|2:C2],[1:C2|2:NPL3],0.5,6.697e-01,6.091e+01': None,
            'double,5,3,[2CH4].Clc1[n]cc(c2[n][1cH]sc2)cc1,Fc1[2cH][1nH][n]c1C,Brc1[2cH][1nH][n]c1C,[2:C3|1:C2],[2:C2|1:NPL3],[2:C3|1:C2],[2:C2|1:NPL3],0.5,6.697e-01,6.091e+01': None}

        for key, value in self.test_dataset_goldenoutput_pairs_and_diffs.items():
            tmp_key_list = key.split(',')
            tmp_key_list.pop()
            tmp_key_list.pop()
            tmp_key_list.pop()
            tmp_key = ",".join(tmp_key_list)
            tmp_key = tmp_key.rstrip(', ').rstrip(',')
            self.test_dataset_goldenoutput_pairs_and_diffs3[tmp_key] = None

        # write test data to temp file (smi)
        for smi_id, smi in list(self.test_dataset_goldeninput_smi_01.items()):
            self.temp_file_input_smi_01.write(smi + " " + smi_id + "\n")
        self.temp_file_input_smi_01.close()

        for smi_id, smi in list(self.test_dataset_goldeninput_smi_01b.items()):
            self.temp_file_input_smi_01b.write(smi + " " + smi_id + "\n")
        self.temp_file_input_smi_01b.close()

        for smi_id, smi in list(self.test_dataset_goldeninput_smi_02.items()):
            self.temp_file_input_smi_02.write(smi + " " + str(smi_id) + "\n")
        self.temp_file_input_smi_02.close()

        # write test data to temp file (csv)
        self.temp_file_input_csv.write(', '.join(self.test_dataset_goldeninput_csv_headers) + "\n")
        for data in list(self.test_dataset_goldeninput_csv_data.keys()):
            self.temp_file_input_csv.write(data + "\n")
        self.temp_file_input_csv.close()

        # container for results data
        self.test_dataset_testresults = {}

    def tearDown(self):
        """Tear down object for clean reuse in further tests"""
        # clean out the object
        self.test_mmp_data_object.clean_out_data()
        # clean out the temp data store
        self.test_dataset_testresults.clear()

        os.remove(self.temp_file_input_smi_01.name)
        os.remove(self.temp_file_input_csv.name)
        os.remove(self.temp_file_output_pairs.name)

    def test_build_comparison_smidict(self):
        """ """
        self.test_mmp_data_object.build_comparison_smidict(self.temp_file_input_smi_02.name, add_prop_data=2)
        # not the best test but simple method simple test
        self.assertEqual(self.test_mmp_data_object.mol_smi_comparison_dict, self.test_dataset_goldeninput_smi_02)

        self.assertEqual(len(self.test_mmp_data_object.mol_props_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_comparison_dict), 4)

    def test_csv_sniffer(self):
        """Test method to sniff/prescan CSV file to determine format"""

        # 1. scan CSV
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')

        #
        # Equality test on base objects
        #
        # print(self.test_mmp_data_object.headers_nosmi)
        self.assertEqual(self.test_mmp_data_object.headers_nosmi,
                         ['ACT_A', 'ACT_B', 'OTHER_INFO', 'CATEGORICAL_DATA_1', 'CATEGORICAL_DATA_2']
                         )
        # print(self.test_mmp_data_object.headers_numeric_position)
        self.assertEqual(self.test_mmp_data_object.headers_numeric_position,
                         {2: 'ACT_A', 3: 'ACT_B', 5: 'CATEGORICAL_DATA_1', 6: 'CATEGORICAL_DATA_2'}
                         )
        # print(self.test_mmp_data_object.csv_items_per_line)
        self.assertEqual(self.test_mmp_data_object.csv_items_per_line, 7)
        # print(self.test_mmp_data_object.smi_col_num)
        self.assertEqual(self.test_mmp_data_object.smi_col_num, 1)
        # print(self.test_mmp_data_object.molid_col_num)
        self.assertEqual(self.test_mmp_data_object.molid_col_num, 0)

        # print(self.test_mmp_data_object.csv_dialect.__name__)
        self.assertEqual(self.test_mmp_data_object.csv_dialect.__name__, 'dialect')

    def test_csv_sniffer_skip_num_check(self):
        """Test method to sniff/prescan CSV file to determine format"""

        # 1. scan CSV
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID', skip_num_check=True)

        #
        # Equality test on base objects
        #
        # print(self.test_mmp_data_object.headers_nosmi)
        self.assertEqual(self.test_mmp_data_object.headers_nosmi,
                         ['ACT_A', 'ACT_B', 'OTHER_INFO', 'CATEGORICAL_DATA_1', 'CATEGORICAL_DATA_2']
                         )
        # print(self.test_mmp_data_object.headers_numeric_position)
        self.assertEqual(self.test_mmp_data_object.headers_numeric_position,
                         # without skip_num_check set as True we got this:
                         # {2: 'ACT_A', 3: 'ACT_B', 5: 'CATEGORICAL_DATA_1', 6: 'CATEGORICAL_DATA_2'}
                         {2: 'ACT_A', 3: 'ACT_B', 4: 'OTHER_INFO', 5: 'CATEGORICAL_DATA_1', 6: 'CATEGORICAL_DATA_2'}
                         )
        #
        # Tested again as per test_csv_sniffer, not really needed here but inc anyway to reassert
        #
        # print(self.test_mmp_data_object.csv_items_per_line)
        self.assertEqual(self.test_mmp_data_object.csv_items_per_line, 7)
        # print(self.test_mmp_data_object.smi_col_num)
        self.assertEqual(self.test_mmp_data_object.smi_col_num, 1)
        # print(self.test_mmp_data_object.molid_col_num)
        self.assertEqual(self.test_mmp_data_object.molid_col_num, 0)

        # print(self.test_mmp_data_object.csv_dialect.__name__)
        self.assertEqual(self.test_mmp_data_object.csv_dialect.__name__, 'dialect')

    def test_csv_to_data_objects(self):
        """Test method to load CSV file into data objects assuming it's already been prescanned"""

        # 2. scan and parse CSV
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID')

        # equality test
        # print(self.test_mmp_data_object.mol_smi_dict)
        self.assertEqual(self.test_mmp_data_object.mol_smi_dict,
                         {1: 'N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
                          2: 'N1(C2=NC(=CS2)C2=CC=C(Cl)C=C2)C(=C(F)C(=N1)C)C',
                          3: 'N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
                          4: 'N1(C2=NC(=CS2)C2=NC=C(Cl)C=C2)C(=C(Br)C(=N1)C)C',
                          5: 'N1(C2=NC(=CS2)C2=CN=C(Cl)C=C2)C(=C(F)C(=N1)C)C'}
                         )

        # print(self.test_mmp_data_object.mol_data_dict)
        self.assertEqual(self.test_mmp_data_object.mol_data_dict,
                         {1: [30.0, 25.0, 0.0, 0.0],
                          2: [20.0, 25.0, 1.0, 0.0],
                          3: [10.0, 15.0, 1.0, 1.0],
                          4: [50.0, 60.0, 0.0, 1.0],
                          5: [20.0, 30.0, 1.0, 1.0]}
                         )

    def test_write_mol_smi_dict_tofile(self):
        """Test method to write out the SMI data into a SMI file"""

        # 3. scan and parse CSV then write SMILES file back out
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID')
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()

        # now read it back into temp object and check it's what we wrote out!
        test_results_filehandle = open(tmp_dicer_file, 'r')
        for line in test_results_filehandle:
            line = line.rstrip('\r')
            line = line.rstrip('\n')
            self.test_dataset_testresults[int(line.split()[1])] = line.split()[0]
        test_results_filehandle.close()

        self.assertEqual(self.test_dataset_testresults, self.test_mmp_data_object.mol_smi_dict)

    def test_build_from_dicer(self):
        """Test method to read DICER output into pairs dicts"""

        # 4. build pairs dicts from dicer output
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID')
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')

        # Below refsmi_dict gets too big to print so we'll simply check num entries
        # print(self.test_mmp_data_object.refsmi_dict)
        # print(len(self.test_mmp_data_object.refsmi_dict))
        self.assertEqual(len(self.test_mmp_data_object.refsmi_dict), 160)

        # Below single_pairs_dict gets too big to print so we'll simply check num entries
        # print(self.test_mmp_data_object.single_pairs_dict)
        # print(len(self.test_mmp_data_object.single_pairs_dict))
        self.assertEqual(len(self.test_mmp_data_object.single_pairs_dict), 51)

        #print(self.test_mmp_data_object.double_pairs_dict)
        self.assertEqual(self.test_mmp_data_object.double_pairs_dict,
                         {50: {13: (3, 4)}, 99: {43: (6, 4), 76: (6, 4), 493: (6, 4), 558: (6, 4)}, 118: {103: (8, 9)},
                          649: {208: (12, 13), 1481: (12, 13), 3155: (18, 13)}, 555: {18: (15, 4)},
                          1161: {627: (17, 9)}, 1414: {228: (12, 13), 1590: (12, 13)}, 1171: {24: (3, 4)},
                          1369: {62: (6, 4), 101: (6, 4), 589: (6, 4), 660: (6, 4)}, 1223: {132: (8, 9)},
                          2528: {39: (15, 4)}, 3369: {735: (17, 9)}, 2623: {31: (3, 4)},
                          2917: {73: (6, 4), 115: (6, 4)}, 2699: {148: (8, 9)}}
                         )

    def test_generate_std_smiles(self):
        """Test method to standardise smiles"""

        # scan and parse CSV then write SMILES file back out
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID')
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()

        self.test_mmp_data_object.mol_smi_dict = self.test_mmp_data_object.generate_std_smiles(tmp_dicer_file,
                                                                                               smi_id_map='both')
        # print self.test_mmp_data_object.mol_smi_dict
        self.assertEqual(
            {1: 'Brc1c([n][n](c2scc([n]2)c2ccc(Cl)cc2)c1C)C',
             2: 'Clc1ccc(c2csc([n]3[n]c(c(F)c3C)C)[n]2)cc1',
             3: 'Brc1c([n][n](c2scc([n]2)c2c[n]c(Cl)cc2)c1C)C',
             4: 'Brc1c([n][n](c2scc(c3[n]cc(Cl)cc3)[n]2)c1C)C',
             5: 'Clc1[n]cc(c2csc([n]3[n]c(c(F)c3C)C)[n]2)cc1',
             'Brc1c([n][n](c2scc([n]2)c2ccc(Cl)cc2)c1C)C': 1,
             'Brc1c([n][n](c2scc(c3[n]cc(Cl)cc3)[n]2)c1C)C': 4,
             'Clc1ccc(c2csc([n]3[n]c(c(F)c3C)C)[n]2)cc1': 2,
             'Brc1c([n][n](c2scc([n]2)c2c[n]c(Cl)cc2)c1C)C': 3,
             'Clc1[n]cc(c2csc([n]3[n]c(c(F)c3C)C)[n]2)cc1': 5},
             self.test_mmp_data_object.mol_smi_dict
        )

    def test_get_pairs_and_diffs(self):
        """Test method to get pairs and pair diffs"""

        # 5. full build then write of pairs to file
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID')
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH')

        # now read it back into temp object and check it's what we wrote out!
        test_results_filehandle = open(self.temp_file_output_pairs.name, 'r')
        for line in test_results_filehandle:
            line = line.rstrip('\r')
            line = line.rstrip('\n')
            self.test_dataset_testresults[line] = None
        test_results_filehandle.close()
        # print(self.test_dataset_testresults)
        self.assertEqual(self.test_dataset_goldenoutput_pairs_and_diffs, self.test_dataset_testresults)

    def test_get_pairs_and_diffs_withnamedcol(self):
        """Test method to get pairs and pair diffs"""

        # 5b. full build then write of pairs to file, but only for a single named column
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID',
                                                      act_data_col='ACT_A')
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH')

        # now read it back into temp object and check it's what we wrote out!
        test_results_filehandle = open(self.temp_file_output_pairs.name, 'r')
        for line in test_results_filehandle:
            line = line.rstrip('\r')
            line = line.rstrip('\n')
            self.test_dataset_testresults[line] = None
        test_results_filehandle.close()

        # print(self.test_dataset_testresults)
        self.assertEqual(self.test_dataset_goldenoutput_pairs_and_diffs3, self.test_dataset_testresults)

    def test_get_pairs_and_diffs_withpropdiffs(self):
        """Test method to get pairs and pair diffs with added property difference"""

        # 5b. full build then write of pairs to file, but only for a single named column
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID',
                                                      act_data_col='ACT_A', add_prop_diff=1)
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH',
                                                      fold_diff=True)

        # now read it back into temp object and check it's what we wrote out!
        test_results_filehandle = open(self.temp_file_output_pairs.name, 'r')
        for line in test_results_filehandle:
            line = line.rstrip('\r')
            line = line.rstrip('\n')
            self.test_dataset_testresults[line] = None
        test_results_filehandle.close()

        #print(self.test_dataset_testresults)
        self.assertEqual(self.test_dataset_goldenoutput_pairs_and_diffs4, self.test_dataset_testresults)

    def test_get_pairs_and_diffs_withpropdiffs_and_qmetric(self):
        """Test method to get pairs and pair diffs with added property difference"""

        # 5b. full build then write of pairs to file, but only for a single named column
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID',
                                                      act_data_col='ACT_A', add_prop_diff=1)
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH',
                                                      fold_diff=True, add_qmetric=True)

        # now read it back into temp object and check it's what we wrote out!
        idx_ = 0
        with open(self.temp_file_output_pairs.name, mode='r') as results_file:
            reader = csv.reader(results_file)
            for line in reader:
                idx_ += 1
                self.test_dataset_testresults[idx_] = line

        headers_ = ['CUT', 'MOLID_L', 'MOLID_R', 'CONTEXT', 'FRAG_L', 'FRAG_R',
                    'ATTCHPT_CTX_L', 'ATTCHPT_FRAG_L', 'ATTCHPT_CTX_R', 'ATTCHPT_FRAG_R',
                    'ACT_A_DIFF', 'MOL_CLP_DIFF', 'MOL_MWT_DIFF', 'MOL_L_CLP', 'MOL_R_CLP']

        # too much data so just validate the data shape and headers
        self.assertEqual(len(self.test_dataset_testresults), 65)
        self.assertEqual(self.test_dataset_testresults[1], headers_)
        self.assertEqual(len(self.test_dataset_testresults[10]), 15)
        self.assertEqual(len(self.test_dataset_testresults[10]), 15)
        self.assertIsInstance(float(self.test_dataset_testresults[10][14]), float)

    def test_get_pairs_and_diffs_withpropdiffs_v2(self):
        """Test method to get pairs and pair diffs with added property difference"""

        # 5b. full build then write of pairs to file, but only for a single named column
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID',
                                                      act_data_col='ACT_A', add_prop_diff=1)
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH',
                                                      fold_diff=True)

        # now read it back into temp object and check it's what we wrote out!
        idx_ = 0
        #print(self.temp_file_output_pairs.name)
        with open(self.temp_file_output_pairs.name, mode='r') as results_file:
            reader = csv.reader(results_file)
            for line in reader:
                idx_ += 1
                self.test_dataset_testresults[idx_] = line

        headers_ = ['CUT', 'MOLID_L', 'MOLID_R', 'CONTEXT', 'FRAG_L', 'FRAG_R', 'ATTCHPT_CTX_L',
                    'ATTCHPT_FRAG_L', 'ATTCHPT_CTX_R', 'ATTCHPT_FRAG_R', 'ACT_A_DIFF', 'MOL_CLP_DIFF', 'MOL_MWT_DIFF']

        # too much data so just validate the data shape and headers
        self.assertEqual(len(self.test_dataset_testresults), 65)
        self.assertEqual(self.test_dataset_testresults[1], headers_)
        self.assertGreater(len(self.test_dataset_testresults[10]), 10)
        self.assertGreater(len(self.test_dataset_testresults[10]), 10)
        # print float(self.test_dataset_testresults[10][14])
        self.assertIsInstance(float(self.test_dataset_testresults[10][11]), float)
        # not sure this next one will work as we cannot guarantee the order of the rows in the csv
        # self.assertEquals(float(self.test_dataset_testresults[10][14]), 4.222)
        # print(self.test_dataset_testresults)
        # self.assertEqual(self.test_dataset_goldenoutput_pairs_and_diffs4, self.test_dataset_testresults)

    def test_get_pairs_and_diffs_manypropdiffs(self):
        """Test method to get pairs and pair diffs with a huge number of added property difference"""

        # 5c. full build then write of pairs to file, but only for a single named column
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID',
                                                      act_data_col='ACT_A', add_prop_diff=2)
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH', fold_diff=False)

        # now read it back into temp object and check it's what we wrote out!
        idx_ = 0
        with open(self.temp_file_output_pairs.name, mode='r') as results_file:
            reader = csv.reader(results_file)
            for line in reader:
                idx_ += 1
                self.test_dataset_testresults[idx_] = line

        # check the shape as too much data to store
        self.assertEqual(len(self.test_dataset_testresults), 65)
        self.assertGreater(len(self.test_dataset_testresults[1]), 200)

    def test_use_of_comparison_dicts(self):
        """Functional test where we load smiles and data into main data objects and check they are
        populated with no data leaks into comparison data objects.  We then clean up and do the
        to ensure when loading comparison smiles we don't contaminate the main data stores"""

        # 5c. full build
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID',
                                                      act_data_col='ACT_A', add_prop_diff=2)
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')

        # ensure we only have data in main data storage containers not comparison ones
        self.assertEqual(len(self.test_mmp_data_object.mol_data_dict), 5)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_dict), 5)
        self.assertGreater(len(self.test_mmp_data_object.mol_props_headers), 200)
        self.assertGreater(len(self.test_mmp_data_object.mol_props_headers_numeric_position), 200)
        self.assertEqual(len(self.test_mmp_data_object.mol_smi_dict), 5)
        self.assertEqual(len(self.test_mmp_data_object.single_pairs_dict), 51)
        self.assertEqual(len(self.test_mmp_data_object.double_pairs_dict), 15)
        # comparison dicts
        self.assertEqual(len(self.test_mmp_data_object.mol_props_comparison_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_comparison_headers), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_comparison_headers_numeric_position), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_smi_comparison_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.single_pairs_comparison_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.double_pairs_comparison_dict), 0)

        # stat again but now use comparison dict
        self.test_mmp_data_object.clean_out_data()
        #
        self.test_mmp_data_object.build_from_dicer(self.temp_file_input_smi_01.name, 'BOTH', 'NONE',
                                                   use_comparison_dict=True)
        self.test_mmp_data_object.build_comparison_smidict(self.temp_file_input_smi_01.name,
                                                           add_prop_data=2)

        # ensure we only have data in comparison data storage containers not main ones
        # ensure we only have data in main data storage containers not comparison ones
        self.assertEqual(len(self.test_mmp_data_object.mol_data_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_headers), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_props_headers_numeric_position), 0)
        self.assertEqual(len(self.test_mmp_data_object.mol_smi_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.single_pairs_dict), 0)
        self.assertEqual(len(self.test_mmp_data_object.double_pairs_dict), 0)
        # comparison dicts
        self.assertEqual(len(self.test_mmp_data_object.mol_props_comparison_dict), 5)
        self.assertGreater(len(self.test_mmp_data_object.mol_props_comparison_headers), 200)
        self.assertGreater(len(self.test_mmp_data_object.mol_props_comparison_headers_numeric_position), 200)
        self.assertEqual(len(self.test_mmp_data_object.mol_smi_comparison_dict), 5)
        self.assertEqual(len(self.test_mmp_data_object.single_pairs_comparison_dict), 51)
        self.assertEqual(len(self.test_mmp_data_object.double_pairs_comparison_dict), 15)

    def test_get_pairs_and_diffs_with_header_types(self):
        """Test method to get pairs and pair diffs with additional header line"""

        # 6. full build then write of pairs to file
        self.test_mmp_data_object.csv_sniffer(self.temp_file_input_csv.name, 'SMILES', 'ID')
        self.test_mmp_data_object.csv_to_data_objects(self.temp_file_input_csv.name, 'SMILES', 'ID')
        tmp_dicer_file = self.test_mmp_data_object.write_mol_smi_dict_tofile()
        self.test_mmp_data_object.build_from_dicer(tmp_dicer_file, 'BOTH', 'NONE')
        self.test_mmp_data_object.get_pairs_and_diffs(self.temp_file_output_pairs.name, 'BOTH', inc_types_header=True)

        # now read it back into temp object and check it's what we wrote out!
        test_results_filehandle = open(self.temp_file_output_pairs.name, 'r')
        for line in test_results_filehandle:
            line = line.rstrip('\r')
            line = line.rstrip('\n')
            self.test_dataset_testresults[line] = None
        test_results_filehandle.close()

        # print(self.test_dataset_testresults)
        self.assertEqual(self.test_dataset_goldenoutput_pairs_and_diffs2, self.test_dataset_testresults)


if __name__ == '__main__':
    unittest.main()

