"""Plot one or more collections of molecule information.

Consumes proto files generated by generate_profile.
Specify two or more such files on the command line.
A minimal usage might be

plot_collections.py CHEMBL_w_natoms.dat PUBCHEM_w_natoms.dat

which generates a plot containing the natoms distributions
for CHEMBL and PUBCHEM, previous computed.

Display will be to the screen. If the --stem option is specified
a png file will be created instead.
"""

from dataclasses import dataclass
from dataclasses import field
import sys
from typing import List, Tuple

from absl import app
from absl import flags
from absl import logging

from google.protobuf import text_format

import matplotlib.pyplot as plt

import numpy as np

import collection_pb2

FLAGS = flags.FLAGS

flags.DEFINE_multi_string("compare", [], "collections to plot (the stems from generate_profile)")
flags.DEFINE_string("feature_descriptions", "", "File containing feature descriptions")
flags.DEFINE_list("color", [], "CSV list of color for each collection")
flags.DEFINE_string("stem", "", "name stem for .png files")
flags.DEFINE_float('X', 0.0, "Figure size (X) for .png output")
flags.DEFINE_float('Y', 0.0, "Figure size (Y) for .png output")
flags.DEFINE_float('xmin', -1.0, "manually set lower limit")
flags.DEFINE_float('xmax', -1.0, "manually set upper limit")
flags.DEFINE_float('width', 0.0, 'Width of bars in bar plots')
flags.DEFINE_float('quantile', 0.0, 'Truncate plots to the <quantile> quantile')
flags.DEFINE_integer('int2c', 0, 'Plot int features with <int2c> or more values as float')
flags.DEFINE_string('legend', None, 'File for legends\n')
flags.DEFINE_boolean('verbose', False, "verbose output")

@dataclass
class Options:
  """Options controlling generation of plots."""
  verbose: bool = False

  # The file name of plots generated
  stem: str = ""

  # Plot dimensions in inches. Both must be set in order
  # to have any effect
  x: int = 0
  y: int = 0

  # Manually specify the x range of the plot
  xmin: float = 0.0
  xmax: float = 0.0

  # For bar plots, manually set the width
  width: int = 0

  # Truncate plots to a given quantile
  quantile: float = 0.0

  # We can optionally write the legends to a file
  stream_for_legends = None

  # The color assigned to each collection can be over-ridden on the
  # command line
  color: List[str] = field(default_factory=lambda: '')

  # Some integer features, natoms for example, look better plotted
  # with the continuous feature plot function. Specify a threshold
  # for the number of different features, above which the
  # continuous value plot function is used.
  int2c: int = 0

def usage(ret):
  """Print usage and exit
  TODO: ianwatson implement this.
  """
  sys.exit(ret)

def get_color(options: Options, protos: List[collection_pb2.Descriptor], ndx: int) -> str:
  """Return the color for collection `ndx`.

  If colors have been specified in `options.color` use that.
  Otherwise use the color in protos[ndx]
  Args:
    options:
    protos: list of collection protos
    ndx: the collection number
  Returns:
    the color as a string
  """
  if len(options.color) > 0:
    return options.color[ndx]

  return protos[ndx].description.line_color


def shrink_to_quantile(quantile: float,
                       x: np.array,
                       counts: List[np.array]) -> Tuple[np.array, List[np.array]]:
  """Reduce `x` and `counts` to the `quantile` quantile.

  'x' holds the x axis for plotting. `counts` holds a list of frequency values
  all aligned with `x`.
  Args:
  Returns:
    Updated values for x and counts
  """
  # If this looks like a fractional property do not scale
  # hmmm, not sure...
  # if x[-1] == 1.0:
  #   return (x, counts)

  npoints = len(x)
  totals = np.zeros(npoints)
  nobs = 0
  for count in counts:
    totals = np.add(totals, count)
    nobs += np.sum(count)

  points_needed = int(round(nobs * quantile))

  left = 0
  for i, tot in enumerate(totals):
    if tot >= points_needed:
      left = i
      break

  right = len(totals)
  tot = 0
  for i in range(len(totals)):
    j = len(totals) - i - 1
    tot += totals[j]
    if tot >= points_needed:
      right = j
      break

  if left == 0 and right == npoints - 1:
    return (x, counts)

  print(f"npoints {npoints} left {left} right {right}")
  newx = x[left:right + 1]
  new_counts = []
  for c in counts:
    new_counts.append(c[left:right + 1])

  return (newx, new_counts)

def get_width(protos: List[collection_pb2.Descriptor],
              options: Options) -> float:
  """Return the width to be used for bar plots.

  Args:
  Returns:
  """
  if options.width > 0:
    return options.width

  return 0.9 * 1.0 / len(protos)

def make_legend(proto: collection_pb2.Descriptor) -> str:
  """Generate a legend for the feature in `proto`

  Args:
    proto:
  Returns:
    A lagend string
  """
  if proto.maxval <= 1.0:
    return f"{proto.description.source} {proto.mean:.3f}"
  elif proto.maxval <= 10.0:
    return f"{proto.description.source} {proto.mean:.2f}"
  elif proto.maxval <= 100.0:
    return f"{proto.description.source} {proto.mean:.1f}"
  elif proto.mean <= 1000.0:
    return f"{proto.description.source} {proto.mean:.0f}"
  else:
    return f"{proto.description.source} {proto.mean}"

def get_range(protos: List[collection_pb2.Descriptor]) -> Tuple:
  """Determine overall min and max of `protos`

  Args:
    protos: list of
  Returns:
  """

  # Get the range of the graph
  min_value = protos[0].minval
  max_value = protos[0].maxval
  for i in range(1, len(protos)):
    min_value = min(protos[i].minval, min_value)
    max_value = max(protos[i].maxval, max_value)
  logging.info("Range of %s btw %f and %f", protos[0].description.feature_name, min_value, max_value)
  return (min_value, max_value)

def int_plot(options: Options,
             protos: List[collection_pb2.Descriptor],
             make_barplot: bool) -> None:
  """Generate a plot of integer data

  Args:
    options: options controlling behaviour
    protos: Descriptor protos
    make_barplot: If set, make a barplot, otherwise a line plot
  """
  (min_value, max_value) = get_range(protos)

  nvalues = round(max_value - min_value) + 1

  # Each set will be aligned with this as the X axis
  x = np.arange(round(min_value), round(max_value) + 1)
  # A count array for each proto
  counts = []
  for proto in protos:
    c = np.zeros(nvalues)
    for value_count in proto.int_values:
      # slight risk of rounding error, use indices instead...
      ndx = round(value_count.value - min_value)
      c[ndx] = value_count.count
    counts.append(c)

  if options.quantile > 0.0:
    (x, counts) = shrink_to_quantile(options.quantile, x, counts)

  bars = []
  width = get_width(protos, options)
  for (i, count) in enumerate(counts):
    legend = make_legend(protos[i])
    normed = count / np.linalg.norm(count, ord=1)
    if make_barplot:
      b = plt.bar(x + width * i, normed, width,
                  color=get_color(options, protos, i))
      b.set_label(legend)
    else:
      b = plt.plot(x, normed, color=get_color(options, protos, i),
                   label=legend,
                   linewidth = 2 if i == 0 else 1)
    if options.stream_for_legends is not None:
      print(f'{protos[i].description.feature_name} {legend} {protos[i].description.description}',
            file=options.stream_for_legends)
    bars.append(b)

  ymax = plt.gca().get_ylim()[1]
  for (i, proto) in enumerate(protos):
    mean = proto.mean
    x = [mean, mean]
    y = [0.96 * ymax, 0.999 * ymax]
    plt.plot(x, y, color=get_color(options, protos, i))

  if options.xmin >= 0.0 and options.xmax > options.xmin:
    plt.xlim(options.xmin, options.xmax)
  plt.xlabel(protos[0].description.feature_name)
  plt.title(protos[0].description.description)
  plt.ylabel("Prevalence")
  plt.legend()
  if len(options.stem) == 0:
    plt.show()
    plt.close()
    return

  # generating png.
  fname = f"{options.stem}_{protos[0].description.feature_name}.png"

  fig = plt.gcf()
  if options.x > 0.0 and options.y >= 0.0:
    fig.set_size_inches(options.x, options.y)
  fig.savefig(fname, dpi=200)

  plt.close()


def float_plot(options: Options,
               protos: List[collection_pb2.Descriptor]) -> None:
  """Generate a plot of float data

  Args:
    options: options controlling behaviour
    protos: Descriptor protos
  """
  (min_value, max_value) = get_range(protos)
  logging.info("Range %r to %r", min_value, max_value)

  # Each set will be aligned with this as the X axis
  dx = (max_value - min_value) / 50.0
  print(f'{min_value} to {max_value} dx {dx}')
  x = np.arange(min_value, max_value + dx, dx)
  counts = []
  for proto in protos:
    myvalues = np.fromiter(map(lambda x: x.value, proto.float_values), dtype=float)
    mycounts = np.fromiter(map(lambda x: x.count, proto.float_values), dtype=int)
    count = np.interp(x, myvalues, mycounts)
    counts.append(count)

  if options.quantile > 0.0:
    (x, counts) = shrink_to_quantile(options.quantile, x, counts)

  plts = []

  for (i, count) in enumerate(counts):
    normed = count / np.linalg.norm(count, ord=1)
    p = plt.plot(x, normed, color=get_color(options, protos, i),
                 label=make_legend(protos[i]),
                 linewidth= 2 if i == 0 else 1)
    plts.append(p)

  ymax = plt.gca().get_ylim()[1]
  for (i, proto) in enumerate(protos):
    mean = proto.mean
    x = [mean, mean]
    y = [0.0, 0.04 * ymax]
    plt.plot(x, y, color=get_color(options, protos, i))

  if options.xmin >= 0.0 and options.xmax > options.xmin:
    plt.xlim(options.xmin, options.xmax)
  plt.xlabel(protos[0].description.feature_name)
  plt.title(protos[0].description.description)
  plt.ylabel("Prevalence")
  plt.legend()
  if len(options.stem) == 0:
    plt.show()
    plt.close()
    return

  # generating png
  fname = f"{options.stem}_{protos[0].description.feature_name}.png"

  fig = plt.gcf()
  if options.x > 0.0 and options.y >= 0.0:
    fig.set_size_inches(options.x, options.y)
  fig.savefig(fname, dpi=200)
  plt.close()

def do_plots(options: Options,
             protos: List[collection_pb2.Descriptor]) -> None:
  """Generate property profile plots from `protos`.

  Basically just decides if this is integer data or float and branches.
  Args:
    options:
    protos:
  Returns:
  """
  # The number of datasets that come in as integer.
  is_int = 0

  # By default, integer data is a barplot.
  # If the the number of values is > options.int2c then we make a line plot
  make_barplot = True

  for proto in protos:
    number_int_values = len(proto.int_values)
    # If all float values now, nothing to do
    if number_int_values == 0:
      continue

    is_int += 1
    if options.int2c == 0:  # Not being checked
      pass
    elif number_int_values > options.int2c:
      make_barplot = False
    else:
      pass

  if is_int > 0:
    int_plot(options, protos, make_barplot)
  else:
    float_plot(options, protos)

def process_group_of_files(options: Options,
                           collections: List[str],
                           feature_name: str,
                           feature_description: str)->None:
  """Generate a plot for `feature_name` across `collections`.

  Relies on a standardised naming scheme for the proto files,
  <collection>_<feature>.dat

  Args:
    options: controls options
    collections: list of collections - actually the stem from generate_profile
    feature_name: the feature to plot
    feature_description: an understandable description of `feature`.
  Returns:
  """
  protos = []
  for collection in collections:
    fname = f"{collection}_{feature_name}.dat"
    with open(fname, "r") as reader:
      file_contents = reader.readlines()

    proto = text_format.Parse('\n'.join(file_contents), collection_pb2.Descriptor())
    if feature_name != proto.description.feature_name:
      raise f"Feature mismatch in #{feature_name}, should be {proto.description.feature_name}"
    protos.append(proto)

  if options.verbose:
    logging.info("Read %d protos for feature %s\n", len(protos), feature_name)

  do_plots(options, protos)

def process_files_from_cmdline(options: Options,
                               args: List[str]):
  """Plotting a single feature, in the files in `args`.

  Args:
    options: Options controlling output.
    args: List of files from the command line.
  """
  protos = []
  feature_name = ""
  for i in range(1, len(args)):
    fname = args[i]
    with open(fname, 'r') as reader:
      contents = reader.readlines()

    if len(contents) == 0:
      logging.fatal("No data in %s", fname)

    proto = text_format.Parse('\n'.join(contents), collection_pb2.Descriptor())
    protos.append(proto)

    if feature_name == "":
      feature_name = proto.description.feature_name
    elif feature_name != proto.description.feature_name:
      logging.fatal("Name mismatch %s vs %s", feature_name, proto.feature_name)

  if options.verbose:
    logging.info("Read %d protos for feature %s\n", len(protos), feature_name)

  do_plots(options, protos)

def plot_profiles(args):
  """Generate plots for the protos in `args`.
  """
  options = Options()
  options.verbose = FLAGS.verbose
  options.stem = FLAGS.stem
  options.x = FLAGS.X
  options.y = FLAGS.Y
  options.xmin = FLAGS.xmin
  options.xmax = FLAGS.xmax
  options.width = FLAGS.width
  options.quantile = FLAGS.quantile
  if FLAGS.legend is not None:
    options.stream_for_legends = open(FLAGS.legend, 'w')
  options.int2c = FLAGS.int2c

  # Note there is no checking of the length of the color
  # array with the number of collections.
  if len(FLAGS.color) > 0:
    options.color = FLAGS.color

  # There are two ways in which we can make plots.
  # Files on the command line, plotting one feature.
  # Or, via the --collection and --feature_descriptions options
  # which specify a set of features to plot.
  if len(FLAGS.compare) > 0 and len(FLAGS.feature_descriptions) > 0:
    with open(FLAGS.feature_descriptions, 'r') as reader:
      file_contents = reader.read()
    feature_descriptions = text_format.Parse(file_contents, collection_pb2.Descriptions())
    for feature in feature_descriptions.feature_to_description:
      process_group_of_files(options, FLAGS.compare, feature,
                             feature_descriptions.feature_to_description[feature])
  else:
    if len(args) < 3:
      logging.error("Must specify at least two protos to plot")
      usage(1)
    process_files_from_cmdline(options, args)

if __name__ == "__main__":
  app.run(plot_profiles)
