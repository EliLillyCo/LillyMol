#!/usr/bin/env python
##############################################################################
#
# Summary: 
# Generate all Matched Series from input CSV file. Take the query molecules
# and search for all possible series extensions (within set SAR transfer)
#
# Usage:
#   getMMPSeriesSuggestfromCSV.py -i test.csv -o test.ideas -s SMILES -n ID -a PIC50 -m 4
#
##############################################################################
import argparse 
import sys
import logging

from mmp.mmp_series_object import MMPSeriesObjectClass


def main():

    def restricted_float(x):
        x = float(x)
        if x < 0.1 or x > 0.99:
            raise argparse.ArgumentTypeError("%r not in range [0.1, 0.99]" % (x,))
        return x

    def restricted_int(x):
        x = int(x)
        if x < 1 or x > 99:
            raise argparse.ArgumentTypeError("%r not in range [1, 99]" % (x,))
        return x

    parser = argparse.ArgumentParser(description='Generate new ideas using Matched Series data for 1 or more input SMI '
                                                 'and a set of compounds to derive MMS from (within set MMS Analysis).'
                                                 'For removal of poor quality matches use: -p 5 -f which is consistent '
                                                 'with Keefer and Chang MedChemComm 2017 where candidate (match) '
                                                 'series must have >=5 compounds, activity spread >= 0.5 and skew <= 3')
    # This is essential
    parser.add_argument('-i', required=True, help='CSV: Input CSV file of smiles and activity data')
    parser.add_argument('-s', required=True, help='Column name for Molecule SMILES')
    parser.add_argument('-n', required=True, help='Column name for Molecule ID')
    parser.add_argument('-a', required=True, help='Column name for Activity Data')
    parser.add_argument('-o', required=True, help='Output file of enumerated new ideas with scored MMS data')
    # options
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-x', type=str, default=None,
                       help='Quoted, Comma delimited list of 3 or more Mol IDs with no gaps or spaces e.g.: '
                            '\"12345,12346,12347\". These Mol IDs must be present in the CSV. An alternative is to '
                            'use auto_search (-y) which scans series created from input CSV and uses them to derive '
                            'query series.')
    group.add_argument('-y', action='store_true', default=False,
                       help='Invoke this flag instead of -x if you want to run an auto_search')
    group.add_argument('-w', action='store_true', default=False,
                       help='Invoke this flag instead of -x or -y if you want to run an auto_search_fullscan')
    # additional option
    parser.add_argument('-z', type=str, default=None,
                        help='Fully qualified path containing one or more series files to use as reference set for '
                             'SAR Transfer - external set transfer. If this is defined, will run external set transfer '
                             'not within set transfer.')
    # limits on series length and other matching options
    parser.add_argument('-p', type=restricted_int, default=5,
                        help='Invoke to set a min limit on the reported series length (default >= 5). The minimum '
                             'allowed value is 3 as a value of 2 will simple find matched pairs. For the auto search '
                             'method, this switch will be used as the series length for the auto search query series '
                             'and -q will be used as the max length.')
    parser.add_argument('-q', type=restricted_int, default=10,
                        help='Invoke to set a max limit on the search series length (default <= 10). This affects '
                             'auto search only and combined with -p defines the max and mix extent of all the '
                             'series that will be autogenerated from existing series and used as search queries '
                             'to try and identify further functional groups that can be made with greater activity.')
    parser.add_argument('-m', action='store_true', default=False,
                        help='Invoke flag to force strict, ordered matching of fragments in series (default = False). '
                             'If False, series Me,F,Cl,Br will be allowed to match Me,Cl,F,Br i.e.: number and type'
                             'of fragments must be the same by order does not have to match. Output will include '
                             'Spearmans rho to allow assessment of rank correlation for matched series pairs')
    #
    parser.add_argument('-f', action='store_true', default=False,
                        help='Invoke flag to apply range and skew filters to initial query MMS')
    #
    parser.add_argument('-t', action='store_true', default=False,
                        help='Invoke this flag (no value needed) if you want a second header line with datatypes')
    #
    parser.add_argument('-d', type=restricted_float, default=0.3,
                        help='Dicer maxff cutoff with default value of 0.3 (remove a maximum of 30 pct of each mol as'
                             ' the fragment).')
    #
    parser.add_argument('-c', type=str, default='BOTH', choices=['SINGLE', 'DOUBLE', 'BOTH'],
                        help='Specify cut type, SINGLE, DOUBLE or default = BOTH')
    #
    parser.add_argument('-l', help='optional log filename', default=False)
    parser.add_argument('-L', help='debug log level CRITICAL|ERROR|WARNING|INFO|DEBUG', default='INFO')

    args = parser.parse_args()

    # create logger
    mmplogger = logging.getLogger('lillymol_file_logger')

    log_level = args.L

    if args.l:
        log_file = args.l
    else:
        log_file = None
        log_level = None

    if log_file is not None:

        fh = logging.FileHandler(log_file)

        if log_level is None:
            mmplogger.setLevel(logging.INFO)

        else:
            numeric_level = getattr(logging, log_level.upper(), None)
            if not isinstance(numeric_level, int):
                raise ValueError('Invalid log level: %s' % log_level)
            mmplogger.setLevel(numeric_level)

        formatter = logging.Formatter('%(asctime)s %(levelname)s %(module)s: %(message)s',
                                      datefmt='%m/%d/%Y %I:%M:%S %p')
        fh.setFormatter(formatter)
        mmplogger.addHandler(fh)

    else:
        logging.disable(logging.CRITICAL)

    #######################
    # main stuff          #
    #######################
    mmplogger.info('Instantiating MMP Suggest Object')
    mmp_suggest_object = MMPSeriesObjectClass(mmplogger)

    # parse series from directory of files or generate from CSV

    use_comparison_df = False

    mmp_suggest_object.setup_mmp_data_for_mms(args.i, args.s, args.n, args.a, args.p, args.d, cut_type=args.c)
    mmp_suggest_object.generate_store_mmp_series(apply_pre_filter=args.f)

    if args.z is not None:
        mmp_suggest_object.setup_pregenerated_series_data_for_mms(args.z)
        use_comparison_df = True

    # check the input list of Mol IDs is valid
    if args.x is not None:

        mol_id_list = args.x
        mol_id_list = mol_id_list.split(",")
        if len(mol_id_list) < 3:
            sys.exit("Please specify 3 or more Mol ID's as a (quoted) comma delimited list e.g.: /'12345,12346,12347/'")
        mol_id_list = [int(x) for x in mol_id_list]

        mmplogger.info('Initiating search for MMS in reference dir set, using molid list input')
        result_df = mmp_suggest_object.search_for_mms_to_extend_molids(mol_id_list,
                                                                       strict_order=args.m,
                                                                       use_comparison_df=use_comparison_df)
        if result_df.empty:
            print("No results found: query series had no matches against the target set")
        else:
            result_scored = None
            result_scored = mmp_suggest_object.return_scored_series_dataframe(mol_id_list, result_df, result_scored)
            mmp_suggest_object.write_series_dataframe(result_scored, args.o)

    # args.y must be true
    elif args.y:
        result_df = mmp_suggest_object.auto_search(args.q, args.p,
                                                   strict_ordering=args.m,
                                                   use_comparison_df=use_comparison_df)
        mmp_suggest_object.auto_search_write(result_df, args.o)

    elif args.w:
        # print "Running full auto search"
        result_df = mmp_suggest_object.auto_search_fullscan(strict_ordering=args.m,
                                                            use_comparison_df=use_comparison_df)
        mmp_suggest_object.auto_search_write(result_df, args.o)

    else:
        sys.exit('Error, invalid option, please try -x, -y or -w')


if __name__ == "__main__":
    main()
