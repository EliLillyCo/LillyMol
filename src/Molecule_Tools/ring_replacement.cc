// Using queries generated by ring_extraction, replace rings in molecules.

#include <iostream>
#include <memory>

#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
#include "google/protobuf/text_format.h"

#define RESIZABLE_ARRAY_IWQSORT_IMPLEMENTATION

#include "Foundational/cmdline/cmdline.h"
#include "Foundational/iwmisc/misc.h"
#include "Foundational/iwstring/iw_stl_hash_set.h"
#include "Foundational/iwqsort/iwqsort.h"

#include "Molecule_Lib/aromatic.h"
#include "Molecule_Lib/atom_typing.h"
#include "Molecule_Lib/istream_and_type.h"
#include "Molecule_Lib/molecule.h"
#include "Molecule_Lib/rwsubstructure.h"
#include "Molecule_Lib/smiles.h"
#include "Molecule_Lib/substructure.h"
#include "Molecule_Lib/standardise.h"
#include "Molecule_Lib/target.h"

#include "Molecule_Tools/replacement_ring.pb.h"

namespace ring_replacement {

using std::cerr;

void
Usage(int rc) {
// clang-format off
#if defined(GIT_HASH) && defined(TODAY)
  cerr << __FILE__ << " compiled " << TODAY << " git hash " << GIT_HASH << '\n';
#else
  cerr << __FILE__ << " compiled " << __DATE__ << " " << __TIME__ << '\n';
#endif
  // clang-format on
  // clang-format off
  cerr << R"(Performs ring replacement given an existing set of replacement rings from ring_extraction.
 -R <fname>    file(s) of labelled rings created by ring_extraction
 -s <smarts>   only replace rings containing atoms matched by <smarts>
 -q <query>    only replace rings containing atoms matched by <query>
 -u            unique molecules only
 -a            allow change of aromaticity on ring replacement
 -p            write parent molecule
 -n <ex>       only process replacement rings with <ex> or more examples
 -w            sort output by precedent count
 -d            do NOT preserve substitution patterns. Replacement rings may
               not have had the same substition pattern as they do here
 -Y <query>    product molecules MUST     match a query in <query>
 -N <query>    product molecules must NOT match any queries in <query>
 -D <query>    discard any replacement ring that matches <query>
 -3            if the input molecules contain 3D coordinates, copy the old atom's coordinates to the new atom.
 -I .          remove isotopes from product molecules
 -I <n>        change all existing isotopes to <n> (useful if atom types used)
 -B <fname>    write molecules not transformed to <fname>
 -X ...        miscellaneous options, enter '-X help' for info
 -c            remove chirality
 -l            strip to largest fragment
 -v            verbose output
)";
  // clang-format on

  ::exit(rc);
}

class Replacement {
  private:
    // Constructed from `smt` in the proto.
    Substructure_Query _query;

    // Constructed from `smi` in the proto.
    Molecule _m;

    // Copied from `id` in the proto.
    IWString _id;

    // the kind of ring replacement this is, 5a6a...
    IWString _label;

    // Copied from `n` in the proto. The number of examplars.
    int _count;

    // If the ring has exocyclic doubly bonded atoms.
    Molecule _exocyclic;

    // save for debugging.
    IWString _smarts;

    // incremented once the product has passed a valence check.
    int _variants_generated;

    // We can optionally copy the coordinates of the old atoms to the new
    // atoms. Coordinates of exocyclic doubly bonded atoms are computed.
    int _transfer_coordinates;

  public:
    // public so these variables can be set from the command line options.
    static int _display_valence_error_messages;

    static int _warn_loss_of_aromaticity;
  private:

    int _invalid_valenced_generated;

  // private functions.

    void ReportValenceErrors(const Molecule& parent, Molecule& m, std::ostream& output);
    void SetName(const IWString& parent_name, Molecule& m) const;
    int JoinExocyclic(Molecule& m);
    int MakeDoubleBond(Molecule& m, atom_number_t zatom);

  public:
    Replacement();

    int BuildFromProto(const RplRing::ReplacementRing& proto);

    void set_transfer_coordinates(int s) {
      _transfer_coordinates = s;
    }

    int count() const {
      return _count;
    }
    int variants_generated() const {
      return _variants_generated;
    }

    Molecule& mol() {
      return _m;
    }

    int SubstructureSearch(Molecule_to_Match& target, Substructure_Results& sresults);

    int MakeVariant(Molecule& m, const Set_of_Atoms& embedding, const uint32_t* atypes, std::unique_ptr<Molecule>& result);

    int Report(std::ostream& output);
};

int Replacement::_display_valence_error_messages = 1;
int Replacement::_warn_loss_of_aromaticity = 0;

Replacement::Replacement() {
  _variants_generated = 0;
  _invalid_valenced_generated = 0;

  _transfer_coordinates = 0;
}

int
Replacement::BuildFromProto(const RplRing::ReplacementRing& proto) {
  IWString smt(proto.smt());
  if (! _query.create_from_smarts(smt)) {
    cerr << "Replacement::BuildFromProto:cannot parse '" << proto.smt() << "'\n";
    return 0;
  }

  _query.set_find_unique_embeddings_only(1);

  if (! _m.build_from_smiles(proto.smi())) {
    cerr << "Replacement::BuildFromProto:cannot parse smiles:" << proto.ShortDebugString() << "'n";
    return 0;
  }

  _id = proto.id();
  _label = proto.label();

  _count = proto.n();

  // _smarts = proto.smt();

  if (proto.has_exo()) {
    if (! _exocyclic.build_from_smiles(proto.exo())) {
      cerr << "Replacement::build_from_smiles:cannot parse exocyclic '" << proto.exo() << "'\n";
      return 0;
    }
    for (int i = 0; i < _exocyclic.natoms(); ++i) {
      _exocyclic.unset_all_implicit_hydrogen_information(i);
    }
  }

  return 1;
}

int
Replacement::SubstructureSearch(Molecule_to_Match& target, Substructure_Results& sresults) {
  return _query.substructure_search(target, sresults);
}

// Provide detailed information on valence errors in `m`.
void
Replacement::ReportValenceErrors(const Molecule& parent, Molecule& m, std::ostream& output) {
  m.unset_unnecessary_implicit_hydrogens_known_values();

  if (m.valence_ok()) {
    return;
  }

  if (! _display_valence_error_messages) {
    return;
  }

  ++_invalid_valenced_generated;

  output << "Invalid valence " << m.smiles() << ' ' << parent.name() << ' ' << _id << '\n';

  for (int i = 0; i < m.natoms(); ++i) {
    if (! m.valence_ok(i)) {
      output << " atom " << i << ' ' << m.smarts_equivalent_for_atom(i) << '\n';
    }
  }
}

// Install a new name in `m` derived from `parent_name` and `_id`.
void
Replacement::SetName(const IWString& parent_name,
                     Molecule& m) const {
  IWString name;
  name << parent_name;
  name << " %% " << _id;
  if (! _label.empty()) {
    name << '.' << _label;
  }
  name << ' ' << _count;

  m.set_name(name);
}

void
UnsetImplicitHydrogenInformation(Molecule& m) {
  const int matoms = m.natoms();
  for (int i = 0; i < matoms; ++i) {
    m.unset_all_implicit_hydrogen_information(i);
  }
}

int
EnvironmentMatch(const Molecule& m,
                 atom_number_t zatom,
                 atom_number_t to_join,
                 const uint32_t* atypes) {
  if (! atypes) {
    return 1;
  }

  const isotope_t iso = m.isotope(zatom);
  // cerr << " atom " << zatom << " iso " << m.isotope(zatom) << " to_join " << to_join << " atype " << atypes[to_join] << " eq " << (iso == atypes[to_join]) << '\n';
  return iso == atypes[to_join];
}

//#define DEBUG_MAKE_VARIANT

int
Replacement::MakeVariant(Molecule& parent,
                         const Set_of_Atoms& embedding,
                         const uint32_t* atypes,
                         std::unique_ptr<Molecule>& result) {
  std::unique_ptr<Molecule> m = std::make_unique<Molecule>(parent);
  const int initial_natoms = m->natoms();
  const int initial_aromatic_count = parent.aromatic_atom_count();

  m->set_name(parent.name());
  m->add_molecule(&_m);
  Molecule mcopy(_m);
  //cerr << mcopy.smiles() << " was added " << _id << " smarts " << _smarts << '\n';
#ifdef DEBUG_MAKE_VARIANT
  cerr << "After adding replacement " << m->smiles() << " initial_natoms " << initial_natoms << '\n';
  write_isotopically_labelled_smiles(*m, false, cerr);
  cerr << "\nembedding " << embedding << '\n';
#endif

  std::unique_ptr<int[]> to_remove(new_int(m->natoms()));
  embedding.set_vector(to_remove.get(), 1);

#ifdef DEBUG_MAKE_VARIANT
  for (int i = 0; i < m->natoms(); ++i) {
    cerr << " atom " << i << ' ' << m->smarts_equivalent_for_atom(i) << " to_remove " << to_remove[i] << '\n';
  }
#endif

  resizable_array<const Bond*> remove_bonds;
  remove_bonds.reserve(10);  // approximately.

  // A list of bonds that we will place once existing bonds are removed.
  resizable_array_p<Bond> bonds_to_be_placed;

  const int esize = embedding.number_elements();
  for (int i = 0; i < esize; ++i) {
    const atom_number_t a = embedding[i];
    const Atom& atom = m->atom(a);
    for (const Bond* b : atom) {
      atom_number_t o = b->other(a);
      if (to_remove[o]) {
        continue;
      }
      // Remove doubly bonded atoms on aromatic rings.
      if (b->is_double_bond() && parent.is_aromatic(a) && parent.ncon(o) == 1) {
        to_remove[o] = 1;
        continue;
      }

      if (! b->is_single_bond()) {
        // Or maybe we should abandon the calculation. Multiple bonds
        // are still handled below...
        continue;
      }
      if (! EnvironmentMatch(_m, i, o, atypes)) {
        // cerr << "Failed due to EnvironmentMatch\n";
        return 0;
      }
      // cerr << "From atom " << a << " make bond " << (initial_natoms + i) << " to " << o << '\n';
      remove_bonds << b;

      atom_number_t join_to = initial_natoms + i;
      if (b->is_single_bond()) {
        bonds_to_be_placed << new Bond(o, join_to, SINGLE_BOND);
      } else if (b->is_double_bond()) {
        bonds_to_be_placed << new Bond(o, join_to, DOUBLE_BOND);
      } else if (b->is_triple_bond()) {
        bonds_to_be_placed << new Bond(o, join_to, TRIPLE_BOND);
      }
      m->set_implicit_hydrogens_known(o, 0);
      m->set_implicit_hydrogens_known(join_to, 0);
    }
  }

  if (_transfer_coordinates) {
    for (int i = 0; i < esize; ++i) {
      const atom_number_t a = embedding[i];
      m->setxyz(initial_natoms + i, m->atomi(a));
    }
  }

  // Note that `b` is destroyed by remove_bond_between_atoms
  for (const Bond* b: remove_bonds) {
    atom_number_t a1 = b->a1();
    atom_number_t a2 = b->a2();
    // cerr << "Removing bond btw " << a1 << ' ' << a2 << '\n';
    if (m->are_bonded(a1, a2)) {
      m->remove_bond_between_atoms(a1, a2);
    }
  }

  for (Bond * b : bonds_to_be_placed) {
    if (m->hcount(b->a1()) == 0 || m->hcount(b->a2()) == 0) {
      return 0;
    }
    m->add_bond(b->a1(), b->a2(), b->btype());
  }

  m->remove_atoms(to_remove.get());

#ifdef DEBUG_MAKE_VARIANT
  cerr << "After removing atoms " << m->aromatic_smiles() << '\n';
#endif

  if (! _exocyclic.empty()) {
    if (! JoinExocyclic(*m)) {
      // cerr << "JoinExocyclic failed\n";
      return 0;
    }
  }
  UnsetImplicitHydrogenInformation(*m);

  if (! m->ok()) {
    cerr << "Invalid molecule generated\n";
  }

  if (int final_aromatic_atoms = m->aromatic_atom_count(); final_aromatic_atoms < initial_aromatic_count) {
    if (_warn_loss_of_aromaticity) {
      cerr << "Warning loss of aromaticty " << parent.smiles() << " vs " << m->smiles() << '\n';
      cerr << initial_aromatic_count << " vs " << final_aromatic_atoms << " aromatic atoms\n";
      cerr << parent.name() << " combined with " << _id << '\n';
    }
    return 0;
  }

#ifdef DEBUG_MAKE_VARIANT
  cerr << "MakeVariant succeeds " << m->smiles() << '\n';
#endif

  ReportValenceErrors(parent, *m, cerr);

  SetName(parent.name(), *m);

  result.reset(m.release());

  ++_variants_generated;

  return 1;
}

// We have just added `exocyclic` to `m` by making a double bond with `zatom`.
// Adjust the coordinates of `exocyclic` to reflect a double bond
int
SetExocyclicCoordinates(Molecule& m, atom_number_t zatom, atom_number_t exocyclic) {
  if (m.ncon(zatom) != 3) {
    cerr << "SetExocyclicCoordinates:not 3 connected!\n";
    return 0;
  }

  atom_number_t c1 = kInvalidAtomNumber;
  atom_number_t c2 = kInvalidAtomNumber;
  for (const Bond* b : m[zatom]) {
    atom_number_t o = b->other(zatom);
    if (o == exocyclic) {
      continue;
    }
    if (c1 == kInvalidAtomNumber) {
      c1 = o;
    } else {
      c2 = o;
    }
  }

  // Should never happen.
  if (c2 == kInvalidAtomNumber) {
    return 0;
  }
  Space_Vector<coord_t> v1(m[c1]);
  Space_Vector<coord_t> v2(m[c2]);
  Space_Vector<coord_t> vz(m[zatom]);
  Space_Vector<coord_t> vz1 = vz - v1;
  Space_Vector<coord_t> vz2 = vz - v2;
  vz1.normalise();
  vz2.normalise();
  Space_Vector<coord_t> middle = (vz1 + vz2) * 0.5;
  middle.normalise();
  Space_Vector<coord_t> pos = vz + middle * 1.23;

  m.setxyz(exocyclic, pos);

  return 1;
}

// Atom `zatom` has an atom map number, and _exocyclic has been added.
// Before _exocyclic was added, the molecule had `initial_natoms` atoms.
// Find the atom in _exocyclic that has an isotope corresponding to the
// atom map number and join the corresponding atoms.
int
Replacement::MakeDoubleBond(Molecule& m,
               atom_number_t zatom) {
  const int matoms = m.natoms();
  const int initial_natoms = matoms - _exocyclic.natoms();

  assert(zatom < initial_natoms);

  const isotope_t amap = m.atom_map_number(zatom);
  assert(amap > 0);

  // Look among the newly added atoms for an isotope matching `amap`.
  for (int i = initial_natoms; i < matoms; ++i) {
    if (m.isotope(i) != amap) {
      continue;
    }

    // This is potentially problematic.
    if (m.hcount(zatom) == 0) {
      // cerr << "No match for hcount " << m.smarts_equivalent_for_atom(zatom) << '\n';
      return 0;
    }

    // If the existing connection was just 1 atom, we could remove it.
    // TODO:ianwatson investigate this.
    if (m.ncon(zatom) > 2) {
      return 0;
    }

    m.add_bond(zatom, i, DOUBLE_BOND);
    m.set_atom_map_number(zatom, 0);
    m.set_isotope(i, 0);
    if (_transfer_coordinates) {
      return SetExocyclicCoordinates(m, zatom, i);
    }
    return 1;
  }

  cerr << "Replacement::MakeDoubleBond:no match to " << amap << ' ' << m.smiles() << '\n';
  return 0;
}

// By convention, exocyclic doubly bonded atoms are in _exocyclic, with
// an isotopic label. There will be an atom in `m` with a corresponding
// atom map number. Join those pairs of atoms with a double bond.
int
Replacement::JoinExocyclic(Molecule& m) {
  const int initial_natoms = m.natoms();

  m.add_molecule(&_exocyclic);
  for (int i = 0; i < initial_natoms; ++i) {
    auto amap = m.atom_map_number(i);
    if (amap == 0) {
      continue;
    }

    if (! MakeDoubleBond(m, i)) {
      return 0;
    }
  }

  return 1;
}

int
Replacement::Report(std::ostream& output) {
  if (_variants_generated == 0 && _invalid_valenced_generated == 0) {
    return 1;
  }

  output << _id << ' ' << _m.smiles() << " exo " << _exocyclic.smiles() <<
         " generated " << _variants_generated << " variants, "
         << _invalid_valenced_generated << " invalid valence";
  if (_variants_generated == _invalid_valenced_generated) {
    output << " !";
  }
  output << '\n';

  return 1;
}

class RingReplacement {
  private:
    int _verbose;

    int _molecules_read;

    int _reduce_to_largest_fragment;

    int _remove_chirality;

    int _write_parent_molecule;

    Atom_Typing_Specification _atype;

    int _preserve_connectivity;

    // One per -R option.
    int _nreplacements;
    resizable_array_p<Replacement>* _rings;

    // From the -D option.
    resizable_array_p<Substructure_Query> _replacement_ignore;

    // Identify the (ring) atoms in the starting molecule that
    // are available for replacement.
    resizable_array_p<Substructure_Query> _queries;

    resizable_array_p<Substructure_Query> _products_must_have;
    resizable_array_p<Substructure_Query> _products_must_not_have;

    int _molecules_discarded_by_must_have_queries = 0;
    int _molecules_discarded_by_must_not_have_queries = 0;

    int _molecules_with_invalid_valences_suppressed;

    int _unique_molecules_only = 0;

    int _min_examples_needed = 0;
    int _replacement_rings_discarded_for_count = 0;

    IW_STL_Hash_Set _seen;
    int _duplicates_suppressed;

    int _molecules_formed;

    extending_resizable_array<int> _number_variants;

    // Remove isotopes from product molecules.
    int _remove_isotopes;

    // Translate all isotopes to a single value.
    isotope_t _translate_isotopes;

    int _sort_output_by_precedent = 0;

    Chemical_Standardisation _chemical_standardisation;

    IWString_and_File_Descriptor _stream_for_unchanged_molecules;

  // Private functions.

    int ReadReplacementRings(IWString& fname, int ndx);
    int ReadReplacementRings(iwstring_data_source& input, int ndx);
    int AnyReplacementRingIgnoreQueryMatches(Replacement& r);
    int OkSupport(const Replacement& r);
    int IsUnique(Molecule& m);
    int OkQueryConstraints(Molecule& m);
    int Process(resizable_array_p<Molecule>& mols, int ndx, const uint32_t* atypes,
                const int* process_atom);
    int Write(const resizable_array_p<Molecule>& mols, IWString_and_File_Descriptor& output);
    int IdentifyMatchedAtoms(Molecule& m, resizable_array_p<Substructure_Query>& queries,
                             int* process_atom);

  public:
    RingReplacement();
    ~RingReplacement();

    int Initialise(Command_Line& cl);

    int Preprocess(Molecule& m);

    int Process(Molecule& m, IWString_and_File_Descriptor& output);

    int Report(std::ostream& output);
};

RingReplacement::RingReplacement() {
  _verbose = 0;
  _molecules_read = 0;
  _reduce_to_largest_fragment = 0;
  _remove_chirality = 0;

  _write_parent_molecule = 0;

  _molecules_discarded_by_must_have_queries = 0;
  _molecules_discarded_by_must_not_have_queries = 0;

  _molecules_with_invalid_valences_suppressed = 0;

  _unique_molecules_only = 0;

  _preserve_connectivity = 1;

  _min_examples_needed = 0;
  _replacement_rings_discarded_for_count = 0;

  _duplicates_suppressed = 0;

  _molecules_formed = 0;

  _remove_isotopes = 0;
  _translate_isotopes = 0;

  _sort_output_by_precedent = 0;

  _nreplacements = 0;
  _rings = nullptr;
}

RingReplacement::~RingReplacement() {
  if (_rings != nullptr) {
    delete [] _rings;
  }
}

int
RingReplacement::Initialise(Command_Line& cl) {
  _verbose = cl.option_count('v');

  if (cl.option_present('c')) {
    _remove_chirality = 1;
    if (_verbose) {
      cerr << "Will remove chirality from input molecules\n";
    }
  }

  if (cl.option_present('g')) {
    if (! _chemical_standardisation.construct_from_command_line(cl, _verbose > 1, 'g')) {
      cerr << "Cannot initialise chemical standardisation\n";
      return 0;
    }
  }

  if (cl.option_present('l')) {
    _reduce_to_largest_fragment = 1;
    if (_verbose) {
      cerr << "Will reduce molecules to largest fragment\n";
    }
  }

  if (cl.option_present('s')) {
    const_IWSubstring smarts;
    for (int i = 0; cl.value('s', smarts, i); ++i) {
      std::unique_ptr<Substructure_Query> q = std::make_unique<Substructure_Query>();
      if (! q->create_from_smarts(smarts)) {
        cerr << "Cannot parse smarts '" << smarts << "'\n";
        return 0;
      }
      _queries << q.release();
    }
  }

  if (cl.option_present('q')) {
    if (! process_queries(cl, _queries, _verbose, 'q')) {
      cerr << "Cannot read queries (-q)\n";
      return 0;
    }
  }

  for (Substructure_Query* q : _queries) {
    q->set_embeddings_do_not_overlap(1);
  }

  if (cl.option_present('Y')) {
    if (! process_queries(cl, _products_must_have, _verbose, 'M')) {
      cerr << "Cannot read products must have queries (-M)\n";
      return 0;
    }
  }

  if (cl.option_present('N')) {
    if (! process_queries(cl, _products_must_not_have, _verbose, 'N')) {
      cerr << "Cannot read products must not have queries (-N)\n";
      return 0;
    }
  }

  if (cl.option_present('D')) {
    if (! process_queries(cl, _replacement_ignore, _verbose, 'D')) {
      cerr << "Cannot read replacement ring must not have queries (-D)\n";
      return 0;
    }
  }

  if (cl.option_present('u')) {
    _unique_molecules_only = 1;
    if (_verbose) {
      cerr << "Will only produce unique molecules\n";
    }
  }

  if (cl.option_present('p')) {
    _write_parent_molecule = 1;
    if (_verbose) {
      cerr << "Will write the parent molecule\n";
    }
  }

  if (cl.option_present('n')) {
    if (! cl.value('n', _min_examples_needed) || _min_examples_needed < 1) {
      cerr << "The min examples needed option (-n) must be a whole +ve number\n";
      return 0;
    }
    if (_verbose) {
      cerr << "Will only consider rings with at least " << _min_examples_needed << " examples\n";
    }
  }

  // Make sure this is set before reading the replacement rings.
  if (cl.option_present('w')) {
    _sort_output_by_precedent = 1;
    if (_verbose) {
      cerr << "Will write new molecules in order of precedent\n";
    }
  }

  if (! cl.option_present('R')) {
    cerr << "Must specify one of more sets of replacement rings via the -R option\n";
    return 0;
  }

  if (cl.option_present('d')) {
    _preserve_connectivity = 0;
    if (_verbose) {
      cerr << "Will allow changes in ring connectivity\n";
    }
  }

  _nreplacements = cl.option_count('R');

  _rings = new resizable_array_p<Replacement>[_nreplacements];

  if (cl.option_present('R')) {
    IWString r;
    for (int i = 0; cl.value('R', r, i); ++i) {
      if (! ReadReplacementRings(r, i)) {
        cerr << "Cannot read replpcement rings '" << r << "'\n";
        return 0;
      }
    }

    if (_verbose) {
      for (int i = 0; i < _nreplacements; ++i) {
        cerr << " set " << i << " read " << _rings[i].size() << " replacement rings\n";
      }
    }
  }

  if (cl.option_present('I')) {
    const_IWSubstring i = cl.string_value('I');
    if (i == '.') {
      _remove_isotopes = 1;
      if (_verbose) {
        cerr << "Will remove isotopes from product molecules\n";
      }
    } else if (i.numeric_value(_translate_isotopes)) {
      if (_verbose) {
        cerr << "Will translate all isotopes to " << _translate_isotopes << '\n';
      }
    } else {
      cerr << "Unrecognised -I qualifier '" << i << "'\n";
      return 1;
    }
  }

  if (cl.option_present('P')) {
    const_IWSubstring p = cl.string_value('P');
    if (! _atype.build(p)) {
      cerr << "Invalid atom type specification '" << p  << "'\n";
      return 0;
    }
  }

  if (cl.option_present('3')) {
    for (int i = 0; i < _nreplacements; ++i) {
      for (Replacement* r : _rings[i]) {
        r->set_transfer_coordinates(1);
      }
    }
    if (_verbose) {
      cerr << "Will write 3D coordinates\n";
    }
    set_append_coordinates_after_each_atom(1);
  }

  if (cl.option_present('B')) {
    IWString fname = cl.string_value('B');
    if (! fname.ends_with(".smi")) {
      fname << ".smi";
    }
    if (! _stream_for_unchanged_molecules.open(fname)) {
      cerr << "Cannot open stream for unprocessed molecules '" << fname << "'\n";
      return 0;
    }
    if (_verbose) {
      cerr << "Unchanged molecules written to '" << fname << "'\n";
    }
  }

  return 1;
}

int
RingReplacement::ReadReplacementRings(IWString& fname, int ndx) {
  iwstring_data_source input(fname);
  if (! input.good()) {
    cerr << "RingReplacement::ReadReplacementRings:cannot open '" << fname << "'\n";
    return 0;
  }

  return ReadReplacementRings(input, ndx);
}

int
RingReplacement::ReadReplacementRings(iwstring_data_source& input, int ndx) {
  const_IWSubstring line;
  while (input.next_record(line)) {
    google::protobuf::io::ArrayInputStream zero_copy_array(line.data(), line.nchars());
    RplRing::ReplacementRing proto;
    if (!google::protobuf::TextFormat::Parse(&zero_copy_array, &proto)) {
      cerr << "RingReplacement:ReadReplacementRings:cannot parse proto " << line << '\n';
      return 0;
    }

    if (_preserve_connectivity && ! proto.conn()) {
      continue;
    }

    std::unique_ptr<Replacement> r = std::make_unique<Replacement>();
    if (! r->BuildFromProto(proto)) {
      cerr << "RingReplacement::ReadReplacementRings:cannot parse " << proto.ShortDebugString() << "\n";
      return 0;
    }

    if (! OkSupport(*r)) {
      continue;
    }

    if (AnyReplacementRingIgnoreQueryMatches(*r)) {
      continue;
    }

    _rings[ndx] << r.release();
  }

  if (_rings[ndx].empty()) {
    cerr << "RingReplacement::ReadReplacementRings:no replacement rings\n";
    return 0;
  }

  if (_sort_output_by_precedent) {
    _rings[ndx].iwqsort_lambda([](const Replacement* r1, const Replacement* r2) {
      if (r1->count() < r2->count()) {
        return 1;
      } else if (r1->count() > r2->count()) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  return 1;
}

// Return true if any of the _replacement_ignore queries match the
// molecule in `r`.
int
RingReplacement::AnyReplacementRingIgnoreQueryMatches(Replacement& r) {
  if (_replacement_ignore.empty()) {
    return 0;
  }

  Molecule_to_Match target(&r.mol());
  for (Substructure_Query * q : _replacement_ignore) {
    if (q->substructure_search(target)) {
      return 1;
    }
  }

  return 0;
}

int
RingReplacement::OkSupport(const Replacement& r) {
  if (r.count() < _min_examples_needed) {
    ++_replacement_rings_discarded_for_count;
    return 0;
  }

  return 1;
}

int
RingReplacement::Preprocess(Molecule& m) {
  if (_reduce_to_largest_fragment) {
    m.reduce_to_largest_fragment_carefully();
  }

  if (_chemical_standardisation.active()) {
    _chemical_standardisation.process(m);
  }

  if (_remove_chirality) {
    m.remove_all_chiral_centres();
  }

  if (m.natoms() == 0) {
    return 0;
  }

  return 1;
}

int
RingReplacement::Report(std::ostream& output) {
  output << "RingReplacement:read " << _molecules_read << " molecules\n";
  if (_molecules_read == 0) {
    return 1;
  }
  if (_min_examples_needed) {
    output << _replacement_rings_discarded_for_count << " replacement rings discarded for support below " << _min_examples_needed << '\n';
  }
  output << _duplicates_suppressed << " duplicates suppressed\n";
  output << "Formed " << _molecules_formed << " molecules\n";

  for (int i = 0; i < _number_variants.number_elements(); ++i) {
    if (_number_variants[i]) {
      output << _number_variants[i] << " molecules generated " << i << " variants\n";
    }
  }

  int tot = 0;
  int nonzero = 0;
  for (int i = 0; i < _nreplacements; ++i) {
    tot += _rings[i].number_elements();
    for (Replacement* r : _rings[i]) {
      if (r->variants_generated()) {
        ++nonzero;
      }
      r->Report(output);
    }
  }
  output << nonzero << " of " << tot << " replacement rings generated variants " 
        << iwmisc::Fraction<float>(nonzero, tot) << '\n';

  return 1;
}

// For all query matches of `queries` agains `m`, set the
// corresponding entries in `process_atom`.
int
RingReplacement::IdentifyMatchedAtoms(Molecule& m,
                        resizable_array_p<Substructure_Query>& queries,
                        int* process_atom) {
  int rc = 0;
  Molecule_to_Match target(&m);
  for (Substructure_Query* q : queries) {
    Substructure_Results sresults;
    if (! q->substructure_search(target, sresults)) {
      continue;
    }
    sresults.each_embedding_set_vector(process_atom, 1);
    ++rc;
  }

  return rc;
}

int
RingReplacement::Process(Molecule& m,
                         IWString_and_File_Descriptor& output) {
  ++_molecules_read;

  std::unique_ptr<uint32_t[]> atypes;
  if (_atype.active()) {
    atypes.reset(new uint32_t[m.natoms()]);
    _atype.assign_atom_types(m, atypes.get());
  }

  std::unique_ptr<int[]> process_atom;
  if (_queries.size()) {
    process_atom.reset(new_int(m.natoms()));
    if (! IdentifyMatchedAtoms(m, _queries, process_atom.get())) {
      return 0;
    }
  }

  resizable_array_p<Molecule> generated;
  generated << new Molecule(m);

  if (! Process(generated, 0, atypes.get(), process_atom.get())) {
    return 0;
  }

  if (_verbose > 1) {
    cerr << "From " << m.name() << " generated " << generated.size() << "  molecules\n";
  }

  if (generated.size() == 1) {
    if (_stream_for_unchanged_molecules.is_open()) {
      _stream_for_unchanged_molecules << m.smiles() << ' ' << m.name() << '\n';
      _stream_for_unchanged_molecules.write_if_buffer_holds_more_than(8192);
    }
    return 1;
  }

  return Write(generated, output);
}

// All isotopic atoms get translated to `iso`.
void
TranslateIsotopes(Molecule& m, isotope_t iso) {
  const int matoms = m.natoms();
  for (int i = 0; i < matoms; ++i) {
    if (m.isotope(i)) {
      m.set_isotope(i, iso);
    }
  }
}

// Return true if `process_atom` is null.
// Return true if any of the atoms in `embedding` are set in
// `process_atom`.
int
MatchesAtomsToProcess(int n, const int* process_atom,
                      const Set_of_Atoms& embedding) {
  if (process_atom == nullptr) {
    return 1;
  }

  return embedding.any_members_set_in_array(process_atom);
}

//#define DEBUG_RING_REPLACEMENT_PROCESS

int
RingReplacement::Process(resizable_array_p<Molecule>& mols,
                         int ndx,
                         const uint32_t* atypes,
                         const int* process_atom) {

  resizable_array_p<Molecule> generated_here;
  generated_here.reserve(10 * mols.size());

#ifdef DEBUG_RING_REPLACEMENT_PROCESS
  cerr << "RingReplacement::Process:scanning " << mols.size() << " molecules\n";
#endif

  for (Molecule* m : mols) {
#ifdef DEBUG_RING_REPLACEMENT_PROCESS
    cerr << "processing " << m->name() << '\n';
#endif
    Molecule_to_Match target(m);
    Substructure_Results sresults;

    for (Replacement* r : _rings[ndx]) {
#ifdef DEBUG_RING_REPLACEMENT_PROCESS
      Substructure_Results for_debugging;
      cerr << "Processing replacement " << ndx << " SSS " << r->SubstructureSearch(target, for_debugging) << '\n';
#endif
      if (! r->SubstructureSearch(target, sresults)) {
        continue;
      }

      for (const Set_of_Atoms* e : sresults.embeddings()) {
        if (! MatchesAtomsToProcess(m->natoms(), process_atom, *e)) {
          continue;
        }
        std::unique_ptr<Molecule> variant;
        if (! r->MakeVariant(*m, *e, atypes, variant)) {
          continue;
        }
        if (!IsUnique(*variant)) {
          continue;
        }
        if (!OkQueryConstraints(*variant)) {
          continue;
        }
        if (_remove_isotopes) {
          variant->transform_to_non_isotopic_form();
        } else if (_translate_isotopes) {
          TranslateIsotopes(*variant, _translate_isotopes);
        }
        variant->reduce_to_largest_fragment();

        generated_here << variant.release();
      }
    }
  }

  ++_number_variants[generated_here.size()];

  mols.transfer_in(generated_here);

  if (ndx < _nreplacements - 1) {
    Process(mols, ndx + 1, atypes, process_atom);
    return 1;
  }

  return 1;
}

int
RingReplacement::IsUnique(Molecule& m) {
  if (! _unique_molecules_only) {
    return 1;
  }

  if (_seen.contains(m.unique_smiles())) {
    return 0;
  }

  _seen.insert(m.unique_smiles());

  // Make sure we do not write unique smiles.
  m.invalidate_smiles();

  return 1;
}

// Return true if any of `queries` match `target`.
int
MatchAny(Molecule_to_Match& target,
         resizable_array_p<Substructure_Query>& queries) {
  for (Substructure_Query* q : queries) {
    if (q->substructure_search(target)) {
      return 1;
    }
  }

  return 0;
}

int
RingReplacement::OkQueryConstraints(Molecule& m) {
  Molecule_to_Match target(&m);

  if (_products_must_have.empty()) {
  } else if (! MatchAny(target, _products_must_have)) {
    return 0;
  }

  if (_products_must_not_have.empty()) {
  } else if (MatchAny(target, _products_must_not_have)) {
    return 0;
  }
  
  return 1;
}

int
RingReplacement::Write(const resizable_array_p<Molecule>& mols,
                       IWString_and_File_Descriptor& output) {
  for (Molecule* m : mols) {
    output << m->smiles() << ' ' << m->name() << '\n';
    output.write_if_buffer_holds_more_than(8192);
  }
  output.flush();

  _molecules_formed += mols.number_elements();

  return 1;
}


int
ReplaceCore(RingReplacement& ring_replacement,
            Molecule& m,
            IWString_and_File_Descriptor& output) {
  return ring_replacement.Process(m, output);
}

int
ReplaceCore(RingReplacement& ring_replacement,
            data_source_and_type<Molecule>& input,
            IWString_and_File_Descriptor& output) {
  Molecule * m;
  while ((m = input.next_molecule()) != nullptr) {
    std::unique_ptr<Molecule> free_m(m);

    if (! ring_replacement.Preprocess(*m)) {
      continue;
    }

    if (! ReplaceCore(ring_replacement, *m, output)) {
      cerr << "Fatal error processing " << m->name() << '\n';
      return 0;
    }
  }

  return 1;
}

int
ReplaceCore(RingReplacement& ring_replacement,
            const char * fname,
            FileType input_type,
            IWString_and_File_Descriptor& output) {
  if (input_type == FILE_TYPE_INVALID) {
    input_type = discern_file_type_from_name(fname);
  }

  data_source_and_type<Molecule> input(input_type, fname);
  if (! input.ok()) {
    cerr << "Cannot open '" << fname << "'\n";
    return 0;
  }

  return ReplaceCore(ring_replacement, input, output);
}

void
DisplayDashXOptions(std::ostream& output) {
  output << " -X no_valence_warning             do NOT display warnings about invalid valences\n";
  output << " -X arom_loss_warning              display warnings about aromaticity losses\n";
  ::exit(0);
}

int
Main(int argc, char** argv) {
  Command_Line cl(argc, argv, "vE:A:i:g:lcY:N:R:P:s:q:uapn:D:I:wX:dB:3");
  if (cl.unrecognised_options_encountered()) {
    cerr << "unrecognised_options_encountered\n";
    Usage(1);
  }

  set_copy_name_in_molecule_copy_constructor(1);

  const int verbose = cl.option_count('v');

  if (! process_standard_aromaticity_options(cl, verbose, 'A')) {
    cerr << "Cannot process aromaticity options\n";
    return 1;
  }

  if (! process_elements(cl, verbose, 'E')) {
    cerr << "Cannot process standard elements options (-E)\n";
    return 1;
  }

  if (cl.option_present('X')) {
    const_IWSubstring x;
    for (int i = 0; cl.value('X', x, i); ++i) {
      if (x == "no_valence_warning") {
        ring_replacement::Replacement::_display_valence_error_messages = 0;
        if (verbose) {
          cerr << "Will NOT display valence error messges\n";
        }
      } else if (x == "arom_loss_warning") {
        ring_replacement::Replacement::_warn_loss_of_aromaticity = 1;
        if (verbose) {
          cerr << "Will display loss of aromaticity warnings\n";
        }
      } else if (x == "help") {
        DisplayDashXOptions(cerr);
      } else {
        cerr << "Unrecognised -X qualifier '" << x << "'\n";
        DisplayDashXOptions(cerr);
      }
    }
  }

  RingReplacement ring_replacement;
  if (! ring_replacement.Initialise(cl)) {
    cerr << "Cannot initialise options\n";
    Usage(1);
  }

  FileType input_type = FILE_TYPE_INVALID;

  if (cl.option_present('i')) {
    if (!process_input_type(cl, input_type)) {
      cerr << "Cannot determine input type\n";
      return 1;
    }
  } else if (!all_files_recognised_by_suffix(cl)) {
    return 1;
  }

  if (cl.empty()) {
    cerr << "Insufficient arguments\n";
    Usage(1);
  }

  IWString_and_File_Descriptor output(1);
  for (const char* fname : cl) {
    if (! ReplaceCore(ring_replacement, fname, input_type, output)) {
      cerr << "Fatal error processing '" << fname << "'\n";
      return 1;
    }
  }

  output.flush();

  if (verbose) {
    set_append_coordinates_after_each_atom(0);

    ring_replacement.Report(cerr);
  }

  return 0;
}

}  // namespace ring_replacement

int
main(int argc, char** argv) {
  int rc = ring_replacement::Main(argc, argv);

  return rc;
}
