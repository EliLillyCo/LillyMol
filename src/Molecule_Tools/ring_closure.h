#ifndef MOLECULE_TOOLS_RING_CLOSURE_H
#define MOLECULE_TOOLS_RING_CLOSURE_H

// Given a starting molecule, add ring closure bonds thereby
// making new molecules.

#include <cstdint>
#include <iostream>

#include "Foundational/cmdline/cmdline.h"
#include "Foundational/iwstring/iw_stl_hash_set.h"

#include "Molecule_Lib/molecule.h"
#include "Molecule_Lib/substructure.h"
#include "Molecule_Tools/ring_closure.pb.h"
#include "Molecule_Lib/temp_detach_atoms.h"

namespace ring_closure {

// Some data about the starting molecule that is computed
// once and passed around.
struct MoleculeData {
  public:
    // Number of aromatic rings in the parent molecule.
    int initial_aromatic_ring_count;

    // For each atom, was it aromatic in the parent molecule.
    int* initially_aromatic;

    // The number of spiro ring fusions in the starting molecule.
    int initial_spiro_ring_count;

    // The function to count spiro fused rings needs an array.
    int * spiro_count_tmp_array;

    // A temporary array used during traversals.
    int* visited;

    // We keep track of all the molecules generated by
    // a given starting molecule.
    IW_STL_Hash_Set seen;

    // If the starting molecule has explicit Hydrogens, they
    // will be removed.
    // Care is needed when reattaching in case bonds have been
    // formed.
    Temp_Detach_Atoms temp_detach_atoms;

  public:
    MoleculeData();
    ~MoleculeData();

    int Initialise(Molecule& m);
};

class RingClosureOptions {
  private:
    RingClosure::ring_closure _proto;
    // The size of ring that gets formed - bonds between the two ends.
    int _min_bonds_between;
    int _max_bonds_between;

    // By default, a single bond is placed, but we can do both single
    // and double.
    resizable_array<bond_type_t> _btype;

    // By default, we generate all possible rings in a starting molecule.
    uint32_t _max_variants_formed;

    // We can specify 0, 1 or 2 queries that define the two atoms that
    // be at the end of the bond formed.
    resizable_array_p<Substructure_Query> _connection;

    // We can specify motifs that must be present in the product.
    // If any query matches, the product is OK.
    resizable_array_p<Substructure_Query> _product_must_have;

    // Discard the newly formed molecule if any of these queries match.
    resizable_array_p<Substructure_Query> _product_must_not_have;

    uint32_t _molecules_processed;
    extending_resizable_array<int> _variants_formed;

    // We keep track of how many of each ring size are formed.
    extending_resizable_array<int> _ring_size_formed;

    // For each bond type, how many rings formed.
    extending_resizable_array<int> _formed_with_bond_type;

    // If 3d distance constraints are present.
    float _min_distance;
    float _max_distance;

    // If working in 3D, impose limits on the bond angles formed.
    float _min_bond_angle;
    float _max_bond_angle;

    // For reporting, we keep track of the number of atom pairs
    // that are toplogically OK, but do not meet the distance constraint.
    float _pairs_failing_distance_constraint;

    // We can place isotopes at each end of the newly created bond.
    int _isotope;

    // By default, we do not allow strongly fused aromatics to be
    // formed.
    bool _allow_caged_aromatic_rings;

    // By default, we do NOT allow all aromatic substitutents to form 3
    // membered rings.
    bool _allow_aromatic_3_membered_ring_fusions;

    // By default we do not generate 3 membered rings with double bonds.
    bool _allow_cyclopropene;

    // By default, we allow spiro fusions to form.
    bool _allow_spiro_fusions;

    int _spiro_ring_fusions_created;

    // After each ring is formed, we can attempt to make it aromatic
    // if it is an isolated ring.
    // TODO: ianwatson extend to fused rings if ever needed.
    bool _attempt_aromatization;

    // Transforming [ND3x2] to C may enable more rings to be formed.
    int _nd3x2_to_c;

    // Similar idea for [OD2x2].
    int _od2x2_to_n;

    // The number of successful aromatizations.
    int _aromatized_forms_found;

  // private functions

    int IdentifyRingEnds(Molecule& m, int* ok_atom);
    int OkChemistry(Molecule& m, atom_number_t atom1, atom_number_t atom2,
                bond_type_t btype) const;
    int OkBondSeparation(const int dist) const;
    int OkQueryRequirements(Molecule& m);
    int OkDistance(float d);
    int OkBondAngles(const Molecule& m,
                                 atom_number_t a1,
                                 atom_number_t a2) const;
    int OkBondAnglesDirectional(const Molecule& m,
                                 atom_number_t a1,
                                 atom_number_t a2) const;
    int OkImplicitHydrogens(Molecule& m, atom_number_t zatom, bond_type_t btype) const;
    int ContainsCagedAromaticRing(Molecule& m);
    int InSameAromaticSystem(Molecule& m,
                        atom_number_t a1,
                        atom_number_t a2) const;
    int TripleBondInRing(Molecule& m) const;
    int WouldFormBridgedAromatic(Molecule& m,
                        atom_number_t a1,
                        atom_number_t a2) const;
    int WouldFormDisallowedCyloPropene(Molecule& m,
                atom_number_t a1, atom_number_t a2, int bonds_between,
                bond_type_t btype) const;
    int WouldFormDisallowedSpiroFusion(Molecule& m,
                atom_number_t a1, atom_number_t a2, int bonds_between,
                bond_type_t btype) const;
    int ContainsRequiredMotif(Molecule_to_Match& target);
    int WouldFormDisallowedFused3MemberedRing(Molecule& m,
                atom_number_t a1, atom_number_t a2, int bonds_between) const;
    int StronglyFusedRingIncludesAromatic(Molecule& m,
                atom_number_t a1, atom_number_t a2,
                MoleculeData& molecule_data);
    int AlreadySeen(Molecule& m, IW_STL_Hash_Set& seen) const;
    int MaybeAttemptAromatization(Molecule& m, atom_number_t a1, atom_number_t a2,
                MoleculeData& molecule_data,
                resizable_array_p<Molecule>& result);
    int MaybePlaceIsotopes(Molecule& m,
                                       atom_number_t a1,
                                       atom_number_t a2) const;
    int MaybeReattachHydrogens(Molecule& m, 
                atom_number_t a1, 
                atom_number_t a2,
                MoleculeData& molecule_data);
    void UpdateRingsFormed(int nbonds, bond_type_t btype);
    int FormRings(Molecule& m,
                        const int* ok_atom,
                        std::optional<atom_number_t> only_process,
                        bond_type_t btype,
                        MoleculeData& molecule_data,
                        resizable_array_p<Molecule>& result);
    void TrackSpiroFusions(Molecule& m, MoleculeData& molecule_data);

  public:
    RingClosureOptions();

    int Initialise(Command_Line& cl, char flag);

    // Given a single starting molecule, generate a (possibly empty) list of
    // the molecules that can be formed by ring closures in `m`.
    resizable_array_p<Molecule> Process(Molecule& m);

    int Report(std::ostream& output) const;
};

}

#endif // MOLECULE_TOOLS_RING_CLOSURE_H
