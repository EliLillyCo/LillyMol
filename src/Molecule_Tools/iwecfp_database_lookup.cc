// Looks up molecules in a database built by iwecfp_database_load, single threaded only
// since threading did not help. Should remove the remaining threading vestiges.
// More complex than needed, partially because this contains many ideas that have been
// tried over time. The most useful output seems to be what is generated by `-w PSD`
// but then the consumer needs to figure out how to value that data.

#include <atomic>
#include <iomanip>
#include <iostream>
#include <limits>
#include <memory>
#include <mutex>

#ifdef __WIN32__
#include <winsock2.h>
#else
#include <netinet/in.h>
#endif

#include <assert.h>

#include "db_cxx.h"

#define RESIZABLE_ARRAY_IMPLEMENTATION
#define RESIZABLE_ARRAY_IWQSORT_IMPLEMENTATION
#include "Foundational/accumulator/accumulator.h"
#include "Foundational/cmdline/cmdline.h"
#include "Foundational/iwaray/iwaray.h"
#include "Foundational/iwmisc/misc.h"
#include "Foundational/iwmisc/report_progress.h"
#include "Foundational/iwqsort/iwqsort.h"
#include "Foundational/iwstring/iw_stl_hash_map.h"
#include "Foundational/iwstring/iw_stl_hash_set.h"

#define ISTREAM_AND_TYPE_IMPLEMENTATION

#include "Molecule_Lib/aromatic.h"
#include "Molecule_Lib/atom_typing.h"
#include "Molecule_Lib/istream_and_type.h"
#include "Molecule_Lib/molecule.h"
#include "Molecule_Lib/standardise.h"

#include "iwecfp_database.h"

using std::cerr;

using iwecfp_database::Bit_Produced;
using iwecfp_database::Count_Radius;
using iwecfp_database::DBKey;
using iwecfp_database::Fingerprint_Characteristics;
using iwecfp_database::IWdbkeyHash;
using iwecfp_database::Set_of_Bits;

static Chemical_Standardisation chemical_standardisation;

static int verbose = 0;

static int molecules_read = 0;
static int molecules_written = 0;

static int iwecfp_atom_type = IWATTYPE_Z;

static int write_isotopically_labelled_summary_structure = 0;

static int write_per_shell_data = 0;

static int only_write_outer_shell = 0;

static int write_example_structures = 1;

static int isotopically_label_most_difficult_atoms = 0;

// static DbEnv dbenv (DB_CXX_NO_EXCEPTIONS);

static int doing_ring_system_desirability = 0;

static Report_Progress report_progress;

static int create_descriptor_file = 0;
static char descriptor_file_output_separator = ' ';  // not fully implemented

/*
  We might be interested in not just the number of zero bits, but
  maybe the number of rare bits. We can define rare
*/

static int count_threshold = 0;

#ifdef CACHE_SIZE_SETTABLE
looks like this was never implemented static int db_cache_size = 0;  // 33554432;
#endif

/*
  If we have slurped parts of the database to RAM, we don't do any
  database lookups
*/

static int slurp_examples = 0;

// static double minimum_score_needed = -1.0;

static IWString_and_File_Descriptor stream_for_too_hard;

static int show_number_bits_missing_for_missing_bits = 0;

static unsigned int max_hash_size = 0;

static int parallel_group_size = 0;

static int flush_output_each_molecule = 0;

static int include_score_with_normal_results = 0;

/*
  A debugging aid. When molecules are looked up, the number of instances
  found in the db's should monotonically decrease with radius
*/

static int check_monotonicity_bits_found = 0;

static int per_atom_counts = 0;

/*
  There is a need to assign scores in given ranges to labels.
  Decided not to implement, write post-processing script instead
*/

class Human_Labels
{
 private:
  int _radius;

 public:
  Human_Labels();

  int
  active() const
  {
    return _radius >= 0;
  }

  int
  build(const char* fname);
  int
  build(iwstring_data_source&);
};

Human_Labels::Human_Labels()
{
  _radius = -1;
}

int
Human_Labels::build(const char* fname)
{
  iwstring_data_source input(fname);

  if (!input.good()) {
    cerr << "Human_Labels::build:cannot open '" << fname << "'\n";
    return 0;
  }

  return build(input);
}

int
Human_Labels::build(iwstring_data_source& input)
{
  const_IWSubstring buffer;

  while (input.next_record(buffer)) {
    if (buffer.starts_with('#')) {
      continue;
    }
  }

  return 1;
}

static Human_Labels human_labels;

/*
  A per-thread mechanism for accumulating outputs
*/

class SF_Results
{
 private:
  IWString _to_stdout;

  int _accumulate_rejected_molecules;

  IWString _to_rejected_stream;
  double _score;

 public:
  SF_Results();

  int
  accumulate_rejected_molecules() const
  {
    return _accumulate_rejected_molecules;
  }

  void
  set_accumulate_rejected_molecules(int s)
  {
    _accumulate_rejected_molecules = s;
  }

  void
  reset();

  double
  score() const
  {
    return _score;
  }

  void
  set_score(double s)
  {
    _score = s;
  }

  IWString&
  to_stdout()
  {
    return _to_stdout;
  }

  const IWString&
  to_stdout() const
  {
    return _to_stdout;
  }

  IWString&
  to_rejected_stream()
  {
    return _to_rejected_stream;
  }

  const IWString&
  to_rejected_stream() const
  {
    return _to_rejected_stream;
  }
};

SF_Results::SF_Results()
{
  _score = -9.0;
  _accumulate_rejected_molecules = 0;

  return;
}

void
SF_Results::reset()
{
  _to_stdout.resize_keep_storage(0);
  _to_rejected_stream.resize_keep_storage(0);

  return;
}

class Score_Related
{
 private:
  double _minimum_score_needed;

  int _min_examples;

  Accumulator<double> _acc_score;

  std::mutex _mutex;

  int _molecules_with_score_zero;

  int _molecules_rejected_for_score_too_low;

  //  private functions

  int
  _okscore_mutex_protected(const double score);

 public:
  Score_Related();

  int build(const Command_Line& cl, const char, const int verbose);

  int report(std::ostream&) const;

  int okscore(const double score);
};

Score_Related::Score_Related()
{
  _minimum_score_needed = -std::numeric_limits<double>::max();

  _min_examples = -1;

  _molecules_with_score_zero = 0;

  _molecules_rejected_for_score_too_low = 0;

  return;
}

static double
mylog10(const int x)
{
  if (0 == x) {
    return 0.0;
  }

  if (x > 1) {
    return log10(static_cast<double>(x));
  }

  return 0.1;  // nice easy number
  // return 0.1505149978319906;    // which is half of log10(2.0)
}

int
Score_Related::build(const Command_Line& cl, const char u1, const int verbose)
{
  if (!cl.option_present(u1)) {  // nothing to do
    return 1;
  }

  const_IWSubstring s = cl.string_value(u1);

  if (s.starts_with('E')) {
    s.remove_leading_chars(1);

    if (!s.numeric_value(_min_examples) || _min_examples < 1) {
      cerr << "Score_Related::build:the minimum number of examples 'E" << s
           << "' must specify a valid +ve number\n";
      return 0;
    }

    _minimum_score_needed = mylog10(_min_examples) - 0.01;

    if (verbose) {
      cerr << "Score_Related::build:requiring at least " << _min_examples
           << " examples, translates to a min score of " << _minimum_score_needed << '\n';
    }
  } else if (!s.numeric_value(_minimum_score_needed)) {
    cerr << "Score_Related::build:the minimum score (-" << u1
         << ") must be a positive value\n";
    return 0;
  }

  if (verbose) {
    cerr << "Score_Related::build:will discard molecules with scores below "
         << _minimum_score_needed << '\n';
  }

  return 1;
}

int
Score_Related::report(std::ostream& output) const
{
  output << "Score_Related::report:examined " << _acc_score.n() << " molecules\n";

  if (0 == _acc_score.n()) {
    return 1;
  }

  output << _molecules_with_score_zero << " molecules with zero score";
  if (_min_examples > 0) {
    output << ", " << _molecules_rejected_for_score_too_low << " rejected for fewer than "
           << _min_examples << " examples";
  } else if (_minimum_score_needed > 0.0) {
    output << ", " << _molecules_rejected_for_score_too_low
           << " rejected for scores below " << _minimum_score_needed;
  }
  output << '\n';

  if (1 == _acc_score.n()) {
    output << " single value " << _acc_score.minval() << '\n';
  } else {
    output << "Scores between " << _acc_score.minval() << " and " << _acc_score.maxval()
           << " ave " << static_cast<float>(_acc_score.average()) << '\n';
  }

  return 1;
}

template <typename T>
int
write_smiles_and_id(Molecule& m, const int max_shell_radius, const int* min_each_shell,
                    const Set_of_Atoms* rarest_atom, T& output)
{
  if (create_descriptor_file) {
    output << m.name();
    return 1;
  }

  if (0 == isotopically_label_most_difficult_atoms) {
    output << m.smiles() << ' ' << m.name();
    return 1;
  }

  for (int i = max_shell_radius; i >= 0; --i) {
    if (rarest_atom[i].number_elements() > 0) {
      return write_smiles_and_id(m, i, rarest_atom[i], output);
    }
  }

  output << m.smiles() << ' ' << m.name();

  return 1;
}

int
Score_Related::okscore(const double score)
{
  _mutex.lock();

  int rc = _okscore_mutex_protected(score);

  _mutex.unlock();

  return rc;
}

int
Score_Related::_okscore_mutex_protected(const double score)
{
  _acc_score.extra(score);

  if (score <= 0.0) {
    _molecules_with_score_zero++;
  }

  if (score >= _minimum_score_needed) {
    return 1;  // score is good
  }

  _molecules_rejected_for_score_too_low++;

  return 0;  // score is bad
}

static Score_Related score_related;

/*
  A lookup class for databases built by iwecfp_database_load
*/

class SP_Database
{
 private:
  Db* _db;
  DbEnv* _env;

  int _lookups_done;
  int _bits_found;

  // We need a mutex to protect access to the _hash related things

  std::mutex _mutex;

  std::unordered_map<DBKey, Count_Radius, IWdbkeyHash> _hash;
  int _hash_size;
  int _cache_hit;

  int _contains_examples;

  IWString _dbname;

  int _logfile_open;

  std::ofstream _logfile;

  int _need_to_swap_bytes;  // not used

  //  private functions

  int _do_open(const char*, int multi_threaded);
  int _parse_database_record(const const_IWSubstring& fromdb, const DBKey& dbkey, int& radius,
                         int& count, IWString& example);
  int _in_cache(Dbt& zkey, const DBKey& dbkey, int& radius, int& count);
  int _in_cache_mutex_protected(Dbt& zkey, const DBKey& dbkey, int& radius, int& count);

 public:
  SP_Database();
  ~SP_Database();

  int report(std::ostream&) const;
  int debug_print(std::ostream&) const;

  int open_logfile(const char* fname);

  int determine_if_examples_present();

  int contains_example_structures() const
  {
    return _contains_examples;
  }

  void set_env(DbEnv* e)
  {
    _env = e;
  }

  int open(const char*, int multi_threaded);
  //  int open(const const_IWSubstring & s, int ndx);

  unsigned int slurp_to_cache(int);

  int check_exists(Dbt* zkey);

  int do_lookup(Dbt& zkey, const DBKey& dbkey, int& radius, int& count, IWString& example);
  int get(DbTxn*, Dbt&, Dbt&, u_int32_t);
};

SP_Database::SP_Database()
{
  _db = nullptr;
  _env = nullptr;

  _lookups_done = 0;
  _bits_found = 0;
  _hash_size = 0;
  _cache_hit = 0;

  _contains_examples = 1;  // until proven otherwise

  _logfile_open = 0;

  _need_to_swap_bytes = 0;

  return;
}

SP_Database::~SP_Database()
{
  if (nullptr != _db) {
    delete _db;
  }

  return;
}

int
SP_Database::debug_print(std::ostream& output) const
{
  output << "SP_Database::debug_print:database '" << _dbname << "' _contains_examples "
         << _contains_examples << " _hash_size " << _hash_size << '\n';

  return 1;
}

int
SP_Database::report(std::ostream& os) const
{
  os << "Database '" << _dbname << "' looked up " << _lookups_done << " bits, found "
     << _bits_found << " bits\n";
  if (_hash.size() > 0) {
    os << "Bit hash contains " << _hash.size() << " bits, " << _cache_hit
       << " cache hits\n";
  }

  return 1;
}

int
SP_Database::open(const char* dbname, int multi_threaded)
{
  return _do_open(dbname, multi_threaded);
}

int
SP_Database::open_logfile(const char* fname)
{
  _logfile.open(fname, std::ios::out);

  if (!_logfile.good()) {
    cerr << "SP_Database::open_logfile:cannot open '" << fname << "'\n";
    return 0;
  }

  _logfile_open = 1;

  return 1;
}

int
SP_Database::_do_open(const char* dbname, int multi_threaded)
{
  if (nullptr != _db) {
#ifdef DEBUG_SEQUENCE_DATABASE_STUFF
    cerr << "Deleting old database\n";
#endif

    delete _db;
  }

  _db = new Db(_env, DB_CXX_NO_EXCEPTIONS);

#ifdef DEBUG_SEQUENCE_DATABASE_STUFF
  cerr << "Opening '" << dbname << "'\n";
#endif

  int oflags = DB_RDONLY;
  if (multi_threaded) {
    oflags |= DB_THREAD;
  }

  int rc = _db->open(NULL, dbname, NULL, DB_UNKNOWN, oflags, 0);

  if (0 != rc) {
    cerr << "Cannot open database '" << dbname << "' ";
    _db->err(rc, "");

    return 0;
  }

  _dbname = dbname;

  return 1;
}

unsigned int
SP_Database::slurp_to_cache(int min_examples)
{
  Dbc* cursor = nullptr;

  int rc = _db->cursor(NULL, &cursor, 0);
  if (0 != rc) {
    _db->err(rc, "cannot acquire cursor");
    return 0;
  }

  int records_in_database = 0;

  Dbt zkey, zdata;

  while (0 == (rc = cursor->get(&zkey, &zdata, DB_NEXT))) {
    records_in_database++;

    if (sizeof(Count_Radius) != zdata.get_size()) {
      continue;
    }

    const Count_Radius* cr = reinterpret_cast<const Count_Radius*>(zdata.get_data());

    if (cr->_count < min_examples) {
      continue;
    }

    DBKey* dbkey = reinterpret_cast<DBKey*>(zkey.get_data());

    Count_Radius cr2;
    cr2._count = cr->_count;
    cr2._radius = cr->_radius;
    _hash[*dbkey] = cr2;
  }

  if (DB_NOTFOUND != rc) {
    _db->err(rc, "Strange error at end of cursor");
  }

  if (verbose) {
    cerr << "Slurped " << _hash.size() << " of " << records_in_database
         << " database records into hash "
         << static_cast<float>(_hash.size()) / static_cast<float>(records_in_database)
         << '\n';
  }

  return _hash.size();
}

int
SP_Database::_parse_database_record(
    const const_IWSubstring& fromdb,
    const DBKey& dbkey,  // just for informational messages
    int& radius, int& count, IWString& example)
{
  if (fromdb.nwords() < 3) {
    cerr << "SP_Database::_parse_database_record:corrupted database contents for bit "
         << dbkey._bit << " found '" << fromdb << "'\n";
    return 0;
  }

  int i = 0;
  const_IWSubstring token;

  fromdb.nextword(token, i);

  if (!token.numeric_value(count) || count < 1) {
    cerr << "Invalid count in database for bit " << dbkey._bit << " found '" << fromdb
         << "'\n";
    return 0;
  }

  fromdb.nextword(token, i);

  if ('4' == token) {
    radius = 4;
  } else if ('3' == token) {
    radius = 3;
  } else if ('2' == token) {
    radius = 2;
  } else if ('1' == token) {
    radius = 1;
  } else if ('0' == token) {
    radius = 0;
  } else if (!token.numeric_value(radius) || radius < 0)  // Strange
  {
    cerr << "Invalid radius in database for bit " << dbkey._bit << " found '" << fromdb
         << "'\n";
    return 0;
  }

  // What follows is the smiles and name of the example

  example = fromdb.substr(i + 1);

  // cerr << "Example set to '" << example << "'\n";

  return 1;
}

int
SP_Database::_in_cache_mutex_protected(Dbt& zkey, const DBKey& dbkey, int& radius,
                                       int& count)
{
  // const DBKey * dbkey = reinterpret_cast<const DBKey *>(zkey.get_data());

  const auto f = _hash.find(dbkey);

  if (f == _hash.end()) {
    return 0;
  }

  _cache_hit++;

  count = (*f).second._count;
  radius = (*f).second._radius;
  _bits_found++;
  return 1;
}

int
SP_Database::_in_cache(Dbt& zkey, const DBKey& dbkey, int& radius, int& count)
{
  _mutex.lock();
  int rc = _in_cache_mutex_protected(zkey, dbkey, radius, count);
  _mutex.unlock();
  return rc;
}

/*
  The DBKey object is not really used, just for informational messages
*/

int
SP_Database::do_lookup(Dbt& zkey, const DBKey& dbkey, int& radius, int& count,
                       IWString& example)
{
// #define DEBUG_SP_DATABASE_DO_LOOKUP
#ifdef DEBUG_SP_DATABASE_DO_LOOKUP
  cerr << "SP_Database::do_lookup, bit " << dbkey._bit << " examples? "
       << _contains_examples << '\n';
#endif

  example.resize_keep_storage(0);

  _lookups_done++;

  if (max_hash_size > 0 && _in_cache(zkey, dbkey, radius, count)) {
    return 1;
  }

  if (slurp_examples > 0) {  // no longer doing lookups, bit not present
    return 0;
  }

  Dbt zdata;
  char* user_memory;
  if (!_contains_examples) {
    user_memory = new char[8];
    zdata.set_ulen(8);
  } else {
    user_memory = new char[1024];
    zdata.set_ulen(1024);
  }

  std::unique_ptr<char[]> free_user_memory(user_memory);

  zdata.set_data(user_memory);
  zdata.set_flags(DB_DBT_USERMEM);

  //_logfile << "key " << zkey.get_size() << " bytes, flags " << zkey.get_flags() << '\n';

  int dbrc = _db->get(NULL, &zkey, &zdata, 0);

  if (0 == dbrc) {  // great, found
    ;
  } else if (DB_NOTFOUND == dbrc) {  // not here
    return 0;
  } else {
    _db->err(dbrc, "Unspecified database error, see Ian");
    return 0;
    ;
  }

  _bits_found++;

#ifdef DEBUG_SP_DATABASE_DO_LOOKUP
  cerr << "Db contents size " << zdata.get_size() << '\n';
#endif

  if (8 == zdata.get_size())  // no examples here. Should be a #defined symbol
  {
    const int* iptr = reinterpret_cast<const int*>(zdata.get_data());

    count = iptr[0];
    radius = iptr[1];
    if (_logfile_open) {
      _mutex.lock();
      _logfile << "bit " << dbkey._bit << " centre " << dbkey._acca << " found " << count
               << " count, radius " << radius << '\n';
      _mutex.unlock();
    }
  } else {
    const_IWSubstring fromdb(reinterpret_cast<const char*>(zdata.get_data()),
                             zdata.get_size());

    if (!_parse_database_record(fromdb, dbkey, radius, count, example)) {
      cerr << "Invalid database contents, ignored\n";
      return 0;
    }
    //  cerr << "Example is '" << example << "'\n";
  }

  if (_hash_size <
      static_cast<int>(
          max_hash_size))  // slightly dangerous access to unguarded variable _hash_size
  {
    DBKey* dbkey = reinterpret_cast<DBKey*>(zkey.get_data());
    Count_Radius cr;
    cr._count = count;
    cr._radius = radius;

    _mutex.lock();
    _hash[*dbkey] = cr;
    _hash_size++;
    _mutex.unlock();
  }

  return 1;
}

int
SP_Database::check_exists(Dbt* zkey)
{
  return 0 == _db->exists(NULL, zkey, 0);
}

int
SP_Database::get(DbTxn* env, Dbt& dkey, Dbt& zdata, u_int32_t flags)
{
  int rc = _db->get(env, &dkey, &zdata, flags);

  if (0 == rc) {
    return 1;
  }

  if (DB_NOTFOUND) {
    return 0;
  }

  _db->err(rc, "Trying to retrieve ");
  cerr.write(reinterpret_cast<const char*>(dkey.get_data()), dkey.get_size());
  cerr << '\n';

  return 0;
}

int
SP_Database::determine_if_examples_present()
{
  Dbc* cursor = nullptr;

  int rc = _db->cursor(NULL, &cursor, 0);
  if (0 != rc) {
    _db->err(rc, "SP_Database::determine_if_examples_present:cannot acquire cursor");
    return 0;
  }

  Dbt zkey, zdata;

  _contains_examples = 0;

  for (int records_checked = 0; 0 == (rc = cursor->get(&zkey, &zdata, DB_NEXT));
       records_checked++) {
    if (records_checked > 100) {
      break;
    }

    //  cerr << records_checked << " got " << zdata.get_size() << " bytes\n";

    if (8 == zdata.get_size()) {  // most common case
      continue;
    }

    if (zdata.get_size() > 8) {
      _contains_examples = 1;
      break;
    }
  }

  cursor->close();

  return _contains_examples;
}

/*
  When doing retrospective studies, it can be interesting to look
  at the database without certain molecules
*/

typedef std::unordered_map<DBKey, int, IWdbkeyHash> Subtract;

static int
preprocess_molecule(Molecule& m)
{
  m.remove_all(1);

  m.reduce_to_largest_fragment();  // always reduce to largest fragment

  // Apr 2023. Even though chirality does not influence the result,
  // there is no reason to remove it. Just causes problems.
  // m.remove_all_chiral_centres();   // do NOT remove chirality.

  if (chemical_standardisation.active()) {
    chemical_standardisation.process(m);
  }

  return 1;
}

class Subtraction_Set
{
 private:
  Subtract _subtract;
  int _molecules_in_subtraction_set;

  std::atomic<int> _subtraction_bits_hit;

  //  private functions

  int
  _transfer_fingerprints_to_subtract(const Set_of_Bits<Bit_Produced>& sob);
  int
  _adjust_count_for_subtraction(const DBKey& dbkey, int& count) const;

 public:
  Subtraction_Set();

  size_t
  nbits() const
  {
    return _subtract.size();
  }

  int
  report(std::ostream&) const;

  int
  build(const Command_Line& cl, const char flag, Fingerprint_Characteristics& rpc);
  int
  build(const char* fname, Fingerprint_Characteristics& fpc);
  int
  build(data_source_and_type<Molecule>& input, Fingerprint_Characteristics& fpc);

  int
  nmolecules() const
  {
    return _molecules_in_subtraction_set;
  }

  int
  active() const
  {
    return _molecules_in_subtraction_set;
  }

  int
  adjust_count_for_subtraction(const DBKey& dbkey, int& count);

  int
  adjust_count_for_subtraction_threaded(
      const DBKey& dbkey, int& count);  // does not adjust _subtraction_bits_hit
};

Subtraction_Set::Subtraction_Set()
{
  _molecules_in_subtraction_set = 0;

  _subtraction_bits_hit = 0;

  return;
}

int
Subtraction_Set::report(std::ostream& os) const
{
  os << "Subtraction_Set::report:contains " << _subtract.size() << " bits, "
     << _subtraction_bits_hit << " adjustments made\n";

  return 1;
}

int
Subtraction_Set::build(const Command_Line& cl, const char flag,
                       Fingerprint_Characteristics& fpc)
{
  for (int i = 0; i < cl.option_count(flag); ++i) {
    const char* s = cl.option_value(flag, i);

    if (!build(s, fpc)) {
      cerr << "Subtraction_Set::build:cannot build from '" << s << "'\n";
      return 0;
    }
  }

  return 1;
}

int
Subtraction_Set::build(data_source_and_type<Molecule>& input,
                       Fingerprint_Characteristics& fpc)
{
  Molecule* m;

  while (nullptr != (m = input.next_molecule())) {
    _molecules_in_subtraction_set++;

    preprocess_molecule(*m);

    std::unique_ptr<Molecule> free_m(m);

    Set_of_Bits<Bit_Produced> sob;

    compute_fingerprints(*m, fpc, sob);

    _transfer_fingerprints_to_subtract(sob);
  }

  return _subtract.size();
}

int
Subtraction_Set::build(const char* fname, Fingerprint_Characteristics& fpc)
{
  data_source_and_type<Molecule> input(FILE_TYPE_SMI, fname);

  if (!input.good()) {
    cerr << "build_subtraction_set:cannot open '" << fname << "'\n";
    return 0;
  }

  return build(input, fpc);
}

int
Subtraction_Set::_transfer_fingerprints_to_subtract(const Set_of_Bits<Bit_Produced>& sob)
{
  for (auto i : sob) {
    const auto& k = i.first;

    //  unordered_map<DBKey, int, IWdbkeyHash>::const_iterator f = sub.find(k);
    const auto f = _subtract.find(k);

    //  cerr << "Loaded subtraction for " << k._bit << '\n';

    if (f == _subtract.end()) {
      _subtract[k] = 1;
    } else {
      _subtract[k]++;
    }
  }

  return 1;
}

int
Subtraction_Set::_adjust_count_for_subtraction(const DBKey& dbkey, int& count) const
{
  Subtract::const_iterator f = _subtract.find(dbkey);

  if (f == _subtract.end()) {
    return 0;
  }

  int s = (*f).second;

  if (count >= s) {
    count = count - s;
  } else {
    count = 0;
  }

  return 1;
}

int
Subtraction_Set::adjust_count_for_subtraction_threaded(const DBKey& dbkey, int& count)
{
  return _adjust_count_for_subtraction(dbkey, count);
}

int
Subtraction_Set::adjust_count_for_subtraction(const DBKey& dbkey, int& count)
{
  const auto rc = _adjust_count_for_subtraction(dbkey, count);
  if (rc) {
    _subtraction_bits_hit++;
  }

  return rc;
}

static Subtraction_Set subtract;

class Count_Example
{
 private:
  const int _number_examples;

  const int _radius;

  IWString _first_example_smiles;
  IWString _first_example_name;

 public:
  //  Count_Example(Molecule &, atom_number_t centre_atom, int r);
  Count_Example(const IWString&, int r, int c);

  int
  radius() const
  {
    return _radius;
  }

  void
  set_first_example_smiles(const const_IWSubstring& s)
  {
    _first_example_smiles = s;
  }

  int
  number_examples() const
  {
    return _number_examples;
  }

  //  const IWString & first_example() const {return _first_example;}

  int
  do_output(IWString_and_File_Descriptor&) const;
};

Count_Example::Count_Example(const IWString& s, int r, int c)
    : _number_examples(c), _radius(r)
{
  if (s.nwords() < 2) {
    cerr << "Count_Example::Count_Example:invalid db contents '" << s << "'\n";
    return;
  }

  int i = 0;

  s.nextword(_first_example_smiles, i);
  s.nextword(_first_example_name, i);

  return;
}

int
Count_Example::do_output(IWString_and_File_Descriptor& output) const
{
  if (0 == _first_example_smiles.length()) {
    return 1;
  }

  output << _first_example_smiles << ' ';

  output << _first_example_name << ' ';

  if (_radius >= 0) {
    output << _radius << ' ';
  }

  output << _number_examples << " EX\n";

  return 1;
}

static void
usage(int rc)
{
// clang-format off
#if defined(GIT_HASH) && defined(TODAY)
  cerr << __FILE__ << " compiled " << TODAY << " git hash " << GIT_HASH << '\n';
#else
  cerr << __FILE__ << " compiled " << __DATE__ << " " << __TIME__ << '\n';
#endif
  // clang-format on
  // clang-format off
  cerr << DB_VERSION_STRING << '\n';
  cerr << "Compute the Extended Connectivity fingerprints for molecules\n";
  cerr << "  -r <len>       min shell radius\n";
  cerr << "  -R <length>    mas shell radius (default is whatever is in DB)\n";
  cerr << "  -l             only check bits at the maximum radius\n";
  cerr << "  -d <dbname>    database(s) to use\n";
  cerr << "  -w <...>       output desired\n";
  cerr << "    -w score       smiles and score (log10 of rarest outer shell bit)\n";
  cerr << "    -w PSD         write per shell data on examples found\n";
  cerr << "    -w OSO         only write per shell data for the outer shell only\n";
  cerr << "    -w iso         write isotopically labelled parent molecule\n";
  cerr << "    -w examples    write examples of each bit (if available)\n";
  cerr << "  -u E<n>        discard any molecule with fewer than <n> examples in the outer shell\n";
  cerr << "  -u <x>         discard any molecule with score lower than <x>, need to your log10 tables\n";
  cerr << "       log10 values     1 0.1*";

  for (int i = 2; i < 10; ++i)
  {
    cerr << "  " << i << ' ' << std::setprecision(3) << static_cast<float>(log10(i));
  }
  cerr << '\n';
  cerr << "  -U <fname>     stream for molecules rejected by -u option\n";
  cerr << "  -S <fname>     subtract bits produced by molecules in <fname>\n";
  cerr << "  -I             place an isotope on the rarest atom(s)\n";
  cerr << "  -M ...         miscellaneous options, enter '-M help' for info\n";
//cerr << "  -z <number>    only count bits with counts >= <number> examples\n";
  cerr << "  -n <n>         if examples in databases, write the first <n>. Use 'all' for all\n";
//cerr << "  -Y ...         file with human readable scores/classifications - enter -Y help for info\n";
  cerr << "  -t <number>    report progress every <number> molecules processed\n";
  cerr << "  -i <type>      input type\n";
  cerr << "  -g ...         chemical standardisation options\n";
  cerr << "  -E ...         standard element options\n";
  cerr << "  -v             verbose output\n";
  // clang-format on

  exit(rc);
}

/*
  Information about a bit.
  During lookups we will associate a bit with some information
  looked up in the database
*/

template <typename I>
class Bit_Produced_CE : public Bit_Produced
{
 private:
  //  This will get populated when we do the lookup

  const I* _fromdb;

 public:
  Bit_Produced_CE(unsigned int, atom_number_t, unsigned int, unsigned int);

  void
  extra() {
    _count++;
  }

  void set_fromdb(const I* s)
  {
    _fromdb = s;
  }

  const I* fromdb() const
  {
    return _fromdb;
  }
};

template <typename I>
Bit_Produced_CE<I>::Bit_Produced_CE(unsigned int b, atom_number_t c, unsigned int cat,
                                    unsigned int r)
    : Bit_Produced(b, c, cat, r)
{
  _fromdb = nullptr;

  return;
}

class Set_of_Databases
{
 private:
  int _n;
  SP_Database* _db;
  DbEnv _dbenv;

  int _user_wants_example_structures;

  unsigned char _userdata[512];  // user memory for retrievals

  //  private functions

  int
  _determine_if_examples_present();

 public:
  Set_of_Databases();
  ~Set_of_Databases();

  int number_database() const
  {
    return _n;
  }

  int debug_print(std::ostream& output) const;

  int open_logfile(const char* stem);

  int build(Command_Line& cl, char flag_env, char flag_db, const int verbose);
  int
  build(const Command_Line& cl, const char flag_db, const int verbose, DbEnv* envptr);

  int report(std::ostream&) const;

  void set_user_wants_example_structures(int s)
  {
    _user_wants_example_structures = s;
  }

  int user_wants_example_structures() const
  {
    return _user_wants_example_structures;
  }

  int determine_atom_typing_in_use(int& iwecfp_atom_type);
  int determine_max_search_radius(int& min_radius);

  int slurp_to_cache(const int s);

  int lookup_bit(const DBKey& dbkey, int& count, IWString& example_structure);
  int lookup_bit(const DBKey& dbkey, resizable_array_p<Count_Example>& ce);
  int lookup_bit_threaded(const DBKey& dbkey);
};

Set_of_Databases::Set_of_Databases() : _dbenv(0u)
{
  _n = 0;
  _db = nullptr;

  _user_wants_example_structures = 1;

  return;
}

Set_of_Databases::~Set_of_Databases()
{
  if (nullptr != _db) {
    delete[] _db;
  }

  return;
}

int
Set_of_Databases::debug_print(std::ostream& output) const
{
  output << "Set_of_Databases::debug_print:set contains " << _n << " databases\n";
  cerr << " _user_wants_example_structures " << _user_wants_example_structures << '\n';
  for (int i = 0; i < _n; ++i) {
    _db[i].debug_print(output);
  }

  return 1;
}

int
Set_of_Databases::report(std::ostream& os) const
{
  os << "Report on " << _n << " databases\n";

  for (int i = 0; i < _n; ++i) {
    _db[i].report(os);
  }

  return 1;
}

int
Set_of_Databases::open_logfile(const char* stem)
{
  IWString s(stem);

  for (int i = 0; i < _n; ++i) {
    IWString fname(stem);
    fname << '.' << i << ".log";
    if (!_db[i].open_logfile(fname.null_terminated_chars())) {
      cerr << "Set_of_Databases::open_logfile:cannot set logfile '" << fname << "'\n";
      return 0;
    }
  }

  return _n;
}

int
Set_of_Databases::build(Command_Line& cl, char flag_env, char flag_db, const int verbose)
{
  if (!cl.option_present(flag_env)) {
    return build(cl, flag_db, verbose, nullptr);
  }

  const char* e = cl.option_value(flag_env);

  u_int32_t env_flags = DB_CREATE | DB_INIT_MPOOL;

  int rc = _dbenv.open(e, env_flags, 0);

  if (0 != rc) {
    cerr << "Set_of_Databases::build:cannot initialise DB environment '" << e << "'\n";
    return 0;
  }

  if (verbose) {
    cerr << "Using database environment '" << e << "'\n";
  }

  return build(cl, flag_db, verbose, &_dbenv);
}

int
Set_of_Databases::build(const Command_Line& cl, const char flag_db, const int verbose,
                        DbEnv* envptr)
{
  _n = cl.option_count(flag_db);

  if (0 == _n) {
    return 0;
  }

  _db = new SP_Database[_n];

  for (int i = 0; i < _n; ++i) {
    const char* fname = cl.option_value(flag_db, i);

    if (verbose) {
      cerr << "Opening database '" << fname << "'" << '\n';
    }

    if (nullptr != envptr) {
      _db[i].set_env(envptr);
    }

    if (!_db[i].open(fname, 0 /* no threading */)) {
      cerr << "Set_of_Databases::build:cannot open '" << fname << "'\n";
      return 0;
    }
  }

  if (verbose) {
    cerr << "Set_of_Databases::build:opened " << _n << " databases\n";
  }

  if (_user_wants_example_structures) {
    _determine_if_examples_present();
  }

  return _n;
}

int
Set_of_Databases::slurp_to_cache(int min_examples)
{
  for (int i = 0; i < _n; i++) {
    if (!_db[i].slurp_to_cache(min_examples)) {
      cerr << "Set_of_Databases::slurp_to_cache:cannot slurp database " << i << " for "
           << min_examples << " examples\n";
    }
  }

  return _n;
}

int
Set_of_Databases::_determine_if_examples_present()
{
  for (int i = 0; i < _n; ++i) {
    _db[i].determine_if_examples_present();

    if (!_db[i].contains_example_structures()) {
      _user_wants_example_structures = 0;
    }
  }

  // cerr <<
  // "Set_of_Databases::_determine_if_examples_present:_user_wants_example_structures " <<
  // _user_wants_example_structures << '\n';

  return 1;
}

// #define DEBUG_BIT_LOOKUP

int
Set_of_Databases::lookup_bit(const DBKey& dbkey, int& count, IWString& example_structure)
{
#ifdef DEBUG_BIT_LOOKUP
  cerr << "Set_of_Databases::lookup_bit:looking for bit " << dbkey << " across " << _n
       << " databases\n";
#endif

  int nexamples = 0;
  example_structure.resize_keep_storage(0);

  Dbt zkey((void*)(&dbkey), sizeof(dbkey));  // loss of const OK

  IWString s;  // scope here for efficiency
  for (int i = 0; i < _n; i++) {
    int radius;

    if (!_db[i].do_lookup(zkey, dbkey, radius, count, s)) {
      //    cerr << "Did not find bit " << dbkey._bit << " (radius " <<
      //    static_cast<int>(dbkey._radius) << ") in database " << i << '\n';
      continue;
    }

    if (radius != dbkey._radius) {  // collision
      continue;
    }

#ifdef DEBUG_BIT_LOOKUP
    cerr << "Found bit " << dbkey._bit << " (radius " << radius << ") in database " << i
         << ", count " << count << " example '" << s << "'\n";
#endif

    if (subtract.active()) {
      subtract.adjust_count_for_subtraction(dbkey, count);
      if (0 == count) {
        continue;
      }
    }

    nexamples += count;

    if (_user_wants_example_structures && 0 == example_structure.length()) {
      example_structure = s;
    }
  }

  return nexamples;
}

int
Set_of_Databases::lookup_bit_threaded(const DBKey& dbkey)
{
  if (1 == _n) {  // no need for multi threaded execution
    int notused1;
    IWString notused2;
    return lookup_bit(dbkey, notused1, notused2);
  }

  int nexamples = 0;

  for (int i = 0; i < _n; i++) {
    int radius, count;
    IWString s;

    DBKey tmp(dbkey);
    // loss of const OK. Each thread needs its own key
    Dbt zkey((void*)(&tmp), sizeof(tmp));
    assert(tmp._bit == dbkey._bit);

    if (!_db[i].do_lookup(zkey, dbkey, radius, count, s)) {
      continue;
    }

    if (radius != dbkey._radius) {  // collision
      continue;
    }

#ifdef DEBUG_BIT_LOOKUP
    cerr << "Found bit " << dbkey._bit << " (radius " << radius << ") in database " << i
         << ", count " << count << '\n';
#endif

    if (subtract.active()) {
      subtract.adjust_count_for_subtraction_threaded(dbkey, count);  // count may be zero
    }

    nexamples += count;
  }

  return nexamples;
}

int
Set_of_Databases::lookup_bit(const DBKey& dbkey, resizable_array_p<Count_Example>& ce)
{
  int count;
  IWString zexample;
  const auto rc = lookup_bit(dbkey, count, zexample);

  if (0 == rc) {
    return 0;
  }

  ce.add(new Count_Example(zexample, dbkey._radius, count));

  return rc;
}

int
Set_of_Databases::determine_atom_typing_in_use(int& iwecfp_atom_type)
{
  Dbt dkey((void*)(ATYPE_KEY), ::strlen(ATYPE_KEY));
  Dbt d;

  char buffer[32];
  d.set_data(buffer);
  d.set_ulen(sizeof(buffer));
  d.set_flags(DB_DBT_USERMEM);

  IWString string_atype;

  for (int i = 0; i < _n; i++) {
    if (!_db[i].get(NULL, dkey, d, 0)) {
      cerr << "Database " << i << " lacks atom type key '" << ATYPE_KEY << "'\n";
      return 0;
    }

    const_IWSubstring tmp(reinterpret_cast<const char*>(d.get_data()), d.get_size());

    //  cerr << "type '" << tmp << "' fetched\n";

    if (0 == i) {
      string_atype = tmp;
    } else if (string_atype == tmp) {  // great, consistent
      ;
    } else {
      cerr << "INconsistent atom types in use, stored " << tmp << "', using '"
           << string_atype << "', cannot continue\n";
      return 0;
    }
  }

  iwecfp_atom_type = determine_atom_type(string_atype);

  if (0 == iwecfp_atom_type) {
    cerr << "INvalid atom type stored in database\n";
    return 0;
  }

  if (verbose) {
    cerr << "Atom type '" << string_atype << "', numeric " << iwecfp_atom_type << '\n';
  }

  return 1;
}

/*
  The max search radius will be the shortest radius stored in any of our databases
*/

int
Set_of_Databases::determine_max_search_radius(int& min_radius)
{
  min_radius = 99;

  Dbt dkey((void*)(RADIUS_KEY), ::strlen(RADIUS_KEY));
  Dbt d;

  char buffer[32];
  d.set_data(buffer);
  d.set_ulen(sizeof(buffer));
  d.set_flags(DB_DBT_USERMEM);

  for (int i = 0; i < _n; i++) {
    if (!_db[i].get(NULL, dkey, d, 0)) {
      cerr << "Database " << i << " lacks atom type key '" << RADIUS_KEY << "'\n";
      continue;
    }

    const_IWSubstring tmp(reinterpret_cast<const char*>(d.get_data()), d.get_size());

    //  cerr << "type '" << tmp << "' fetched\n";

    int r;
    if (!tmp.numeric_value(r) || r < 1) {
      cerr << "Set_of_Databases::determine_max_radius:invalid '" << RADIUS_KEY
           << "' value '" << tmp << "', ignored\n";
      continue;
    }

    if (r < min_radius) {
      min_radius = r;
    }
  }

  if (verbose) {
    cerr << "Set_of_Databases::determine_max_radius:across " << _n
         << " databases, min radius " << min_radius << '\n';
  }

  return 1;
}

class Count_Example_Sorter
{
 private:
 public:
  int
  operator()(const Count_Example*, const Count_Example*) const;
};

int
Count_Example_Sorter::operator()(const Count_Example* ce1, const Count_Example* ce2) const
{
  int e1 = ce1->number_examples();
  int e2 = ce2->number_examples();

  if (e1 < e2) {
    return -1;
  } else if (e1 > e2) {
    return 1;
  } else {
    return 0;
  }
}

template <typename I>
class Bit_Produced_Comparator
{
 private:
 public:
  int
  operator()(const Bit_Produced_CE<I>*, const Bit_Produced_CE<I>*) const;
};

template <typename I>
int
Bit_Produced_Comparator<I>::operator()(const Bit_Produced_CE<I>* bp1,
                                       const Bit_Produced_CE<I>* bp2) const
{
  const I* ce1 = bp1->fromdb();
  const I* ce2 = bp2->fromdb();

  if (nullptr == ce1) {
    if (nullptr == ce2) {
      return 0;
    }
    return -1;
  } else if (nullptr == ce2) {
    return 1;
  }

  if (ce1->number_examples() < ce2->number_examples()) {
    return -1;
  } else if (ce1->number_examples() > ce2->number_examples()) {
    return 1;
  }

  return 0;
}

static Bit_Produced_Comparator<Count_Example> bpc;

class Lookup_Results
{
 private:
  int _nbits;
  Accumulator_Int<int> _found;

 public:
  Lookup_Results();

  //  void increment_nbits () { _nbits++;}

  int
  nbits() const
  {
    return _nbits;
  }

  void
  reset();

  void
  extra(int c);

  int
  n() const
  {
    return _found.n();
  }

  template <typename O>
  int
  report(O&) const;

  int
  bits_missing() const
  {
    return _nbits - _found.n();
  }

  int
  min_examples() const
  {
    return _found.minval();
  }
};

Lookup_Results::Lookup_Results()
{
  _nbits = 0;

  return;
}

void
Lookup_Results::reset()
{
  _nbits = 0;

  _found.reset();

  return;
}

template <typename O>
int
Lookup_Results::report(O& output) const
{
  output << ' ' << _nbits;

  if (0 == _found.n()) {
    output << " 0 " << _nbits << " 0.0 0.0";
    return 1;
  }

  output << ' ' << _found.n() << ' ' << (_nbits - _found.n());
  output << ' ' << _found.minval() << ' ';

  if (_found.n() > 1) {
    output << static_cast<float>(_found.average());
  } else {
    output << static_cast<float>(_found.minval());
  }

  return 1;
}

void
Lookup_Results::extra(int c)
{
  _nbits++;

  if (c > 0) {
    _found.extra(c);
  }

  return;
}

static int
do_check_monotonicity_bits_found(const IWString& mname, Lookup_Results* lkrs,
                                 const int min_shell_radius, const int max_shell_radius)
{
  int rc = 1;

  for (auto r = min_shell_radius + 1; r <= max_shell_radius; ++r) {
    if (lkrs[r - 1].bits_missing() > lkrs[r].bits_missing()) {
      cerr << "Non monotonic bits missing at radii " << (r - 1) << " and " << r
           << " missing: " << lkrs[r - 1].bits_missing() << " and "
           << lkrs[r].bits_missing() << '\n';
      rc = 0;
    }
    if (lkrs[r - 1].min_examples() < lkrs[r].min_examples()) {
      cerr << "Non monotonic min examples at radii " << (r - 1) << " and " << r
           << " missing: " << lkrs[r - 1].min_examples() << " and "
           << lkrs[r].min_examples() << '\n';
      rc = 0;
    }
  }

  return rc;
}

template <typename T>
int
write_smiles_and_id(Molecule& m, const int radius, const Set_of_Atoms& rarest_atom,
                    T& output)
{
  // cerr << "write_smiles_and_id:rarest_atom " << rarest_atom << '\n';
  for (int i = 0; i < rarest_atom.number_elements(); ++i) {
    const auto j = rarest_atom[i];

    m.set_isotope(j, radius);
  }

  output << m.smiles() << ' ' << m.name();

  return 1;
}

template <typename T>
int
do_write_per_radius_data(const Lookup_Results* lkrs,
                         const Fingerprint_Characteristics& fpc, T& output)
{
  for (int i = fpc.min_shell_radius(); i <= fpc.max_shell_radius(); i++) {
    output << descriptor_file_output_separator << i << descriptor_file_output_separator;

    if (lkrs[i].bits_missing()) {
      if (show_number_bits_missing_for_missing_bits) {
        output << lkrs[i].bits_missing() << '*';
      } else {
        output << '0';
      }
    } else {
      output << lkrs[i].min_examples();
    }
  }

  return 1;
}

static double
do_log10_outer_shell_score(const Lookup_Results* lkrs, const int max_shell_radius)
{
  const Lookup_Results& l = lkrs[max_shell_radius];

  // cerr << "Max radius " << max_shell_radius << " missing " << l.bits_missing() << " min
  // " << l.min_examples() << '\n';

  if (l.bits_missing())  // figure out first shell with a missing bit
  {
    for (int i = 0; i <= max_shell_radius; ++i) {
      if (0 == lkrs[i].bits_missing()) {
        continue;
      }
      // radius 0 -> -4.0 score, radius 3 -> -1.0 score
      return static_cast<double>(-4 + i);
    }
    //  return -1.0 / static_cast<double>(max_shell_radius);
  }

  if (l.min_examples() <= 0) {  // very small molecule
    return -1.0;
  }

  return mylog10(l.min_examples());
}

static int
write_smiles_with_isotope(Molecule& m, atom_number_t centre_atom, int radius,
                          IWString_and_File_Descriptor& output)
{
  if (create_descriptor_file) {
    output << m.name();
    return 1;
  }

  // cerr << "write_smiles_with_isotope atom " << centre_atom << '\n';
  m.set_isotope(centre_atom, radius);
  output << m.smiles() << ' ' << m.name() << '\n';
  m.set_isotope(centre_atom, 0);

  return 1;
}

/*
  Isotopocally label the most difficult atoms
*/

template <typename I>
int
do_isotopically_label_most_difficult_atoms(Molecule& m,
                                           const resizable_array<Bit_Produced_CE<I>*>& bp,
                                           int n, IWString_and_File_Descriptor& output)
{
  cerr << "do_isotopically_label_most_difficult_atoms, n = " << n << '\n';
  const auto* bpi = bp[0];  // first database only

  const I* ce = bpi->fromdb();

  int lowest_count = ce->number_examples();

  // int nprocess = n;

  for (int i = 1; i < bp.number_elements(); i++) {
    int nex = ce->number_examples();

    if (nex < lowest_count) {
      lowest_count = nex;
    }
  }

  // int nset = n;

  for (int i = 0; i < n; i++) {
    atom_number_t a = bp[i]->centre_atom();

    m.set_isotope(a, n - i);
  }

  output << m.smiles() << ' ' << m.name();

  for (int i = 0; i < n; i++) {
    atom_number_t a = bp[i]->centre_atom();

    m.set_isotope(a, 0);
  }

  return 1;
}

/*
  Object that does most of the work
*/

class Lookup_Calculation_Results
{
 private:
  int _min_shell_radius;
  int _max_shell_radius;

  Lookup_Results* _lkrs;

  int* _min_each_shell;

  Set_of_Atoms* _rarest_atom;

  Set_of_Bits<Bit_Produced> _sob;

  double _score;

  int _include_nbits_in_normal_output;

  //  Something useful for debugging

  int* _per_atom_counts;

  //  private functions

  template <typename T>
  int
  _do_write_per_radius_data(T& output) const;
  template <typename T>
  int
  _write_smiles_and_id(Molecule& m, T& output) const;
  void
  _adjust_per_shell_arrays(const int nexamples, const int r, const atom_number_t a);

 public:
  Lookup_Calculation_Results();
  ~Lookup_Calculation_Results();

  int
  initialise(const Fingerprint_Characteristics& fpc);

  void
  set_include_nbits_in_normal_output(int s)
  {
    _include_nbits_in_normal_output = s;
  }

  Lookup_Results*
  lookup_results_array()
  {
    return _lkrs;
  }

  int
  do_lookups_calculate_score(Molecule& m, Fingerprint_Characteristics& rpc,
                             Set_of_Databases& sodb);

  double
  score() const
  {
    return _score;
  }

  template <typename T>
  int
  normal_output(Molecule& m, T& output) const;

  int
  handle_failed_molecule(Molecule& m, SF_Results& res) const;

  template <typename T>
  int
  handle_failed_molecule(Molecule& m, T& stream_for_too_hard) const;
};

Lookup_Calculation_Results::Lookup_Calculation_Results()
{
  _max_shell_radius = 0;
  _min_shell_radius = 0;

  _lkrs = nullptr;
  _min_each_shell = nullptr;
  _rarest_atom = nullptr;

  _score = -1.0;

  _include_nbits_in_normal_output = 0;

  _per_atom_counts = nullptr;

  return;
}

Lookup_Calculation_Results::~Lookup_Calculation_Results()
{
  if (nullptr != _lkrs) {
    delete[] _lkrs;
    delete[] _min_each_shell;
    delete[] _rarest_atom;
  }

  if (nullptr != _per_atom_counts) {
    delete[] _per_atom_counts;
  }

  return;
}

int
Lookup_Calculation_Results::initialise(const Fingerprint_Characteristics& fpc)
{
  assert(0 == _min_shell_radius);
  assert(0 == _max_shell_radius);

  _max_shell_radius = fpc.max_shell_radius();
  _min_shell_radius = fpc.min_shell_radius();

  _lkrs = new Lookup_Results[_max_shell_radius + 1];
  _min_each_shell = new int[_max_shell_radius + 1];
  _rarest_atom = new Set_of_Atoms[_max_shell_radius + 1];

  return 1;
}

// #define DEBUG_DO_LOOKUP_NO_EXAMPLES

int
Lookup_Calculation_Results::do_lookups_calculate_score(Molecule& m,
                                                       Fingerprint_Characteristics& fpc,
                                                       Set_of_Databases& sodb)
{
  set_vector(_min_each_shell, _max_shell_radius + 1, std::numeric_limits<int>::max());

  for (int i = 0; i <= _max_shell_radius; ++i) {
    _rarest_atom[i].resize_keep_storage(0);
    _lkrs[i].reset();
  }

  const int matoms = m.natoms();

  if (per_atom_counts) {
    _per_atom_counts = new_int(matoms * (_max_shell_radius + 1));
  }

  _sob.clear();
  compute_fingerprints(m, fpc, _sob);

  int max_radius = 0;

  int nbits = 0;
  for (auto i : _sob) {
    const auto& k = i.first;

    const auto r = k._radius;

    if (r > max_radius) {
      max_radius = r;
    }

    //  cerr << "Processing bit at radius " << static_cast<int>(r) << '\n';

    nbits++;

#ifdef DEBUG_DO_LOOKUP_NO_EXAMPLES
    cerr << "Looking up bit " << k._bit << ", radius " << static_cast<int>(k._radius)
         << " atom " << i.second->centre_atom() << " "
         << m.smarts_equivalent_for_atom(i.second->centre_atom()) << '\n';
#endif

    const auto nexamples = sodb.lookup_bit_threaded(k);
    //  int notused1;
    //  IWString notused2;
    //  const auto nexamples = sodb.lookup_bit(k, notused1, notused2);

#ifdef DEBUG_DO_LOOKUP_NO_EXAMPLES
    cerr << "  found " << nexamples << " examples\n";
#endif

    _lkrs[r].extra(nexamples);

    if (nullptr != _per_atom_counts) {
      _per_atom_counts[i.second->centre_atom() * (_max_shell_radius + 1) + k._radius] =
          nexamples;
    }

    if (nexamples > _min_each_shell[r]) {
      continue;
    }

    _adjust_per_shell_arrays(nexamples, r, i.second->centre_atom());
  }

  if (check_monotonicity_bits_found) {
    do_check_monotonicity_bits_found(m.name(), _lkrs, fpc.min_shell_radius(),
                                     fpc.max_shell_radius());
  }

  _score = do_log10_outer_shell_score(_lkrs, max_radius);

  return 1;
}

void
Lookup_Calculation_Results::_adjust_per_shell_arrays(const int nexamples, const int r,
                                                     const atom_number_t a)
{
  // cerr << "Lookup_Calculation_Results:_adjust_per_shell_arrays:compare " << nexamples
  // << " with " << _min_each_shell[r] << " radius " << r << '\n';
  if (nexamples > _min_each_shell[r]) {
    return;
  }

  if (nexamples < _min_each_shell[r])  // new lowest value
  {
    _min_each_shell[r] = nexamples;
    if (isotopically_label_most_difficult_atoms) {
      _rarest_atom[r].resize_keep_storage(0);
      _rarest_atom[r].add(a);
    }
  } else if (isotopically_label_most_difficult_atoms) {
    _rarest_atom[r].add(a);
  }

  return;
}

template <typename T>
int
Lookup_Calculation_Results::_write_smiles_and_id(Molecule& m, T& output) const
{
  if (create_descriptor_file) {
    output << m.name();
    return 1;
  }

  if (0 == isotopically_label_most_difficult_atoms) {
    output << m.smiles() << ' ' << m.name();
    return 1;
  }

  for (int i = _max_shell_radius; i >= 0; --i) {
    // cerr << "Lookup_Calculation_Results::_write_smiles_and_id:radius " << i << "
    // _rarest_atom " << _rarest_atom[i].number_elements() << '\n';
    if (_rarest_atom[i].number_elements() > 0) {
      return write_smiles_and_id(m, i, _rarest_atom[i], output);
    }
  }

  output << m.smiles() << ' ' << m.name();

  return 1;
}

template <typename T>
int
Lookup_Calculation_Results::normal_output(Molecule& m, T& output) const
{
  _write_smiles_and_id(m, output);

  if (_include_nbits_in_normal_output) {
    output << descriptor_file_output_separator << _sob.size();
  }

  if (write_per_shell_data) {
    _do_write_per_radius_data(output);
  }

  if (include_score_with_normal_results) {
    output << descriptor_file_output_separator << static_cast<float>(_score);
  }
  output << '\n';

  if (nullptr != _per_atom_counts) {
    const int matoms = m.natoms();

    int ndx = 0;
    for (int i = 0; i < matoms; ++i) {
      output << i << ' ' << m.smarts_equivalent_for_atom(i);

      for (int r = 0; r <= _max_shell_radius; ++r) {
        output << ' ' << _per_atom_counts[ndx];
        ndx++;
      }
      output << '\n';
    }
  }

  return 1;
}

template <typename T>
int
Lookup_Calculation_Results::_do_write_per_radius_data(T& output) const
{
  for (int i = _min_shell_radius; i <= _max_shell_radius; i++) {
    output << descriptor_file_output_separator;

    if (!create_descriptor_file) {
      output << i << descriptor_file_output_separator;
    }

    if (_lkrs[i].bits_missing()) {
      if (show_number_bits_missing_for_missing_bits) {
        output << (-_lkrs[i].bits_missing());
      } else {
        output << '0';
      }
    } else {
      output << _lkrs[i].min_examples();
    }
  }

  return 1;
}

int
Lookup_Calculation_Results::handle_failed_molecule(Molecule& m, SF_Results& res) const
{
  if (!res.accumulate_rejected_molecules()) {
    return 0;
  }

  return handle_failed_molecule(m, res.to_rejected_stream());

  // cerr << "RJ stream now " << res.to_rejected_stream();
}

template <typename T>
int
Lookup_Calculation_Results::handle_failed_molecule(Molecule& m, T& output) const
{
  _write_smiles_and_id(m, output);

  if (write_per_shell_data) {
    _do_write_per_radius_data(output);
  }

  if (include_score_with_normal_results) {
    output << ' ' << static_cast<float>(_score);
  }

  output << '\n';

  return 0;
}

static int
do_lookup_no_examples(Molecule& m, Set_of_Databases& sodb,
                      Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                      IWString_and_File_Descriptor& output)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  const double score = lcr.score();

  if (!score_related.okscore(score)) {
    return lcr.handle_failed_molecule(m, stream_for_too_hard);
  }

  return lcr.normal_output(m, output);
}

/*static int
do_lookup_no_examples (Molecule & m,
                       Set_of_Databases & sodb,
                       Fingerprint_Characteristics & fpc,
                       Lookup_Calculation_Results & lcr,
                       SF_Results & res)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  const double score = lcr.score();

  if (! score_related.okscore(score))
    return lcr.handle_failed_molecule(m, res);

  return lcr.normal_output(m, res.to_stdout());
}*/

// #define DEBUG_DO_LOOKUP_WITH_EXAMPLES

static int
do_lookup_with_examples(Molecule& m, Set_of_Databases& sodb,
                        Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                        IWString_and_File_Descriptor& output)
{
  Lookup_Results* lkrs = lcr.lookup_results_array();
  for (int i = 0; i <= fpc.max_shell_radius(); ++i) {
    lkrs[i].reset();
  }

  // The array of Count_Example objects is so they can be deleted properly
  // The array of Bit_Produced objects is so they can be sorted

  Set_of_Bits<Bit_Produced_CE<Count_Example>> sob;
  compute_fingerprints(m, fpc, sob);

#ifdef DEBUG_DO_LOOKUP_WITH_EXAMPLES
  cerr << "Calculated " << sob.size() << " fingerprints\n";
#endif

  resizable_array_p<Count_Example> ce;
  resizable_array<Bit_Produced_CE<Count_Example>*> bits;

  const auto s = sob.size();

  ce.resize(s);
  bits.resize(s);

  for (auto i : sob) {
    const auto& k = i.first;

    auto* bp = i.second;

    bits.add(bp);

    const int r = bp->radius();
#ifdef DEBUG_DO_LOOKUP_WITH_EXAMPLES
    cerr << "looking up bit " << bp->bit() << " radius " << r << " atom "
         << i.second->centre_atom() << " "
         << m.smarts_equivalent_for_atom(i.second->centre_atom()) << '\n';
#endif

    int nexamples = sodb.lookup_bit(k, ce);

    lkrs[r].extra(nexamples);

    if (0 == nexamples) {
      continue;
    }

#ifdef DEBUG_DO_LOOKUP_WITH_EXAMPLES
    cerr << "Bit " << k._bit << " from atom " << bp->centre_atom() << " rad "
         << bp->radius() << " found " << nexamples << " examples\n";
#endif

    if (nexamples > count_threshold) {
      lkrs[r].extra(nexamples);
      bp->set_fromdb(ce.last_item());
    }
  }

  if (check_monotonicity_bits_found) {
    do_check_monotonicity_bits_found(m.name(), lkrs, fpc.min_shell_radius(),
                                     fpc.max_shell_radius());
  }

  const double score = do_log10_outer_shell_score(lkrs, fpc.max_shell_radius());

  if (!score_related.okscore(score)) {
    return lcr.handle_failed_molecule(m, stream_for_too_hard);
  }

  // sort so missing bits first, then ordered by numer of examples

  if (bits.number_elements() > 1) {
    bits.iwqsort(bpc);
  }

  if (isotopically_label_most_difficult_atoms) {
    do_isotopically_label_most_difficult_atoms(
        m, bits, isotopically_label_most_difficult_atoms, output);
  } else {
    output << m.smiles() << ' ' << m.name() << ' ' << sob.size() << " bits score "
           << static_cast<float>(
                  do_log10_outer_shell_score(lkrs, fpc.max_shell_radius()));
  }

  if (write_per_shell_data) {
    do_write_per_radius_data(lkrs, fpc, output);
  }

  output << '\n';

// Label all the not-found atoms with the lowest isotpe

// #define ECHO_SORTED_LIST
#ifdef ECHO_SORTED_LIST
  for (int i = 0; i < bits.number_elements(); i++) {
    const Bit_Produced_CE<Count_Example>* bp = bits[i];
    cerr << "i = " << i << " nex " << bp->fromdb()->number_examples() << '\n';
  }
#endif

  int istart = 0;
  int istop = bits.number_elements();
  int min_rad_missing = std::numeric_limits<int>::max();

  for (int i = 0; i < istop; i++) {
    const auto* bp = bits[i];

    if (nullptr != bp->fromdb()) {  // got to the bits that were found
      break;
    }

    atom_number_t c = bp->centre_atom();
    int r = bp->radius();

    if (0 == m.isotope(c) || m.isotope(c) > static_cast<isotope_t>(r)) {
      m.set_isotope(c, r);
    }

    if (r < min_rad_missing) {
      min_rad_missing = r;
    }

    istart++;
  }

  if (istart > 0 && write_isotopically_labelled_summary_structure) {
    output << m.smiles() << ' ' << m.name() << ' ' << istart << " MISSING (minrad) "
           << min_rad_missing << '\n';
    m.transform_to_non_isotopic_form();
  }

  if (0 == write_example_structures) {
    return 1;
  }

  istop = istart + write_example_structures;
  if (istop > bits.number_elements()) {
    istop = bits.number_elements();
  }

  if (verbose > 2) {
    cerr << "Writing " << (istop - istart) << " examples\n";
  }

  for (int i = istart; i < istop; i++) {
    const auto* bp = bits[i];

    write_smiles_with_isotope(m, bp->centre_atom(), bp->radius() + 1, output);

    const auto* c = bp->fromdb();

    if (nullptr == c) {  // should not happen
      output << "*\n";
    } else {
      c->do_output(output);
    }
  }

  output.write_if_buffer_holds_more_than(4096);

  if (verbose > 1) {
    output.flush();
  }

  return ce.number_elements();
}

// static Lookup_Results * lkrs = nullptr;

static const Element* aromatic_carbon = nullptr;
static const Element* aliphatic_carbon = nullptr;

static const Element* aromatic_nitrogen = nullptr;
static const Element* aliphatic_nitrogen = nullptr;

static const Element* aliphatic_oxygen = nullptr;

static const Element* fluorine = nullptr;
static const Element* chlorine = nullptr;
static const Element* bromine = nullptr;
static const Element* iodine = nullptr;

static const Element* sulphur = nullptr;

static resizable_array<const Element*> elements_to_add;

static void
initialise_substituent_elements()
{
  assert(nullptr == aromatic_carbon);

  aromatic_carbon = create_element_with_symbol("c");
  const_cast<Element*>(aromatic_carbon)->set_permanent_aromatic(1);
  aliphatic_carbon = get_element_from_atomic_number(6);

  aromatic_nitrogen = create_element_with_symbol("n");
  const_cast<Element*>(aromatic_nitrogen)->set_permanent_aromatic(1);
  aliphatic_nitrogen = get_element_from_atomic_number(7);

  aliphatic_oxygen = get_element_from_atomic_number(8);
  fluorine = get_element_from_atomic_number(9);
  chlorine = get_element_from_atomic_number(17);
  bromine = get_element_from_atomic_number(35);
  iodine = get_element_from_atomic_number(53);
  sulphur = get_element_from_atomic_number(16);

  elements_to_add.add(aromatic_carbon);
  elements_to_add.add(aliphatic_carbon);
  elements_to_add.add(aromatic_nitrogen);
  elements_to_add.add(aliphatic_nitrogen);
  elements_to_add.add(aliphatic_oxygen);
  elements_to_add.add(fluorine);
  elements_to_add.add(chlorine);
  elements_to_add.add(bromine);
  elements_to_add.add(iodine);
  elements_to_add.add(sulphur);

  return;
}

template <typename T>
double
determine_difficulty_score(Molecule& m, Set_of_Databases& sodb,
                           Fingerprint_Characteristics& fpc, Set_of_Bits<T>& sob,
                           Lookup_Calculation_Results& lcr)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  return lcr.score();
}

/*
  The input molecule is a subset of a larger molecule
*/

static int
analyse_ring_system(Molecule& m, int atoms_to_check, Set_of_Databases& sodb,
                    Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                    IWString_and_File_Descriptor& output)
{
  int n = elements_to_add.number_elements();

  resizable_array<double> difficulty_score;

  Set_of_Bits<Bit_Produced> sob;

  const auto base_difficulty = determine_difficulty_score(m, sodb, fpc, sob, lcr);

  difficulty_score.add(base_difficulty);

  for (int i = 0; i < atoms_to_check; i++) {
    if (0 == m.hcount(i)) {
      continue;
    }

    for (int j = 0; j < n; j++) {
      m.add(elements_to_add[j]);
      m.add_bond(i, atoms_to_check, SINGLE_BOND);

      int d = determine_difficulty_score(m, sodb, fpc, sob, lcr);

      difficulty_score.add(d);

      output << m.smiles() << " S:" << m.name() << ' ' << d << '\n';

      m.resize(atoms_to_check);
    }
  }

  return 1;
}

static void
add_connected_atoms(const Molecule& m, const int* in_subset, const int* xref,
                    Molecule& subset)
{
  int matoms = m.natoms();

  for (int i = 0; i < matoms; i++) {
    if (0 == in_subset[i]) {
      continue;
    }

    const Atom* ai = m.atomi(i);

    int acon = ai->ncon();

    if (2 == acon) {
      continue;
    }

    for (int j = 0; j < acon; j++) {
      const Bond* b = ai->item(j);

      atom_number_t k = b->other(i);

      if (in_subset[k]) {
        continue;
      }

      const Element* ek = m.elementi(k);

      subset.add(ek);
      subset.add_bond(subset.natoms() - 1, xref[k], b->btype());
    }
  }

  return;
}

static int
ring_system_desirability(Molecule& m, Set_of_Databases& sodb,
                         Fingerprint_Characteristics& fpc,
                         Lookup_Calculation_Results& lcr,
                         IWString_and_File_Descriptor& output)
{
  int matoms = m.natoms();
  int* ring_membership = new int[matoms];
  std::unique_ptr<int[]> free_ring_membership(ring_membership);
  int* tmp = new int[matoms];
  std::unique_ptr<int[]> free_tmp(tmp);
  int* xref = new int[matoms];
  std::unique_ptr<int[]> free_xref(xref);

  int number_ring_systems =
      m.label_atoms_by_ring_system_including_spiro_fused(ring_membership);

  for (int i = 1; i <= number_ring_systems; i++) {
    int other_than_aromatic_carbon = 0;

    for (int j = 0; j < matoms; j++)  // transfer atoms in system to TMP
    {
      if (ring_membership[j] == i) {
        tmp[j] = 1;
        if (6 != m.atomic_number(j)) {
          other_than_aromatic_carbon++;
        } else if (!m.is_aromatic(j)) {
          other_than_aromatic_carbon++;
        }
      } else {
        tmp[j] = 0;
      }
    }

    if (0 == other_than_aromatic_carbon) {  // who cares about benzene
      continue;
    }

    Molecule subset;
    m.create_subset(subset, tmp, 1, xref);
    subset.set_name(m.name());

    int atoms_to_check = subset.natoms();

    add_connected_atoms(m, tmp, xref, subset);  // connected atoms don't get checked

    analyse_ring_system(subset, atoms_to_check, sodb, fpc, lcr, output);
  }

  return 1;
}

static int
iwecfp(Molecule& m, Set_of_Databases& sodb, Fingerprint_Characteristics& fpc,
       Lookup_Calculation_Results& lcr, IWString_and_File_Descriptor& output)

{
  m.compute_aromaticity_if_needed();

  // cerr << "Molecule contains " << sob.size() << " bits\n";

  if (doing_ring_system_desirability) {
    ring_system_desirability(m, sodb, fpc, lcr, output);
  } else if (sodb.user_wants_example_structures()) {
    do_lookup_with_examples(m, sodb, fpc, lcr, output);
  } else {
    do_lookup_no_examples(m, sodb, fpc, lcr, output);
  }

  return 1;
}

static int
iwecfp(data_source_and_type<Molecule>& input, Set_of_Databases& sodb,
       Fingerprint_Characteristics& fpc, IWString_and_File_Descriptor& output)
{
  Lookup_Calculation_Results lcr;

  lcr.initialise(fpc);

  Molecule* m;
  while (nullptr != (m = input.next_molecule())) {
    molecules_read++;

    std::unique_ptr<Molecule> free_m(m);

    if (report_progress()) {
      cerr << "Processed " << molecules_read << " molecules\n";
    }

    if (verbose > 1) {
      cerr << molecules_read << " processing '" << m->name() << "'\n";
    }

    if (!preprocess_molecule(*m)) {
      cerr << "Skipping non organic or too large '" << m->name() << "'\n";
      continue;
    }

    if (!iwecfp(*m, sodb, fpc, lcr, output)) {
      cerr << "Fatal error processing '" << m->name() << "'\n";
      return 0;
    }

    if (flush_output_each_molecule) {
      output.flush();
    } else {
      output.write_if_buffer_holds_more_than(1024);
    }
  }

  return 1;
}

static int
iwecfp_single_molecule(Molecule& m, Set_of_Databases& sodb,
                       Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                       SF_Results& res)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  res.reset();

  if (!score_related.okscore(lcr.score())) {
    return lcr.handle_failed_molecule(m, res);
  }

  molecules_written++;

  return lcr.normal_output(m, res.to_stdout());
}

static int
get_next_group_of_molecules(data_source_and_type<Molecule>& input,
                            resizable_array_p<Molecule>& mgrp, const int nget)
{
  mgrp.resize_keep_storage(0);

  int rc = 0;

  Molecule* m;
  while (nullptr != (m = input.next_molecule())) {
    if (!preprocess_molecule(*m)) {
      cerr << "Skipping non organic or too large '" << m->name() << "'\n";
      delete m;
      continue;
    }

    mgrp.add(m);

    rc++;

    if (rc >= nget) {
      return rc;
    }
  }

  return rc;
}

static int
transfer_to_output_streams(const SF_Results* res, const int n,
                           IWString_and_File_Descriptor& output,
                           IWString_and_File_Descriptor& stream_for_too_hard)
{
  for (int i = 0; i < n; ++i) {
    const IWString& s = res[i].to_stdout();
    if (s.length()) {
      output << s;
      output.write_if_buffer_holds_more_than(4096);
      molecules_written++;
    } else if (stream_for_too_hard
                   .active())  // nothing on stdout, is the reject stream open?
    {
      const IWString& r = res[i].to_rejected_stream();
      if (r.length()) {
        stream_for_too_hard << r;
        stream_for_too_hard.write_if_buffer_holds_more_than(32768);
      }
    }
  }

  return 1;
}

/*
  When doing parallel execution, need to hve per-thread instances of everything
*/

static int
iwecfp_chunked(data_source_and_type<Molecule>& input, Set_of_Databases& sodb,
               Fingerprint_Characteristics& fpc, IWString_and_File_Descriptor& output)
{
  // cerr << "Running chunked " << parallel_group_size << '\n';

  SF_Results* res = new SF_Results[parallel_group_size];
  std::unique_ptr<SF_Results[]> free_res(res);
  Lookup_Calculation_Results* lcr = new Lookup_Calculation_Results[parallel_group_size];
  std::unique_ptr<Lookup_Calculation_Results[]> free_lcr(lcr);

  for (int i = 0; i < parallel_group_size; ++i) {
    lcr[i].initialise(fpc);
    if (stream_for_too_hard.active()) {
      res[i].set_accumulate_rejected_molecules(1);
    }
  }

  resizable_array_p<Molecule> m;

  while (get_next_group_of_molecules(input, m, parallel_group_size)) {
    const int n = m.number_elements();

    molecules_read += n;

    if (report_progress()) {
      cerr << "Processed " << molecules_read << " molecules\n";
    }

    for (int i = 0; i < n; ++i) {
      iwecfp_single_molecule(*(m[i]), sodb, fpc, lcr[i], res[i]);
    }

    transfer_to_output_streams(res, n, output, stream_for_too_hard);
  }

  return 1;
}

static int
iwecfp(const char* fname, FileType input_type, Set_of_Databases& sodb,
       Fingerprint_Characteristics& fpc, IWString_and_File_Descriptor& output)
{
  data_source_and_type<Molecule> input(input_type, fname);

  if (!input.ok()) {
    cerr << "Cannot open '" << fname << "'\n";
    return 0;
  }

  if (parallel_group_size > 0) {
    return iwecfp_chunked(input, sodb, fpc, output);
  } else {
    return iwecfp(input, sodb, fpc, output);
  }
}

static void
display_dash_m_options(std::ostream& os)
{
  os << " -M mult       multiplicative bit formation\n";
  os << " -M mb0        display missing bits as '0' rather than number missing\n";
  os << " -M isomd      isotopically label the most difficult atom\n";
  os << " -M isomd=<n>  isotopically label the most difficult atoms\n";
  os << " -M noex       databases do not contain examples, binary count and rad only\n";
  os << " -M dbcache=<n> set database cache size (bytes)\n";
  os << " -M bcache=<n>  set bit hash cache size (bytes)\n";
  os << " -M ckmt        check that the number of bits found decreases with radius\n";
  os << " -M pref        prefetch bits from the database - helps speed\n";

  exit(1);
}

static int
iwecfp(int argc, char** argv)
{
  Command_Line cl(argc, argv, "vE:A:g:i:r:R:ld:e:t:z:w:u:U:H:S:M:n:IL:Y:");

  if (cl.unrecognised_options_encountered()) {
    cerr << "Unrecognised options encountered\n";
    usage(1);
  }

  verbose = cl.option_count('v');

  if (!process_elements(cl)) {
    usage(2);
  }

  if (cl.option_present('g')) {
    if (!chemical_standardisation.construct_from_command_line(cl, verbose > 1, 'g')) {
      cerr << "Cannot initialise chemical standardisation (-g)\n";
      usage(14);
    }
  }

  if (!process_standard_aromaticity_options(cl, verbose)) {
    cerr << "Cannot process aromaticity options (-A)\n";
    usage(5);
  }

  set_global_aromaticity_type(Daylight);

  set_default_iwstring_float_concatenation_precision(3);
  set_default_iwstring_double_concatenation_precision(3);

  if (cl.option_present('I')) {
    write_isotopically_labelled_summary_structure = 1;
    isotopically_label_most_difficult_atoms = 1;

    if (verbose) {
      cerr << "Will write structure with rarest atom(s) isotopically labelled\n";
    }
  }

  if (cl.option_present('n')) {
    const_IWSubstring n = cl.string_value('n');

    if ("all" == n) {
      write_example_structures = std::numeric_limits<int>::max();
    } else if (!n.numeric_value(write_example_structures) ||
               write_example_structures <
                   0)  // zero is OK, means do not write any examples
    {
      cerr << "The number of example structures to write (-n) must be a whole +ve "
              "number\n";
      usage(1);
    } else if (verbose) {
      cerr << "Will write the first " << write_example_structures
           << " example structures\n";
    }
  }

  if (cl.option_present('Y')) {
    IWString y = cl.string_value('Y');

    if ("help" == y) {
      //    display_human_readable_classification_syntax(cerr);
      exit(1);
    }

    if (!human_labels.build(y.null_terminated_chars())) {
      cerr << "Cannot build human readable labels from '" << y << "'\n";
      return 1;
    }
  }

  if (cl.option_present('w')) {
    int i = 0;
    const_IWSubstring w;
    while (cl.value('w', w, i++)) {
      if ("ss" == w || "score" == w || "SCORE" == w) {
        include_score_with_normal_results = 1;
      } else if ("PSD" == w) {
        write_per_shell_data = 1;
        if (verbose) {
          cerr << "Will write Per Shell Data\n";
        }
      } else if ("DSC" == w) {
        if (cl.option_present('I')) {
          cerr << "Writing isotopically labelled smiles and creatign a descriptor file "
                  "are incompatible\n";
          return 1;
        }
        create_descriptor_file = 1;
        if (verbose) {
          cerr << "Output will be a descriptor file\n";
        }
      } else if ("OSO" == w) {
        write_per_shell_data = 1;
        only_write_outer_shell = 1;

        if (verbose) {
          cerr << "Will only write the outer shell info\n";
        }
      } else {
        cerr << "unrecognised -w qualifier '" << w << "'\n";
        usage(5);
      }
    }
  } else {
    include_score_with_normal_results = 1;
  }

  if (!cl.option_present('d')) {
    cerr << "Must specify database(s) via the -d option\n";
    usage(3);
  }

  Set_of_Databases sodb;

  if (!sodb.build(cl, 'e', 'd', verbose)) {
    cerr << "Cannot open database(s) (-d)\n";
    return 2;
  }

  int mr = 0;
  sodb.determine_max_search_radius(mr);

  Fingerprint_Characteristics fpc;

  if (!fpc.build(cl, mr, verbose)) {
    cerr << "Cannot initialise fingerprints\n";
    usage(1);
  }

  if (mr < fpc.max_shell_radius()) {
    cerr << "User specified max radius " << fpc.max_shell_radius()
         << " but longest radius in any DB is " << mr << ", cannot continue\n";
    return 1;
  }

  if (cl.option_present('l')) {
    fpc.set_only_set_bits_for_max_radius_shell();
    if (verbose) {
      cerr << "Only bits for the largest radius will be set\n";
    }
  }

  if (cl.option_present('L')) {
    const char* l = cl.option_value('L');
    sodb.open_logfile(l);
    if (verbose) {
      cerr << "Logfile stem '" << l << "'\n";
    }
  }

  // sodb.debug_print(cerr);

  if (cl.option_present('M')) {
    int i = 0;
    const_IWSubstring m;
    while (cl.value('M', m, i++)) {
      if ("mult" == m) {
        fpc.set_additive(0);

        if (verbose) {
          cerr << "Fingerprints formed with multiplication operations\n";
        }
      } else if ("mb0" == m) {
        show_number_bits_missing_for_missing_bits = 0;
        if (verbose) {
          cerr << "Will show zero count for missing bits\n";
        }
      } else if ("mb1" == m) {
        show_number_bits_missing_for_missing_bits = 1;
        if (verbose) {
          cerr << "Will show asterisk'ed count for missing bits\n";
        }
      } else if ("isomd" == m) {
        isotopically_label_most_difficult_atoms = 1;

        if (verbose) {
          cerr << "Will isotopically label the "
               << isotopically_label_most_difficult_atoms << " most difficult atoms\n";
        }
      } else if (m.starts_with("isomd=")) {
        m.remove_leading_chars(6);
        if (!m.numeric_value(isotopically_label_most_difficult_atoms) ||
            isotopically_label_most_difficult_atoms < 1) {
          cerr << "Invalid value for most difficult atoms '" << m << "\n";
          return 3;
        }
        if (verbose) {
          cerr << "Will isotopically label the "
               << isotopically_label_most_difficult_atoms << " most difficult atoms\n";
        }
      } else if ("noex" == m) {
        sodb.set_user_wants_example_structures(0);
      } else if ("pac" == m) {
        per_atom_counts = 1;
      }
/*      else if ("serial" == m)
      {
        __cilkrts_set_param("nworkers","1");
      }
*/
#ifdef CACHE_SIZE_SETTABLE
      else if (m.starts_with("dbcache=")) {
        m.remove_leading_chars(8);

        if (!m.numeric_value(db_cache_size) || db_cache_size < 1) {
          cerr << "The database cache size must be a reasonable +ve number\n";
          return 3;
        }
      }
#endif
      else if (m.starts_with("bcache")) {
        m.remove_leading_chars(7);

        if (!m.numeric_value(max_hash_size) || max_hash_size < 1) {
          cerr << "The max bit hash size must be a whole +ve number\n";
          return 2;
        }

        if (write_example_structures && cl.option_present('n')) {
          cerr << "Sorry, caching does not work with example databases, see Ian\n";
          return 2;
        }
      } else if (m.starts_with("slurp=")) {
        m.remove_leading_chars(6);
        if (!m.numeric_value(slurp_examples) || slurp_examples < 1) {
          cerr << "The min examples for slurp specification must be a whole +ve number\n";
          return 3;
        }

        if (verbose) {
          cerr << "Will slurp database examples to hash if at least " << slurp_examples
               << " examples\n";
        }
      } else if ("ckmt" == m) {
        check_monotonicity_bits_found = 1;
        if (verbose) {
          cerr << "Will check monotonicity of bits found by radius\n";
        }
      } else if ("flush" == m) {
        flush_output_each_molecule = 1;
        if (verbose) {
          cerr << "output flushed each molecule\n";
        }
      } else if ("help" == m) {
        display_dash_m_options(cerr);
      } else {
        cerr << "Unrecognised -M qualifier '" << m << "'\n";
        display_dash_m_options(cerr);
      }
    }
  }

  if (cl.option_present('m')) {
  }

  if (cl.option_present('t')) {
    if (!report_progress.initialise(cl, 't', verbose)) {
      cerr << "Cannot initialise progress reporting (-p)\n";
      usage(3);
    }
  }

  if (cl.option_present('z')) {
    if (!cl.value('z', count_threshold) || count_threshold < 0) {
      cerr << "The count threshold value (-z) must be a non -ve whole number\n";
      usage(4);
    }

    if (verbose) {
      cerr << "Will count the number of bits with counts <= " << count_threshold << '\n';
    }
  }

  if (!score_related.build(cl, 'u', verbose)) {
    cerr << "Cannot initialise score filtering options (-u and/or -U)\n";
    return 1;
  }

  if (cl.option_present('U')) {
    if (!cl.option_present('u')) {
      cerr << "The rejected molecule option (-U) does not make sense without the -u "
              "option\n";
      usage(1);
    }

    IWString fname = cl.string_value('U');

    if (!fname.ends_with(".smi")) {
      fname << ".smi";
    }

    if (!stream_for_too_hard.open(fname.null_terminated_chars())) {
      cerr << "Cannot open stream for rejected molecules '" << fname << "'\n";
      return 2;
    }

    if (verbose) {
      cerr << "Rejected molecules written to '" << fname << "'\n";
    }
  }

  if (cl.option_present('H')) {
    doing_ring_system_desirability = 1;

    initialise_substituent_elements();

    if (verbose) {
      cerr << "Doing ring system desirability determinations\n";
    }
  }

  FileType input_type = FILE_TYPE_INVALID;

  if (cl.option_present('i')) {
    if (!process_input_type(cl, input_type)) {
      cerr << "Cannot determine input type\n";
      usage(6);
    }
  } else if (1 == cl.number_elements() && 0 == ::strcmp(cl[0], "-")) {
    input_type = FILE_TYPE_SMI;
  } else if (!all_files_recognised_by_suffix(cl)) {
    cerr << "Cannot determine input type(s)\n";
    return 7;
  }

  if (0 == cl.number_elements()) {
    cerr << "Insufficient arguments\n";
    usage(2);
  }

  sodb.determine_atom_typing_in_use(iwecfp_atom_type);

  fpc.set_atype(iwecfp_atom_type);

  if (slurp_examples) {
    sodb.slurp_to_cache(slurp_examples);
  }

  if (cl.option_present('S')) {
    IWString s;
    for (int i = 0; cl.value('S', s, i); ++i) {
      if (!subtract.build(s.null_terminated_chars(), fpc)) {
        cerr << "Cannot read subtraction set from '" << s << "'\n";
        return 3;
      }
    }

    if (verbose) {
      cerr << "Read " << subtract.nbits() << " bits produced by " << subtract.nmolecules()
           << " molecules for subtraction set\n";
    }
  }

  int rc = 0;

  IWString_and_File_Descriptor output(1);

  if (create_descriptor_file) {
    output << "ID" << descriptor_file_output_separator << "nbits";
    if (create_descriptor_file && write_per_shell_data) {
      for (int i = 0; i <= fpc.max_shell_radius(); ++i) {
        output << descriptor_file_output_separator << "Found." << i;
      }
    } else if (write_per_shell_data) {
      for (int i = 0; i <= fpc.max_shell_radius(); ++i) {
        output << descriptor_file_output_separator << "R." << i
               << descriptor_file_output_separator << "Found." << i;
      }
    }
    output << descriptor_file_output_separator << "Score\n";
  }

  set_default_iwstring_float_concatenation_precision(5);

  for (int i = 0; i < cl.number_elements(); i++) {
    if (!iwecfp(cl[i], input_type, sodb, fpc, output)) {
      rc = i + 1;
      break;
    }
  }

  output.flush();

  if (verbose) {
    cerr << "Read " << molecules_read << " molecules\n";

    if (cl.option_present('u')) {
      cerr << "Wrote " << molecules_written << " molecules\n";
    }

    score_related.report(cerr);

    if (subtract.active()) {
      subtract.report(cerr);
    }

    sodb.report(cerr);
  }

  return rc;
}

int
main(int argc, char** argv)
{
  int rc = iwecfp(argc, argv);
  return rc;
}
