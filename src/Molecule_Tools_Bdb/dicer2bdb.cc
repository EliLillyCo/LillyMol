// Convert TFDataRecord's of dicer_data::DicerFragment to BerkeleyDB
// This will typically have been generated by the
// -B fragstatbinproto
// option to dicer.

#include <sys/stat.h>

#include <filesystem>
#include <iostream>
#include <memory>
#include <string>

#include "db_cxx.h"

#include "google/protobuf/io/zero_copy_stream.h"
#include "google/protobuf/io/zero_copy_stream_impl.h"
#include "google/protobuf/text_format.h"

#include "Foundational/cmdline_v2/cmdline_v2.h"
#include "Foundational/data_source/iwstring_data_source.h"
#include "Foundational/data_source/tfdatarecord.h"
#include "Foundational/iwmisc/report_progress.h"

#include "Molecule_Tools/dicer_fragments.pb.h"

namespace dicer2bdb {

using std::cerr;

void 
Usage(int rc) {
// clang-format off
#if defined(GIT_HASH) && defined(TODAY)
  cerr << __FILE__ << " compiled " << TODAY << " git hash " << GIT_HASH << '\n';
#else
  cerr << __FILE__ << " compiled " << __DATE__ << " " << __TIME__ << '\n';
#endif
  // clang-format on
  // clang-format off
cerr << R"(
  Converts TFDataRecord dicer_data::DicerFragment serialised protos bo BerkeleyDB form.
 A typical workflow will be
 dicer ... -B fragstat=dicer.data -B fragstatbinproto ...
 dicer2bdb -d /path/to/database.bdb dicer.data

 -d <dbname>            name of database to build
 -textproto             input is textproto
 -rpt <n>               report progress every <n> records processed
 -v                     verbose output
)";
  // clang-format on
  ::exit(rc);
}

class Options {
  private:
    int _verbose;

    std::unique_ptr<Db> _db;

    int _items_appended;
    int _items_stored;

    int _input_is_textproto;

    Report_Progress _report_progress;

  // private functions

    int UpdateExisting(Dbt& dbkey, Dbt& fromdb, uint32_t nextra);
    int DoStore(Dbt& dbkey, const std::string& data);

  public:
    Options();
    int Initialise(Command_Line_v2& cl);

    int input_is_textproto() const {
      return _input_is_textproto;
    }

    int Store(dicer_data::DicerFragment& proto);

    int Report(std::ostream& output) const;
};

Options::Options() {
  _verbose = 0;
  _input_is_textproto = 0;
  _items_appended = 0;
  _items_stored = 0;
}

int
Options::Report(std::ostream& output) const {
  output << "Read " << (_items_appended + _items_stored) << " fragments\n";
  output << _items_stored << " fragments stored, " << _items_appended << " appended to existing data\n";
  return 1;
}

int
Options::Initialise(Command_Line_v2& cl) {
  _verbose = cl.option_present('v');

  if (cl.option_present('d')) {
    IWString dbname = cl.string_value('d');

    DbEnv* env = NULL;

    uint32_t flags = 0;
    DBTYPE dbtype;;
    if (std::filesystem::exists(dbname.AsString())) {
      dbtype = DB_UNKNOWN;
      flags = 0;
    } else {
      dbtype = DB_HASH;
      flags = DB_CREATE;
    }

    int mode = S_IREAD | S_IWRITE | S_IRGRP | S_IROTH;

    _db =  std::make_unique<Db>(env, DB_CXX_NO_EXCEPTIONS);
    if (int rc = _db->open(NULL, dbname.null_terminated_chars(), NULL, dbtype, flags, mode);
        rc != 0) {
      cerr << "Cannot open '" << dbname << "' ";
      _db->err(rc, "");
    }
  }

  if (cl.option_present("textproto")) {
    _input_is_textproto = 1;
    if (_verbose) {
      cerr << "Will read input as textproto records\n";
    }
  }

  if (cl.option_present("rpt")) {
    uint64_t rpt;
    if (! cl.value("rpt", rpt)) {
      cerr << "The report progress option must be a whole +ve number\n";
      return 0;
    }

    _report_progress.set_report_every(rpt);

    if (_verbose) {
      cerr << "Will report progress every " << rpt << " items processed\n";
    }
  }

  return 1;
}

int
Options::Store(dicer_data::DicerFragment& proto) {
  if (_report_progress()) {
    Report(cerr);
  }

  const std::string& key = proto.smi();

  static google::protobuf::TextFormat::Printer printer;
  printer.SetSingleLineMode(true);

  std::string buffer;
  if (! printer.PrintToString(proto, &buffer)) {
    cerr << "Options::Store write '" << proto.ShortDebugString() << "'\n";
    return 0;
  }

  Dbt dbkey((void*) key.data(), key.size());

  Dbt fromdb;
  if (int rc = _db->get(NULL, &dbkey, &fromdb, 0); rc == 0) {
    return UpdateExisting(dbkey, fromdb, proto.n());
  }

  // Key not found in database, store...

  ++_items_stored;

  return DoStore(dbkey, buffer);
}

int
Options::DoStore(Dbt& dbkey, const std::string& data) {
  Dbt dbdata((void*) data.data(), data.size());

  if (int rc = _db->put(NULL, &dbkey, &dbdata, 0); rc != 0) {
    cerr << "Options::DoStore:cannot store\n";
    _db->err(rc, "");
    return 0;
  }

  return 1;
}

// We have `nextra` instances of a frgament that must be added to the
// existing entry in the database.
// First parse `fromdb` to proto form. Add `nextra` to the count,
// and then write as string and store.
int
Options::UpdateExisting(Dbt& dbkey, Dbt& fromdb, uint32_t nextra) {
  dicer_data::DicerFragment proto;
  google::protobuf::io::ArrayInputStream input(fromdb.get_data(), fromdb.get_size());
  dicer_data::DicerFragment frag;
  if (! google::protobuf::TextFormat::Parse(&input, &frag)) {
    cerr << "DicerFragmentLookupImpl::Lookup:invalid db contents '";
    cerr.write(reinterpret_cast<const char*>(fromdb.get_data()), fromdb.get_size());
    cerr << "'\n";
    return 0;
  }

  proto.set_n(proto.n() + nextra);

  static google::protobuf::TextFormat::Printer printer;
  printer.SetSingleLineMode(true);


  std::string buffer;
  if (! printer.PrintToString(proto, &buffer)) {
    cerr << "Options::Store write '" << proto.ShortDebugString() << "'\n";
    return 0;
  }

  ++_items_appended;

  return DoStore(dbkey, buffer);
}

int
Dicer2Bdb(Options& options, dicer_data::DicerFragment& proto) {
  if (options.Store(proto)) {
    return 1;
  }

  cerr << "Error storing " << proto.ShortDebugString() << '\n';
  return 0;
}

int
Dicer2Bdb(Options& options, iw_tf_data_record::TFDataReader& input) {
  while (1) {
    std::optional<dicer_data::DicerFragment> maybe_proto = 
        input.ReadProto<dicer_data::DicerFragment>();
    if (maybe_proto) {
      ;  // good
    } else if (input.eof()) {
      return 1;
    } else {
      cerr << "Dicer2Bdb:error reading\n";
      return 0;
    }

    if (! Dicer2Bdb(options, *maybe_proto)) {
      return 0;
    }
  }

  return 1;
}

int
Dicer2BdbRecord(Options& options, const const_IWSubstring& buffer) {
  google::protobuf::io::ArrayInputStream input(buffer.data(), buffer.length());

  dicer_data::DicerFragment proto;
  if (!google::protobuf::TextFormat::Parse(&input, &proto)) {
    cerr << "Dicer2BdbRecord:invalid input '" << buffer << "'\n";
    return 0;
  }

  return Dicer2Bdb(options, proto);
}

int
Dicer2BdbTextProto(Options& options, iwstring_data_source& input) {
  const_IWSubstring buffer;
  while (input.next_record(buffer)) {
    if (! Dicer2BdbRecord(options, buffer)) {
      cerr << "Error processing " << buffer << '\n';
      return 0;
    }
  }

  return 1;
}

int
Dicer2BdbTextProto(Options& options, const char* fname) {
  iwstring_data_source input(fname);
  if (! input.good()) {
    cerr << "Dicer2BdbTextProto::cannot open '" << fname << "'\n";
    return 0;
  }

  return Dicer2BdbTextProto(options, input);
}

int
Dicer2Bdb(Options& options, const char* fname) {
  if (options.input_is_textproto()) {
    return Dicer2BdbTextProto(options, fname);
  }

  iw_tf_data_record::TFDataReader input(fname);
  if (! input.good()) {
    cerr << "Dicer2Bdb:cannot open '" << fname << "'\n";
    return 0;
  }

  return Dicer2Bdb(options, input);
}

int
Main(int argc, char** argv) {
  Command_Line_v2 cl(argc, argv, "-v-d=s-textproto-rpt=ipos");
  if (cl.unrecognised_options_encountered()) {
    cerr << "Unrecognised options encountered\n";
    Usage(1);
  }

  const int verbose = cl.option_present('v');

  if (! cl.option_present('d')) {
    cerr << "Must specify database via the -d option\n";
    Usage(1);
  }

  if (cl.empty()) {
    cerr << "Insufficient arguments\n";
    Usage(1);
  }

  Options options;
  if (! options.Initialise(cl)) {
    cerr << "Cannot initialise\n";
    Usage(1);
  }

  for (const char* fname : cl) {
    if (! Dicer2Bdb(options, fname)) {
      cerr << "Error processing '" << fname << "'\n";
      return 1;
    }
  }

  if (verbose) {
    options.Report(cerr);
  }

  return 0;
}


}  // namespace dicer2bdb

int
main(int argc, char ** argv) {

  int rc = dicer2bdb::Main(argc, argv);

  return rc;
}
