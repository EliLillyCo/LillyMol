// Looks up molecules in a database built by iwecfp_database_load, single threaded only
// since threading did not help. Should remove the remaining threading vestiges.
// More complex than needed, partially because this contains many ideas that have been
// tried over time. The most useful output seems to be what is generated by `-w PSD`
// but then the consumer needs to figure out how to value that data.

#include <atomic>
#include <iomanip>
#include <iostream>
#include <limits>
#include <memory>
#include <mutex>

#ifdef __WIN32__
#include <winsock2.h>
#else
#include <netinet/in.h>
#endif

#include <assert.h>

#include "db_cxx.h"

#define RESIZABLE_ARRAY_IMPLEMENTATION
#define RESIZABLE_ARRAY_IWQSORT_IMPLEMENTATION
#include "Foundational/accumulator/accumulator.h"
#include "Foundational/cmdline/cmdline.h"
#include "Foundational/iwaray/iwaray.h"
#include "Foundational/iwmisc/misc.h"
#include "Foundational/iwmisc/report_progress.h"
#include "Foundational/iwqsort/iwqsort.h"
#include "Foundational/iwstring/iw_stl_hash_map.h"
#include "Foundational/iwstring/iw_stl_hash_set.h"

#define ISTREAM_AND_TYPE_IMPLEMENTATION

#include "Molecule_Lib/aromatic.h"
#include "Molecule_Lib/atom_typing.h"
#include "Molecule_Lib/istream_and_type.h"
#include "Molecule_Lib/molecule.h"
#include "Molecule_Lib/standardise.h"

#include "iwecfp_database.h"
#include "iwecfp_database_lookup_lib.h"

using std::cerr;

using iwecfp_database::Bit_Produced;
using iwecfp_database::Count_Radius;
using iwecfp_database::DBKey;
using iwecfp_database::Fingerprint_Characteristics;
using iwecfp_database::IWdbkeyHash;
using iwecfp_database::Set_of_Bits;
using iwecfp_database_lookup::Count_Example;
using iwecfp_database_lookup::Set_of_Databases;

static Chemical_Standardisation chemical_standardisation;

static int verbose = 0;

static int molecules_read = 0;
static int molecules_written = 0;

static int iwecfp_atom_type = IWATTYPE_Z;

static int write_isotopically_labelled_summary_structure = 0;

static int write_per_shell_data = 0;

static int only_write_outer_shell = 0;

static int write_example_structures = 1;

static int isotopically_label_most_difficult_atoms = 0;

// static DbEnv dbenv (DB_CXX_NO_EXCEPTIONS);

static int doing_ring_system_desirability = 0;

static Report_Progress report_progress;

static int create_descriptor_file = 0;
static char descriptor_file_output_separator = ' ';  // not fully implemented

/*
  We might be interested in not just the number of zero bits, but
  maybe the number of rare bits. We can define rare
*/

static int count_threshold = 0;

#ifdef CACHE_SIZE_SETTABLE
looks like this was never implemented static int db_cache_size = 0;  // 33554432;
#endif

// static double minimum_score_needed = -1.0;

static IWString_and_File_Descriptor stream_for_too_hard;

static int show_number_bits_missing_for_missing_bits = 0;

static int parallel_group_size = 0;

static int flush_output_each_molecule = 0;

static int include_score_with_normal_results = 0;

/*
  A debugging aid. When molecules are looked up, the number of instances
  found in the db's should monotonically decrease with radius
*/

static int check_monotonicity_bits_found = 0;

static int per_atom_counts = 0;

/*
  A per-thread mechanism for accumulating outputs
*/

class SF_Results {
 private:
  IWString _to_stdout;

  int _accumulate_rejected_molecules;

  IWString _to_rejected_stream;
  double _score;

 public:
  SF_Results();

  int
  accumulate_rejected_molecules() const
  {
    return _accumulate_rejected_molecules;
  }

  void
  set_accumulate_rejected_molecules(int s)
  {
    _accumulate_rejected_molecules = s;
  }

  void
  reset();

  double
  score() const
  {
    return _score;
  }

  void
  set_score(double s)
  {
    _score = s;
  }

  IWString&
  to_stdout()
  {
    return _to_stdout;
  }

  const IWString&
  to_stdout() const
  {
    return _to_stdout;
  }

  IWString&
  to_rejected_stream()
  {
    return _to_rejected_stream;
  }

  const IWString&
  to_rejected_stream() const
  {
    return _to_rejected_stream;
  }
};

SF_Results::SF_Results()
{
  _score = -9.0;
  _accumulate_rejected_molecules = 0;

  return;
}

void
SF_Results::reset()
{
  _to_stdout.resize_keep_storage(0);
  _to_rejected_stream.resize_keep_storage(0);

  return;
}

class Score_Related
{
 private:
  double _minimum_score_needed;

  int _min_examples;

  Accumulator<double> _acc_score;

  std::mutex _mutex;

  int _molecules_with_score_zero;

  int _molecules_rejected_for_score_too_low;

  //  private functions

  int
  _okscore_mutex_protected(const double score);

 public:
  Score_Related();

  int build(const Command_Line& cl, const char, const int verbose);

  int report(std::ostream&) const;

  int okscore(const double score);
};

Score_Related::Score_Related()
{
  _minimum_score_needed = -std::numeric_limits<double>::max();

  _min_examples = -1;

  _molecules_with_score_zero = 0;

  _molecules_rejected_for_score_too_low = 0;

  return;
}

static double
mylog10(const int x)
{
  if (0 == x) {
    return 0.0;
  }

  if (x > 1) {
    return log10(static_cast<double>(x));
  }

  return 0.1;  // nice easy number
  // return 0.1505149978319906;    // which is half of log10(2.0)
}

int
Score_Related::build(const Command_Line& cl, const char u1, const int verbose)
{
  if (!cl.option_present(u1)) {  // nothing to do
    return 1;
  }

  const_IWSubstring s = cl.string_value(u1);

  if (s.starts_with('E')) {
    s.remove_leading_chars(1);

    if (!s.numeric_value(_min_examples) || _min_examples < 1) {
      cerr << "Score_Related::build:the minimum number of examples 'E" << s
           << "' must specify a valid +ve number\n";
      return 0;
    }

    _minimum_score_needed = mylog10(_min_examples) - 0.01;

    if (verbose) {
      cerr << "Score_Related::build:requiring at least " << _min_examples
           << " examples, translates to a min score of " << _minimum_score_needed << '\n';
    }
  } else if (!s.numeric_value(_minimum_score_needed)) {
    cerr << "Score_Related::build:the minimum score (-" << u1
         << ") must be a positive value\n";
    return 0;
  }

  if (verbose) {
    cerr << "Score_Related::build:will discard molecules with scores below "
         << _minimum_score_needed << '\n';
  }

  return 1;
}

int
Score_Related::report(std::ostream& output) const
{
  output << "Score_Related::report:examined " << _acc_score.n() << " molecules\n";

  if (0 == _acc_score.n()) {
    return 1;
  }

  output << _molecules_with_score_zero << " molecules with zero score";
  if (_min_examples > 0) {
    output << ", " << _molecules_rejected_for_score_too_low << " rejected for fewer than "
           << _min_examples << " examples";
  } else if (_minimum_score_needed > 0.0) {
    output << ", " << _molecules_rejected_for_score_too_low
           << " rejected for scores below " << _minimum_score_needed;
  }
  output << '\n';

  if (1 == _acc_score.n()) {
    output << " single value " << _acc_score.minval() << '\n';
  } else {
    output << "Scores between " << _acc_score.minval() << " and " << _acc_score.maxval()
           << " ave " << static_cast<float>(_acc_score.average()) << '\n';
  }

  return 1;
}

template <typename T>
int
write_smiles_and_id(Molecule& m, const int max_shell_radius, const int* min_each_shell,
                    const Set_of_Atoms* rarest_atom, T& output)
{
  if (create_descriptor_file) {
    output << m.name();
    return 1;
  }

  if (0 == isotopically_label_most_difficult_atoms) {
    output << m.smiles() << ' ' << m.name();
    return 1;
  }

  for (int i = max_shell_radius; i >= 0; --i) {
    if (rarest_atom[i].number_elements() > 0) {
      return write_smiles_and_id(m, i, rarest_atom[i], output);
    }
  }

  output << m.smiles() << ' ' << m.name();

  return 1;
}

int
Score_Related::okscore(const double score)
{
  _mutex.lock();

  int rc = _okscore_mutex_protected(score);

  _mutex.unlock();

  return rc;
}

int
Score_Related::_okscore_mutex_protected(const double score)
{
  _acc_score.extra(score);

  if (score <= 0.0) {
    _molecules_with_score_zero++;
  }

  if (score >= _minimum_score_needed) {
    return 1;  // score is good
  }

  _molecules_rejected_for_score_too_low++;

  return 0;  // score is bad
}

static Score_Related score_related;

/*
  When doing retrospective studies, it can be interesting to look
  at the database without certain molecules
*/

typedef std::unordered_map<DBKey, int, IWdbkeyHash> Subtract;

static int
preprocess_molecule(Molecule& m)
{
  m.remove_all(1);

  m.reduce_to_largest_fragment();  // always reduce to largest fragment

  // Apr 2023. Even though chirality does not influence the result,
  // there is no reason to remove it. Just causes problems.
  // m.remove_all_chiral_centres();   // do NOT remove chirality.

  if (chemical_standardisation.active()) {
    chemical_standardisation.process(m);
  }

  return 1;
}

static void
usage(int rc)
{
// clang-format off
#if defined(GIT_HASH) && defined(TODAY)
  cerr << __FILE__ << " compiled " << TODAY << " git hash " << GIT_HASH << '\n';
#else
  cerr << __FILE__ << " compiled " << __DATE__ << " " << __TIME__ << '\n';
#endif
  // clang-format on
  // clang-format off
  cerr << DB_VERSION_STRING << '\n';
  cerr << "Compute the Extended Connectivity fingerprints for molecules\n";
  cerr << "  -r <len>       min shell radius\n";
  cerr << "  -R <length>    mas shell radius (default is whatever is in DB)\n";
  cerr << "  -l             only check bits at the maximum radius\n";
  cerr << "  -d <dbname>    database(s) to use\n";
  cerr << "  -w <...>       output desired\n";
  cerr << "    -w score       smiles and score (log10 of rarest outer shell bit)\n";
  cerr << "    -w PSD         write per shell data on examples found\n";
  cerr << "    -w OSO         only write per shell data for the outer shell only\n";
  cerr << "    -w iso         write isotopically labelled parent molecule\n";
  cerr << "    -w examples    write examples of each bit (if available)\n";
  cerr << "  -u E<n>        discard any molecule with fewer than <n> examples in the outer shell\n";
  cerr << "  -u <x>         discard any molecule with score lower than <x>, need to your log10 tables\n";
  cerr << "       log10 values     1 0.1*";

  for (int i = 2; i < 10; ++i)
  {
    cerr << "  " << i << ' ' << std::setprecision(3) << static_cast<float>(log10(i));
  }
  cerr << '\n';
  cerr << "  -U <fname>     stream for molecules rejected by -u option\n";
  cerr << "  -S <fname>     subtract bits produced by molecules in <fname>\n";
  cerr << "  -I             place an isotope on the rarest atom(s)\n";
  cerr << "  -M ...         miscellaneous options, enter '-M help' for info\n";
//cerr << "  -z <number>    only count bits with counts >= <number> examples\n";
  cerr << "  -n <n>         if examples in databases, write the first <n>. Use 'all' for all\n";
  cerr << "  -t <number>    report progress every <number> molecules processed\n";
  cerr << "  -i <type>      input type\n";
  cerr << "  -g ...         chemical standardisation options\n";
  cerr << "  -E ...         standard element options\n";
  cerr << "  -v             verbose output\n";
  // clang-format on

  exit(rc);
}

/*
  Information about a bit.
  During lookups we will associate a bit with some information
  looked up in the database
*/

template <typename I>
class Bit_Produced_CE : public Bit_Produced
{
 private:
  //  This will get populated when we do the lookup

  const I* _fromdb;

 public:
  Bit_Produced_CE(unsigned int, atom_number_t, unsigned int, unsigned int);

  void
  extra() {
    _count++;
  }

  void set_fromdb(const I* s)
  {
    _fromdb = s;
  }

  const I* fromdb() const
  {
    return _fromdb;
  }
};

template <typename I>
Bit_Produced_CE<I>::Bit_Produced_CE(unsigned int b, atom_number_t c, unsigned int cat,
                                    unsigned int r)
    : Bit_Produced(b, c, cat, r)
{
  _fromdb = nullptr;

  return;
}

template <typename I>
class Bit_Produced_Comparator
{
 private:
 public:
  int
  operator()(const Bit_Produced_CE<I>*, const Bit_Produced_CE<I>*) const;
};

template <typename I>
int
Bit_Produced_Comparator<I>::operator()(const Bit_Produced_CE<I>* bp1,
                                       const Bit_Produced_CE<I>* bp2) const
{
  const I* ce1 = bp1->fromdb();
  const I* ce2 = bp2->fromdb();

  if (nullptr == ce1) {
    if (nullptr == ce2) {
      return 0;
    }
    return -1;
  } else if (nullptr == ce2) {
    return 1;
  }

  if (ce1->number_examples() < ce2->number_examples()) {
    return -1;
  } else if (ce1->number_examples() > ce2->number_examples()) {
    return 1;
  }

  return 0;
}

static Bit_Produced_Comparator<Count_Example> bpc;

class Lookup_Results
{
 private:
  int _nbits;
  Accumulator_Int<int> _found;

 public:
  Lookup_Results();

  //  void increment_nbits () { _nbits++;}

  int
  nbits() const
  {
    return _nbits;
  }

  void
  reset();

  void
  extra(int c);

  int
  n() const
  {
    return _found.n();
  }

  template <typename O>
  int
  report(O&) const;

  int
  bits_missing() const
  {
    return _nbits - _found.n();
  }

  int
  min_examples() const
  {
    return _found.minval();
  }
};

Lookup_Results::Lookup_Results()
{
  _nbits = 0;

  return;
}

void
Lookup_Results::reset()
{
  _nbits = 0;

  _found.reset();

  return;
}

template <typename O>
int
Lookup_Results::report(O& output) const
{
  output << ' ' << _nbits;

  if (0 == _found.n()) {
    output << " 0 " << _nbits << " 0.0 0.0";
    return 1;
  }

  output << ' ' << _found.n() << ' ' << (_nbits - _found.n());
  output << ' ' << _found.minval() << ' ';

  if (_found.n() > 1) {
    output << static_cast<float>(_found.average());
  } else {
    output << static_cast<float>(_found.minval());
  }

  return 1;
}

void
Lookup_Results::extra(int c)
{
  _nbits++;

  if (c > 0) {
    _found.extra(c);
  }

  return;
}

static int
do_check_monotonicity_bits_found(const IWString& mname, Lookup_Results* lkrs,
                                 const int min_shell_radius, const int max_shell_radius)
{
  int rc = 1;

  for (auto r = min_shell_radius + 1; r <= max_shell_radius; ++r) {
    if (lkrs[r - 1].bits_missing() > lkrs[r].bits_missing()) {
      cerr << "Non monotonic bits missing at radii " << (r - 1) << " and " << r
           << " missing: " << lkrs[r - 1].bits_missing() << " and "
           << lkrs[r].bits_missing() << '\n';
      rc = 0;
    }
    if (lkrs[r - 1].min_examples() < lkrs[r].min_examples()) {
      cerr << "Non monotonic min examples at radii " << (r - 1) << " and " << r
           << " missing: " << lkrs[r - 1].min_examples() << " and "
           << lkrs[r].min_examples() << '\n';
      rc = 0;
    }
  }

  return rc;
}

template <typename T>
int
write_smiles_and_id(Molecule& m, const int radius, const Set_of_Atoms& rarest_atom,
                    T& output)
{
  // cerr << "write_smiles_and_id:rarest_atom " << rarest_atom << '\n';
  for (int i = 0; i < rarest_atom.number_elements(); ++i) {
    const auto j = rarest_atom[i];

    m.set_isotope(j, radius);
  }

  output << m.smiles() << ' ' << m.name();

  return 1;
}

template <typename T>
int
do_write_per_radius_data(const Lookup_Results* lkrs,
                         const Fingerprint_Characteristics& fpc, T& output)
{
  for (int i = fpc.min_shell_radius(); i <= fpc.max_shell_radius(); i++) {
    output << descriptor_file_output_separator << i << descriptor_file_output_separator;

    if (lkrs[i].bits_missing()) {
      if (show_number_bits_missing_for_missing_bits) {
        output << lkrs[i].bits_missing() << '*';
      } else {
        output << '0';
      }
    } else {
      output << lkrs[i].min_examples();
    }
  }

  return 1;
}

static double
do_log10_outer_shell_score(const Lookup_Results* lkrs, const int max_shell_radius)
{
  const Lookup_Results& l = lkrs[max_shell_radius];

  // cerr << "Max radius " << max_shell_radius << " missing " << l.bits_missing() << " min
  // " << l.min_examples() << '\n';

  if (l.bits_missing())  // figure out first shell with a missing bit
  {
    for (int i = 0; i <= max_shell_radius; ++i) {
      if (0 == lkrs[i].bits_missing()) {
        continue;
      }
      // radius 0 -> -4.0 score, radius 3 -> -1.0 score
      return static_cast<double>(-4 + i);
    }
    //  return -1.0 / static_cast<double>(max_shell_radius);
  }

  if (l.min_examples() <= 0) {  // very small molecule
    return -1.0;
  }

  return mylog10(l.min_examples());
}

static int
write_smiles_with_isotope(Molecule& m, atom_number_t centre_atom, int radius,
                          IWString_and_File_Descriptor& output)
{
  if (create_descriptor_file) {
    output << m.name();
    return 1;
  }

  // cerr << "write_smiles_with_isotope atom " << centre_atom << '\n';
  m.set_isotope(centre_atom, radius);
  output << m.smiles() << ' ' << m.name() << '\n';
  m.set_isotope(centre_atom, 0);

  return 1;
}

/*
  Isotopocally label the most difficult atoms
*/

template <typename I>
int
do_isotopically_label_most_difficult_atoms(Molecule& m,
                                           const resizable_array<Bit_Produced_CE<I>*>& bp,
                                           int n, IWString_and_File_Descriptor& output)
{
  cerr << "do_isotopically_label_most_difficult_atoms, n = " << n << '\n';
  const auto* bpi = bp[0];  // first database only

  const I* ce = bpi->fromdb();

  int lowest_count = ce->number_examples();

  // int nprocess = n;

  for (int i = 1; i < bp.number_elements(); i++) {
    int nex = ce->number_examples();

    if (nex < lowest_count) {
      lowest_count = nex;
    }
  }

  // int nset = n;

  for (int i = 0; i < n; i++) {
    atom_number_t a = bp[i]->centre_atom();

    m.set_isotope(a, n - i);
  }

  output << m.smiles() << ' ' << m.name();

  for (int i = 0; i < n; i++) {
    atom_number_t a = bp[i]->centre_atom();

    m.set_isotope(a, 0);
  }

  return 1;
}

/*
  Object that does most of the work
*/

class Lookup_Calculation_Results
{
 private:
  int _min_shell_radius;
  int _max_shell_radius;

  Lookup_Results* _lkrs;

  int* _min_each_shell;

  Set_of_Atoms* _rarest_atom;

  Set_of_Bits<Bit_Produced> _sob;

  double _score;

  int _include_nbits_in_normal_output;

  //  Something useful for debugging

  int* _per_atom_counts;

  //  private functions

  template <typename T>
  int
  _do_write_per_radius_data(T& output) const;
  template <typename T>
  int
  _write_smiles_and_id(Molecule& m, T& output) const;
  void
  _adjust_per_shell_arrays(const int nexamples, const int r, const atom_number_t a);

 public:
  Lookup_Calculation_Results();
  ~Lookup_Calculation_Results();

  int
  initialise(const Fingerprint_Characteristics& fpc);

  void
  set_include_nbits_in_normal_output(int s)
  {
    _include_nbits_in_normal_output = s;
  }

  Lookup_Results*
  lookup_results_array()
  {
    return _lkrs;
  }

  int
  do_lookups_calculate_score(Molecule& m, Fingerprint_Characteristics& rpc,
                             Set_of_Databases& sodb);

  double
  score() const
  {
    return _score;
  }

  template <typename T>
  int
  normal_output(Molecule& m, T& output) const;

  int
  handle_failed_molecule(Molecule& m, SF_Results& res) const;

  template <typename T>
  int
  handle_failed_molecule(Molecule& m, T& stream_for_too_hard) const;
};

Lookup_Calculation_Results::Lookup_Calculation_Results()
{
  _max_shell_radius = 0;
  _min_shell_radius = 0;

  _lkrs = nullptr;
  _min_each_shell = nullptr;
  _rarest_atom = nullptr;

  _score = -1.0;

  _include_nbits_in_normal_output = 0;

  _per_atom_counts = nullptr;

  return;
}

Lookup_Calculation_Results::~Lookup_Calculation_Results()
{
  if (nullptr != _lkrs) {
    delete[] _lkrs;
    delete[] _min_each_shell;
    delete[] _rarest_atom;
  }

  if (nullptr != _per_atom_counts) {
    delete[] _per_atom_counts;
  }

  return;
}

int
Lookup_Calculation_Results::initialise(const Fingerprint_Characteristics& fpc)
{
  assert(0 == _min_shell_radius);
  assert(0 == _max_shell_radius);

  _max_shell_radius = fpc.max_shell_radius();
  _min_shell_radius = fpc.min_shell_radius();

  _lkrs = new Lookup_Results[_max_shell_radius + 1];
  _min_each_shell = new int[_max_shell_radius + 1];
  _rarest_atom = new Set_of_Atoms[_max_shell_radius + 1];

  return 1;
}

//#define DEBUG_DO_LOOKUP_NO_EXAMPLES

int
Lookup_Calculation_Results::do_lookups_calculate_score(Molecule& m,
                                                       Fingerprint_Characteristics& fpc,
                                                       Set_of_Databases& sodb)
{
  set_vector(_min_each_shell, _max_shell_radius + 1, std::numeric_limits<int>::max());

  // cerr << "_max_shell_radius " << _max_shell_radius << '\n';
  for (int i = 0; i <= _max_shell_radius; ++i) {
    _rarest_atom[i].resize_keep_storage(0);
    _lkrs[i].reset();
  }

  const int matoms = m.natoms();

  if (per_atom_counts) {
    _per_atom_counts = new_int(matoms * (_max_shell_radius + 1));
  }

  _sob.clear();
  compute_fingerprints(m, fpc, _sob);

  int max_radius = 0;

  int nbits = 0;
  for (auto i : _sob) {
    const auto& k = i.first;

    const auto r = k._radius;

    if (r > max_radius) {
      max_radius = r;
    }

    //  cerr << "Processing bit at radius " << static_cast<int>(r) << '\n';

    nbits++;

#ifdef DEBUG_DO_LOOKUP_NO_EXAMPLES
    cerr << "Looking up bit " << k._bit << ", radius " << static_cast<int>(k._radius)
         << " atom " << i.second->centre_atom() << " "
         << m.smarts_equivalent_for_atom(i.second->centre_atom()) << '\n';
#endif

    const int nexamples = sodb.lookup_bit_threaded(k);
    //  int notused1;
    //  IWString notused2;
    //  const auto nexamples = sodb.lookup_bit(k, notused1, notused2);

#ifdef DEBUG_DO_LOOKUP_NO_EXAMPLES
    cerr << "  found " << nexamples << " examples\n";
#endif

    _lkrs[r].extra(nexamples);

    if (nullptr != _per_atom_counts) {
      _per_atom_counts[i.second->centre_atom() * (_max_shell_radius + 1) + k._radius] =
          nexamples;
    }

    if (nexamples > _min_each_shell[r]) {
      continue;
    }

    _adjust_per_shell_arrays(nexamples, r, i.second->centre_atom());
  }

  if (check_monotonicity_bits_found) {
    do_check_monotonicity_bits_found(m.name(), _lkrs, fpc.min_shell_radius(),
                                     fpc.max_shell_radius());
  }

  _score = do_log10_outer_shell_score(_lkrs, max_radius);

  return 1;
}

void
Lookup_Calculation_Results::_adjust_per_shell_arrays(const int nexamples, const int r,
                                                     const atom_number_t a)
{
  // cerr << "Lookup_Calculation_Results:_adjust_per_shell_arrays:compare " << nexamples
  // << " with " << _min_each_shell[r] << " radius " << r << '\n';
  if (nexamples > _min_each_shell[r]) {
    return;
  }

  if (nexamples < _min_each_shell[r])  // new lowest value
  {
    _min_each_shell[r] = nexamples;
    if (isotopically_label_most_difficult_atoms) {
      _rarest_atom[r].resize_keep_storage(0);
      _rarest_atom[r].add(a);
    }
  } else if (isotopically_label_most_difficult_atoms) {
    _rarest_atom[r].add(a);
  }

  return;
}

template <typename T>
int
Lookup_Calculation_Results::_write_smiles_and_id(Molecule& m, T& output) const
{
  if (create_descriptor_file) {
    output << m.name();
    return 1;
  }

  if (0 == isotopically_label_most_difficult_atoms) {
    output << m.smiles() << ' ' << m.name();
    return 1;
  }

  for (int i = _max_shell_radius; i >= 0; --i) {
    // cerr << "Lookup_Calculation_Results::_write_smiles_and_id:radius " << i << "
    // _rarest_atom " << _rarest_atom[i].number_elements() << '\n';
    if (_rarest_atom[i].number_elements() > 0) {
      return write_smiles_and_id(m, i, _rarest_atom[i], output);
    }
  }

  output << m.smiles() << ' ' << m.name();

  return 1;
}

template <typename T>
int
Lookup_Calculation_Results::normal_output(Molecule& m, T& output) const
{
  _write_smiles_and_id(m, output);

  if (_include_nbits_in_normal_output) {
    output << descriptor_file_output_separator << _sob.size();
  }

  if (write_per_shell_data) {
    _do_write_per_radius_data(output);
  }

  if (include_score_with_normal_results) {
    output << descriptor_file_output_separator << static_cast<float>(_score);
  }
  output << '\n';

  if (nullptr != _per_atom_counts) {
    const int matoms = m.natoms();

    int ndx = 0;
    for (int i = 0; i < matoms; ++i) {
      output << i << ' ' << m.smarts_equivalent_for_atom(i);

      for (int r = 0; r <= _max_shell_radius; ++r) {
        output << ' ' << _per_atom_counts[ndx];
        ndx++;
      }
      output << '\n';
    }
  }

  return 1;
}

template <typename T>
int
Lookup_Calculation_Results::_do_write_per_radius_data(T& output) const
{
  for (int i = _min_shell_radius; i <= _max_shell_radius; i++) {
    output << descriptor_file_output_separator;

    if (!create_descriptor_file) {
      output << i << descriptor_file_output_separator;
    }

    if (_lkrs[i].bits_missing()) {
      if (show_number_bits_missing_for_missing_bits) {
        output << (-_lkrs[i].bits_missing());
      } else {
        output << '0';
      }
    } else {
      output << _lkrs[i].min_examples();
    }
  }

  return 1;
}

int
Lookup_Calculation_Results::handle_failed_molecule(Molecule& m, SF_Results& res) const
{
  if (!res.accumulate_rejected_molecules()) {
    return 0;
  }

  return handle_failed_molecule(m, res.to_rejected_stream());

  // cerr << "RJ stream now " << res.to_rejected_stream();
}

template <typename T>
int
Lookup_Calculation_Results::handle_failed_molecule(Molecule& m, T& output) const
{
  _write_smiles_and_id(m, output);

  if (write_per_shell_data) {
    _do_write_per_radius_data(output);
  }

  if (include_score_with_normal_results) {
    output << ' ' << static_cast<float>(_score);
  }

  output << '\n';

  return 0;
}

static int
do_lookup_no_examples(Molecule& m, Set_of_Databases& sodb,
                      Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                      IWString_and_File_Descriptor& output)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  const double score = lcr.score();

  if (!score_related.okscore(score)) {
    return lcr.handle_failed_molecule(m, stream_for_too_hard);
  }

  return lcr.normal_output(m, output);
}

/*static int
do_lookup_no_examples (Molecule & m,
                       Set_of_Databases & sodb,
                       Fingerprint_Characteristics & fpc,
                       Lookup_Calculation_Results & lcr,
                       SF_Results & res)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  const double score = lcr.score();

  if (! score_related.okscore(score))
    return lcr.handle_failed_molecule(m, res);

  return lcr.normal_output(m, res.to_stdout());
}*/

// #define DEBUG_DO_LOOKUP_WITH_EXAMPLES

static int
do_lookup_with_examples(Molecule& m, Set_of_Databases& sodb,
                        Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                        IWString_and_File_Descriptor& output)
{
  Lookup_Results* lkrs = lcr.lookup_results_array();
  for (int i = 0; i <= fpc.max_shell_radius(); ++i) {
    lkrs[i].reset();
  }

  // The array of Count_Example objects is so they can be deleted properly
  // The array of Bit_Produced objects is so they can be sorted

  Set_of_Bits<Bit_Produced_CE<Count_Example>> sob;
  compute_fingerprints(m, fpc, sob);

#ifdef DEBUG_DO_LOOKUP_WITH_EXAMPLES
  cerr << "Calculated " << sob.size() << " fingerprints\n";
#endif

  resizable_array_p<Count_Example> ce;
  resizable_array<Bit_Produced_CE<Count_Example>*> bits;

  const auto s = sob.size();

  ce.resize(s);
  bits.resize(s);

  for (auto i : sob) {
    const auto& k = i.first;

    auto* bp = i.second;

    bits.add(bp);

    const int r = bp->radius();
#ifdef DEBUG_DO_LOOKUP_WITH_EXAMPLES
    cerr << "looking up bit " << bp->bit() << " radius " << r << " atom "
         << i.second->centre_atom() << " "
         << m.smarts_equivalent_for_atom(i.second->centre_atom()) << '\n';
#endif

    int nexamples = sodb.lookup_bit(k, ce);

    lkrs[r].extra(nexamples);

    if (0 == nexamples) {
      continue;
    }

#ifdef DEBUG_DO_LOOKUP_WITH_EXAMPLES
    cerr << "Bit " << k._bit << " from atom " << bp->centre_atom() << " rad "
         << bp->radius() << " found " << nexamples << " examples\n";
#endif

    if (nexamples > count_threshold) {
      lkrs[r].extra(nexamples);
      bp->set_fromdb(ce.last_item());
    }
  }

  if (check_monotonicity_bits_found) {
    do_check_monotonicity_bits_found(m.name(), lkrs, fpc.min_shell_radius(),
                                     fpc.max_shell_radius());
  }

  const double score = do_log10_outer_shell_score(lkrs, fpc.max_shell_radius());

  if (!score_related.okscore(score)) {
    return lcr.handle_failed_molecule(m, stream_for_too_hard);
  }

  // sort so missing bits first, then ordered by numer of examples

  if (bits.number_elements() > 1) {
    bits.iwqsort(bpc);
  }

  if (isotopically_label_most_difficult_atoms) {
    do_isotopically_label_most_difficult_atoms(
        m, bits, isotopically_label_most_difficult_atoms, output);
  } else {
    output << m.smiles() << ' ' << m.name() << ' ' << sob.size() << " bits score "
           << static_cast<float>(
                  do_log10_outer_shell_score(lkrs, fpc.max_shell_radius()));
  }

  if (write_per_shell_data) {
    do_write_per_radius_data(lkrs, fpc, output);
  }

  output << '\n';

// Label all the not-found atoms with the lowest isotpe

// #define ECHO_SORTED_LIST
#ifdef ECHO_SORTED_LIST
  for (int i = 0; i < bits.number_elements(); i++) {
    const Bit_Produced_CE<Count_Example>* bp = bits[i];
    cerr << "i = " << i << " nex " << bp->fromdb()->number_examples() << '\n';
  }
#endif

  int istart = 0;
  int istop = bits.number_elements();
  int min_rad_missing = std::numeric_limits<int>::max();

  for (int i = 0; i < istop; i++) {
    const auto* bp = bits[i];

    if (nullptr != bp->fromdb()) {  // got to the bits that were found
      break;
    }

    atom_number_t c = bp->centre_atom();
    int r = bp->radius();

    if (0 == m.isotope(c) || m.isotope(c) > static_cast<isotope_t>(r)) {
      m.set_isotope(c, r);
    }

    if (r < min_rad_missing) {
      min_rad_missing = r;
    }

    istart++;
  }

  if (istart > 0 && write_isotopically_labelled_summary_structure) {
    output << m.smiles() << ' ' << m.name() << ' ' << istart << " MISSING (minrad) "
           << min_rad_missing << '\n';
    m.transform_to_non_isotopic_form();
  }

  if (0 == write_example_structures) {
    return 1;
  }

  istop = istart + write_example_structures;
  if (istop > bits.number_elements()) {
    istop = bits.number_elements();
  }

  if (verbose > 2) {
    cerr << "Writing " << (istop - istart) << " examples\n";
  }

  for (int i = istart; i < istop; i++) {
    const auto* bp = bits[i];

    write_smiles_with_isotope(m, bp->centre_atom(), bp->radius() + 1, output);

    const auto* c = bp->fromdb();

    if (nullptr == c) {  // should not happen
      output << "*\n";
    } else {
      c->do_output(output);
    }
  }

  output.write_if_buffer_holds_more_than(4096);

  if (verbose > 1) {
    output.flush();
  }

  return ce.number_elements();
}

// static Lookup_Results * lkrs = nullptr;

static const Element* aromatic_carbon = nullptr;
static const Element* aliphatic_carbon = nullptr;

static const Element* aromatic_nitrogen = nullptr;
static const Element* aliphatic_nitrogen = nullptr;

static const Element* aliphatic_oxygen = nullptr;

static const Element* fluorine = nullptr;
static const Element* chlorine = nullptr;
static const Element* bromine = nullptr;
static const Element* iodine = nullptr;

static const Element* sulphur = nullptr;

static resizable_array<const Element*> elements_to_add;

static void
initialise_substituent_elements()
{
  assert(nullptr == aromatic_carbon);

  aromatic_carbon = create_element_with_symbol("c");
  const_cast<Element*>(aromatic_carbon)->set_permanent_aromatic(1);
  aliphatic_carbon = get_element_from_atomic_number(6);

  aromatic_nitrogen = create_element_with_symbol("n");
  const_cast<Element*>(aromatic_nitrogen)->set_permanent_aromatic(1);
  aliphatic_nitrogen = get_element_from_atomic_number(7);

  aliphatic_oxygen = get_element_from_atomic_number(8);
  fluorine = get_element_from_atomic_number(9);
  chlorine = get_element_from_atomic_number(17);
  bromine = get_element_from_atomic_number(35);
  iodine = get_element_from_atomic_number(53);
  sulphur = get_element_from_atomic_number(16);

  elements_to_add.add(aromatic_carbon);
  elements_to_add.add(aliphatic_carbon);
  elements_to_add.add(aromatic_nitrogen);
  elements_to_add.add(aliphatic_nitrogen);
  elements_to_add.add(aliphatic_oxygen);
  elements_to_add.add(fluorine);
  elements_to_add.add(chlorine);
  elements_to_add.add(bromine);
  elements_to_add.add(iodine);
  elements_to_add.add(sulphur);

  return;
}

template <typename T>
double
determine_difficulty_score(Molecule& m, Set_of_Databases& sodb,
                           Fingerprint_Characteristics& fpc, Set_of_Bits<T>& sob,
                           Lookup_Calculation_Results& lcr)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  return lcr.score();
}

/*
  The input molecule is a subset of a larger molecule
*/

static int
analyse_ring_system(Molecule& m, int atoms_to_check, Set_of_Databases& sodb,
                    Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                    IWString_and_File_Descriptor& output)
{
  int n = elements_to_add.number_elements();

  resizable_array<double> difficulty_score;

  Set_of_Bits<Bit_Produced> sob;

  const auto base_difficulty = determine_difficulty_score(m, sodb, fpc, sob, lcr);

  difficulty_score.add(base_difficulty);

  for (int i = 0; i < atoms_to_check; i++) {
    if (0 == m.hcount(i)) {
      continue;
    }

    for (int j = 0; j < n; j++) {
      m.add(elements_to_add[j]);
      m.add_bond(i, atoms_to_check, SINGLE_BOND);

      int d = determine_difficulty_score(m, sodb, fpc, sob, lcr);

      difficulty_score.add(d);

      output << m.smiles() << " S:" << m.name() << ' ' << d << '\n';

      m.resize(atoms_to_check);
    }
  }

  return 1;
}

static void
add_connected_atoms(const Molecule& m, const int* in_subset, const int* xref,
                    Molecule& subset)
{
  int matoms = m.natoms();

  for (int i = 0; i < matoms; i++) {
    if (0 == in_subset[i]) {
      continue;
    }

    const Atom* ai = m.atomi(i);

    int acon = ai->ncon();

    if (2 == acon) {
      continue;
    }

    for (int j = 0; j < acon; j++) {
      const Bond* b = ai->item(j);

      atom_number_t k = b->other(i);

      if (in_subset[k]) {
        continue;
      }

      const Element* ek = m.elementi(k);

      subset.add(ek);
      subset.add_bond(subset.natoms() - 1, xref[k], b->btype());
    }
  }

  return;
}

static int
ring_system_desirability(Molecule& m, Set_of_Databases& sodb,
                         Fingerprint_Characteristics& fpc,
                         Lookup_Calculation_Results& lcr,
                         IWString_and_File_Descriptor& output)
{
  int matoms = m.natoms();
  int* ring_membership = new int[matoms];
  std::unique_ptr<int[]> free_ring_membership(ring_membership);
  int* tmp = new int[matoms];
  std::unique_ptr<int[]> free_tmp(tmp);
  int* xref = new int[matoms];
  std::unique_ptr<int[]> free_xref(xref);

  int number_ring_systems =
      m.label_atoms_by_ring_system_including_spiro_fused(ring_membership);

  for (int i = 1; i <= number_ring_systems; i++) {
    int other_than_aromatic_carbon = 0;

    for (int j = 0; j < matoms; j++)  // transfer atoms in system to TMP
    {
      if (ring_membership[j] == i) {
        tmp[j] = 1;
        if (6 != m.atomic_number(j)) {
          other_than_aromatic_carbon++;
        } else if (!m.is_aromatic(j)) {
          other_than_aromatic_carbon++;
        }
      } else {
        tmp[j] = 0;
      }
    }

    if (0 == other_than_aromatic_carbon) {  // who cares about benzene
      continue;
    }

    Molecule subset;
    m.create_subset(subset, tmp, 1, xref);
    subset.set_name(m.name());

    int atoms_to_check = subset.natoms();

    add_connected_atoms(m, tmp, xref, subset);  // connected atoms don't get checked

    analyse_ring_system(subset, atoms_to_check, sodb, fpc, lcr, output);
  }

  return 1;
}

static int
iwecfp(Molecule& m, Set_of_Databases& sodb, Fingerprint_Characteristics& fpc,
       Lookup_Calculation_Results& lcr, IWString_and_File_Descriptor& output)

{
  m.compute_aromaticity_if_needed();

  // cerr << "Molecule contains " << sob.size() << " bits\n";

  if (doing_ring_system_desirability) {
    ring_system_desirability(m, sodb, fpc, lcr, output);
  } else if (sodb.user_wants_example_structures()) {
    do_lookup_with_examples(m, sodb, fpc, lcr, output);
  } else {
    do_lookup_no_examples(m, sodb, fpc, lcr, output);
  }

  return 1;
}

static int
iwecfp(data_source_and_type<Molecule>& input, Set_of_Databases& sodb,
       Fingerprint_Characteristics& fpc, IWString_and_File_Descriptor& output)
{
  Lookup_Calculation_Results lcr;

  lcr.initialise(fpc);

  Molecule* m;
  while (nullptr != (m = input.next_molecule())) {
    molecules_read++;

    std::unique_ptr<Molecule> free_m(m);

    if (report_progress()) {
      cerr << "Processed " << molecules_read << " molecules\n";
    }

    if (verbose > 1) {
      cerr << molecules_read << " processing '" << m->name() << "'\n";
    }

    if (!preprocess_molecule(*m)) {
      cerr << "Skipping non organic or too large '" << m->name() << "'\n";
      continue;
    }

    if (!iwecfp(*m, sodb, fpc, lcr, output)) {
      cerr << "Fatal error processing '" << m->name() << "'\n";
      return 0;
    }

    if (flush_output_each_molecule) {
      output.flush();
    } else {
      output.write_if_buffer_holds_more_than(1024);
    }
  }

  return 1;
}

static int
iwecfp_single_molecule(Molecule& m, Set_of_Databases& sodb,
                       Fingerprint_Characteristics& fpc, Lookup_Calculation_Results& lcr,
                       SF_Results& res)
{
  lcr.do_lookups_calculate_score(m, fpc, sodb);

  res.reset();

  if (!score_related.okscore(lcr.score())) {
    return lcr.handle_failed_molecule(m, res);
  }

  molecules_written++;

  return lcr.normal_output(m, res.to_stdout());
}

static int
get_next_group_of_molecules(data_source_and_type<Molecule>& input,
                            resizable_array_p<Molecule>& mgrp, const int nget)
{
  mgrp.resize_keep_storage(0);

  int rc = 0;

  Molecule* m;
  while (nullptr != (m = input.next_molecule())) {
    if (!preprocess_molecule(*m)) {
      cerr << "Skipping non organic or too large '" << m->name() << "'\n";
      delete m;
      continue;
    }

    mgrp.add(m);

    rc++;

    if (rc >= nget) {
      return rc;
    }
  }

  return rc;
}

static int
transfer_to_output_streams(const SF_Results* res, const int n,
                           IWString_and_File_Descriptor& output,
                           IWString_and_File_Descriptor& stream_for_too_hard)
{
  for (int i = 0; i < n; ++i) {
    const IWString& s = res[i].to_stdout();
    if (s.length()) {
      output << s;
      output.write_if_buffer_holds_more_than(4096);
      molecules_written++;
    } else if (stream_for_too_hard
                   .active())  // nothing on stdout, is the reject stream open?
    {
      const IWString& r = res[i].to_rejected_stream();
      if (r.length()) {
        stream_for_too_hard << r;
        stream_for_too_hard.write_if_buffer_holds_more_than(32768);
      }
    }
  }

  return 1;
}

/*
  When doing parallel execution, need to hve per-thread instances of everything
*/

static int
iwecfp_chunked(data_source_and_type<Molecule>& input, Set_of_Databases& sodb,
               Fingerprint_Characteristics& fpc, IWString_and_File_Descriptor& output)
{
  // cerr << "Running chunked " << parallel_group_size << '\n';

  SF_Results* res = new SF_Results[parallel_group_size];
  std::unique_ptr<SF_Results[]> free_res(res);
  Lookup_Calculation_Results* lcr = new Lookup_Calculation_Results[parallel_group_size];
  std::unique_ptr<Lookup_Calculation_Results[]> free_lcr(lcr);

  for (int i = 0; i < parallel_group_size; ++i) {
    lcr[i].initialise(fpc);
    if (stream_for_too_hard.active()) {
      res[i].set_accumulate_rejected_molecules(1);
    }
  }

  resizable_array_p<Molecule> m;

  while (get_next_group_of_molecules(input, m, parallel_group_size)) {
    const int n = m.number_elements();

    molecules_read += n;

    if (report_progress()) {
      cerr << "Processed " << molecules_read << " molecules\n";
    }

    for (int i = 0; i < n; ++i) {
      iwecfp_single_molecule(*(m[i]), sodb, fpc, lcr[i], res[i]);
    }

    transfer_to_output_streams(res, n, output, stream_for_too_hard);
  }

  return 1;
}

static int
iwecfp(const char* fname, FileType input_type, Set_of_Databases& sodb,
       Fingerprint_Characteristics& fpc, IWString_and_File_Descriptor& output)
{
  data_source_and_type<Molecule> input(input_type, fname);

  if (!input.ok()) {
    cerr << "Cannot open '" << fname << "'\n";
    return 0;
  }

  if (parallel_group_size > 0) {
    return iwecfp_chunked(input, sodb, fpc, output);
  } else {
    return iwecfp(input, sodb, fpc, output);
  }
}

static void
display_dash_m_options(std::ostream& os)
{
  os << " -M mult       multiplicative bit formation\n";
  os << " -M mb0        display missing bits as '0' rather than number missing\n";
  os << " -M isomd      isotopically label the most difficult atom\n";
  os << " -M isomd=<n>  isotopically label the most difficult atoms\n";
  os << " -M noex       databases do not contain examples, binary count and rad only\n";
  os << " -M dbcache=<n> set database cache size (bytes)\n";
  os << " -M bcache=<n>  set bit hash cache size (bytes)\n";
  os << " -M ckmt        check that the number of bits found decreases with radius\n";
  os << " -M pref        prefetch bits from the database - helps speed\n";

  exit(1);
}

static int
iwecfp(int argc, char** argv)
{
  Command_Line cl(argc, argv, "vE:A:g:i:r:R:ld:e:t:z:w:u:U:H:S:M:n:IL:");

  if (cl.unrecognised_options_encountered()) {
    cerr << "Unrecognised options encountered\n";
    usage(1);
  }

  verbose = cl.option_count('v');
  if (verbose) {
    iwecfp_database_lookup::set_verbose(verbose);
  }

  if (!process_elements(cl)) {
    usage(2);
  }

  if (cl.option_present('g')) {
    if (!chemical_standardisation.construct_from_command_line(cl, verbose > 1, 'g')) {
      cerr << "Cannot initialise chemical standardisation (-g)\n";
      usage(14);
    }
  }

  if (!process_standard_aromaticity_options(cl, verbose)) {
    cerr << "Cannot process aromaticity options (-A)\n";
    usage(5);
  }

  set_global_aromaticity_type(Daylight);

  set_default_iwstring_float_concatenation_precision(3);
  set_default_iwstring_double_concatenation_precision(3);

  if (cl.option_present('I')) {
    write_isotopically_labelled_summary_structure = 1;
    isotopically_label_most_difficult_atoms = 1;

    if (verbose) {
      cerr << "Will write structure with rarest atom(s) isotopically labelled\n";
    }
  }

  if (cl.option_present('n')) {
    const_IWSubstring n = cl.string_value('n');

    if ("all" == n) {
      write_example_structures = std::numeric_limits<int>::max();
    } else if (!n.numeric_value(write_example_structures) ||
               write_example_structures <
                   0)  // zero is OK, means do not write any examples
    {
      cerr << "The number of example structures to write (-n) must be a whole +ve "
              "number\n";
      usage(1);
    } else if (verbose) {
      cerr << "Will write the first " << write_example_structures
           << " example structures\n";
    }
  }

  if (cl.option_present('w')) {
    int i = 0;
    const_IWSubstring w;
    while (cl.value('w', w, i++)) {
      if ("ss" == w || "score" == w || "SCORE" == w) {
        include_score_with_normal_results = 1;
      } else if ("PSD" == w) {
        write_per_shell_data = 1;
        if (verbose) {
          cerr << "Will write Per Shell Data\n";
        }
      } else if ("DSC" == w) {
        if (cl.option_present('I')) {
          cerr << "Writing isotopically labelled smiles and creatign a descriptor file "
                  "are incompatible\n";
          return 1;
        }
        create_descriptor_file = 1;
        if (verbose) {
          cerr << "Output will be a descriptor file\n";
        }
      } else if ("OSO" == w) {
        write_per_shell_data = 1;
        only_write_outer_shell = 1;

        if (verbose) {
          cerr << "Will only write the outer shell info\n";
        }
      } else {
        cerr << "unrecognised -w qualifier '" << w << "'\n";
        usage(5);
      }
    }
  } else {
    include_score_with_normal_results = 1;
  }

  if (!cl.option_present('d')) {
    cerr << "Must specify database(s) via the -d option\n";
    usage(3);
  }

  Set_of_Databases sodb;

  if (!sodb.build(cl, 'e', 'd', verbose)) {
    cerr << "Cannot open database(s) (-d)\n";
    return 2;
  }

  int mr = 0;
  sodb.determine_max_search_radius(mr);

  Fingerprint_Characteristics fpc;

  if (!fpc.build(cl, mr, verbose)) {
    cerr << "Cannot initialise fingerprints\n";
    usage(1);
  }

  if (mr < fpc.max_shell_radius()) {
    cerr << "User specified max radius " << fpc.max_shell_radius()
         << " but longest radius in any DB is " << mr << ", cannot continue\n";
    return 1;
  }

  if (cl.option_present('l')) {
    fpc.set_only_set_bits_for_max_radius_shell();
    if (verbose) {
      cerr << "Only bits for the largest radius will be set\n";
    }
  }

  if (cl.option_present('L')) {
    const char* l = cl.option_value('L');
    sodb.open_logfile(l);
    if (verbose) {
      cerr << "Logfile stem '" << l << "'\n";
    }
  }

  // sodb.debug_print(cerr);

  int slurp_examples = 0;
  if (cl.option_present('M')) {
    int i = 0;
    const_IWSubstring m;
    while (cl.value('M', m, i++)) {
      if ("mult" == m) {
        fpc.set_additive(0);

        if (verbose) {
          cerr << "Fingerprints formed with multiplication operations\n";
        }
      } else if ("mb0" == m) {
        show_number_bits_missing_for_missing_bits = 0;
        if (verbose) {
          cerr << "Will show zero count for missing bits\n";
        }
      } else if ("mb1" == m) {
        show_number_bits_missing_for_missing_bits = 1;
        if (verbose) {
          cerr << "Will show asterisk'ed count for missing bits\n";
        }
      } else if ("isomd" == m) {
        isotopically_label_most_difficult_atoms = 1;

        if (verbose) {
          cerr << "Will isotopically label the "
               << isotopically_label_most_difficult_atoms << " most difficult atoms\n";
        }
      } else if (m.starts_with("isomd=")) {
        m.remove_leading_chars(6);
        if (!m.numeric_value(isotopically_label_most_difficult_atoms) ||
            isotopically_label_most_difficult_atoms < 1) {
          cerr << "Invalid value for most difficult atoms '" << m << "\n";
          return 3;
        }
        if (verbose) {
          cerr << "Will isotopically label the "
               << isotopically_label_most_difficult_atoms << " most difficult atoms\n";
        }
      } else if ("noex" == m) {
        sodb.set_user_wants_example_structures(0);
      } else if ("pac" == m) {
        per_atom_counts = 1;
      }
/*      else if ("serial" == m)
      {
        __cilkrts_set_param("nworkers","1");
      }
*/
#ifdef CACHE_SIZE_SETTABLE
      else if (m.starts_with("dbcache=")) {
        m.remove_leading_chars(8);

        if (!m.numeric_value(db_cache_size) || db_cache_size < 1) {
          cerr << "The database cache size must be a reasonable +ve number\n";
          return 3;
        }
      }
#endif
      else if (m.starts_with("bcache")) {
        m.remove_leading_chars(7);

        int max_hash_size;
        if (!m.numeric_value(max_hash_size) || max_hash_size < 1) {
          cerr << "The max bit hash size must be a whole +ve number\n";
          return 2;
        }
        iwecfp_database_lookup::set_max_hash_size(max_hash_size);

        if (write_example_structures && cl.option_present('n')) {
          cerr << "Sorry, caching does not work with example databases, see Ian\n";
          return 2;
        }
      } else if (m.starts_with("slurp=")) {
        m.remove_leading_chars(6);
        if (!m.numeric_value(slurp_examples) || slurp_examples < 1) {
          cerr << "The min examples for slurp specification must be a whole +ve number\n";
          return 3;
        }

        iwecfp_database_lookup::set_slurp_examples(slurp_examples);
        if (verbose) {
          cerr << "Will slurp database examples to hash if at least " << slurp_examples
               << " examples\n";
        }
      } else if ("ckmt" == m) {
        check_monotonicity_bits_found = 1;
        if (verbose) {
          cerr << "Will check monotonicity of bits found by radius\n";
        }
      } else if ("flush" == m) {
        flush_output_each_molecule = 1;
        if (verbose) {
          cerr << "output flushed each molecule\n";
        }
      } else if ("help" == m) {
        display_dash_m_options(cerr);
      } else {
        cerr << "Unrecognised -M qualifier '" << m << "'\n";
        display_dash_m_options(cerr);
      }
    }
  }

  if (cl.option_present('m')) {
  }

  if (cl.option_present('t')) {
    if (!report_progress.initialise(cl, 't', verbose)) {
      cerr << "Cannot initialise progress reporting (-p)\n";
      usage(3);
    }
  }

  if (cl.option_present('z')) {
    if (!cl.value('z', count_threshold) || count_threshold < 0) {
      cerr << "The count threshold value (-z) must be a non -ve whole number\n";
      usage(4);
    }

    if (verbose) {
      cerr << "Will count the number of bits with counts <= " << count_threshold << '\n';
    }
  }

  if (!score_related.build(cl, 'u', verbose)) {
    cerr << "Cannot initialise score filtering options (-u and/or -U)\n";
    return 1;
  }

  if (cl.option_present('U')) {
    if (!cl.option_present('u')) {
      cerr << "The rejected molecule option (-U) does not make sense without the -u "
              "option\n";
      usage(1);
    }

    IWString fname = cl.string_value('U');

    if (!fname.ends_with(".smi")) {
      fname << ".smi";
    }

    if (!stream_for_too_hard.open(fname.null_terminated_chars())) {
      cerr << "Cannot open stream for rejected molecules '" << fname << "'\n";
      return 2;
    }

    if (verbose) {
      cerr << "Rejected molecules written to '" << fname << "'\n";
    }
  }

  if (cl.option_present('H')) {
    doing_ring_system_desirability = 1;

    initialise_substituent_elements();

    if (verbose) {
      cerr << "Doing ring system desirability determinations\n";
    }
  }

  FileType input_type = FILE_TYPE_INVALID;

  if (cl.option_present('i')) {
    if (!process_input_type(cl, input_type)) {
      cerr << "Cannot determine input type\n";
      usage(6);
    }
  } else if (1 == cl.number_elements() && 0 == ::strcmp(cl[0], "-")) {
    input_type = FILE_TYPE_SMI;
  } else if (!all_files_recognised_by_suffix(cl)) {
    cerr << "Cannot determine input type(s)\n";
    return 7;
  }

  if (cl.empty()) {
    cerr << "Insufficient arguments\n";
    usage(2);
  }

  IWString atype_string;
  sodb.determine_atom_typing_in_use(atype_string, iwecfp_atom_type);

  fpc.set_atype(iwecfp_atom_type);

  if (slurp_examples) {
    sodb.slurp_to_cache(slurp_examples);
  }

  if (cl.option_present('S')) {
    IWString fname;
    for (int i = 0; cl.value('S', fname, i); ++i) {
      if (! sodb.BuildSubtractionDatabase(fname, fpc, preprocess_molecule)) {
        cerr << "Cannot read subtraction set from '" << fname << "'\n";
        return 1;
      }
    }

    if (verbose) {
      sodb.ReportSubtractDatabaseStatus(cerr);
    }
  }

  int rc = 0;

  IWString_and_File_Descriptor output(1);

  if (create_descriptor_file) {
    output << "ID" << descriptor_file_output_separator << "nbits";
    if (create_descriptor_file && write_per_shell_data) {
      for (int i = 0; i <= fpc.max_shell_radius(); ++i) {
        output << descriptor_file_output_separator << "Found." << i;
      }
    } else if (write_per_shell_data) {
      for (int i = 0; i <= fpc.max_shell_radius(); ++i) {
        output << descriptor_file_output_separator << "R." << i
               << descriptor_file_output_separator << "Found." << i;
      }
    }
    output << descriptor_file_output_separator << "Score\n";
  }

  set_default_iwstring_float_concatenation_precision(5);

  for (int i = 0; i < cl.number_elements(); i++) {
    if (!iwecfp(cl[i], input_type, sodb, fpc, output)) {
      rc = i + 1;
      break;
    }
  }

  output.flush();

  if (verbose) {
    cerr << "Read " << molecules_read << " molecules\n";

    if (cl.option_present('u')) {
      cerr << "Wrote " << molecules_written << " molecules\n";
    }

    score_related.report(cerr);

    sodb.ReportSubtractionDatabaseImpact(cerr);

    sodb.report(cerr);
  }

  return rc;
}

int
main(int argc, char** argv)
{
  int rc = iwecfp(argc, argv);
  return rc;
}
