/* src/Internal/Utilities_Nondistributable/GFP_Tools/uni.f -- translated by f2c (version 20200916).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

doublereal uni_0_(int n__, integer *iseed, integer *kk)
{
    /* Initialized data */

    static real u[17] = { .8668672834288f,.3697986366357f,.8008968294805f,
	    .417388977468f,.8254561579836f,.9640965269077f,.4508667414265f,
	    .6451309529668f,.164545602473f,.2787901807898f,.06761531340295f,
	    .966322633082f,.01963343943798f,.02947398211399f,.1636231515294f,
	    .3976343250467f,.2631008574685f };
    static integer i__ = 17;
    static integer j = 5;
    static integer k = 24;
    static real c__ = .021602869033813477f;

    /* System generated locals */
    integer i__1;
    real ret_val;

    /* Local variables */
    static real s, t;
    static integer i1, j1, k1, l1, m1, ii, jj;

/* ***BEGIN PROLOGUE  UNI */
/* ***DATE WRITTEN   810915 (YYMMDD) */
/* ***REVISION DATE  871210 (YYMMDD) */
/* ***CATEGORY NO.  L6A21 */
/* ***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS */
/* ***AUTHOR    KAHANER, DAVID, SCIENTIFIC COMPUTING DIVISION, NBS */
/*             MARSAGLIA, GEORGE, SUPERCOMPUTER RES. INST., FLORIDA ST. U. */

/* ***PURPOSE  THIS ROUTINE GENERATES REAL (SINGLE PRECISION) UNIFORM */
/*             RANDOM NUMBERS ON [0,1) */
/* ***DESCRIPTION */
/*        Computes real (single precision) uniform numbers on [0,1). */
/*           From the book, "Numerical Methods and Software" by */
/*                D. Kahaner, C. Moler, S. Nash */
/*                Prentice Hall, 1988 */

/*       USAGE: */
/*              To initialize the generator */
/*                   USEED = USTART(ISEED) */
/*               where: ISEED is any NONZERO integer */
/*                  will return floating point value of ISEED. */

/*               Subsequently */
/*                       U = UNI() */
/*                  will return a real uniform on [0,1) */

/*                One initialization is necessary, but any number of evaluations */
/*                  of  UNI in any order, are allowed. */

/*           Note: Depending upon the value of K (see below), the output */
/*                       of UNI may differ from one machine to another. */

/*           Typical usage: */

/*               REAL U,UNI,USTART,USEED */
/*               INTEGER ISEED */
/* C                 Set seed */
/*               ISEED = 305 */
/*               USEED = USTART(ISEED) */
/*               DO 1 I = 1,1000 */
/*                   U = UNI() */
/*             1 CONTINUE */
/* C                 NOTE: If K=24 (the default, see below) the output value of */
/* C                           U will be 0.1570390462475... */
/*               WRITE(*,*) U */
/*               END */

/*          NOTE ON PORTABILITY: Users can choose to run UNI in its default */
/*               mode (requiring NO user action) which will generate the same */
/*               sequence of numbers on any computer supporting floating point */
/*               numbers with at least 24 bit mantissas, or in a mode that */
/*               will generate numbers with a longer period on computers with */
/*               larger mantissas. */
/*          TO EXERCISE THIS OPTION:  B E F O R E  invoking USTART insert */
/*               the instruction        UBITS = UNIB(K)      K >= 24 */
/*               where K is the number of bits in the mantissa of your floating */
/*               point word (K=48 for Cray, Cyber 205). UNIB returns the */
/*               floating point value of K that it actually used. */
/*                    K input as .LE. 24, then UBITS=24. */
/*                    K input as .GT. 24, then UBITS=FLOAT(K) */
/*               If K>24 the sequence of numbers generated by UNI may differ */
/*               from one computer to another. */



/* ***REFERENCES  MARSAGLIA G., "COMMENTS ON THE PERFECT UNIFORM RANDOM */
/*                 NUMBER GENERATOR", UNPUBLISHED NOTES, WASH S. U. */
/* ***ROUTINES CALLED  (NONE) */
/* ***END PROLOGUE UNI */
/*                            2**24=16777216 */

/*      Load data array in case user forgets to initialize. */
/*      This array is the result of calling UNI 100000 times */
/*         with ISEED=305 and K=64. */
    switch(n__) {
	case 1: goto L_ustart;
	case 2: goto L_unib;
	}


/*   Basic generator is Fibonacci */

    ret_val = u[(0 + (0 + (i__ - 1 << 2))) / 4] - u[(0 + (0 + (j - 1 << 2))) /
	     4];
    if (ret_val < 0.f) {
	ret_val += 1.f;
    }
    u[i__ - 1] = ret_val;
    --i__;
    if (i__ == 0) {
	i__ = 17;
    }
    --j;
    if (j == 0) {
	j = 17;
    }

/*   Second generator is congruential */

    c__ += -.45623308420181274f;
    if (c__ < 0.f) {
	c__ += .99999982118606567f;
    }

/*   Combination generator */

    ret_val -= c__;
    if (ret_val < 0.f) {
	ret_val += 1.f;
    }
    return ret_val;


L_ustart:

/*          Set up ... */
/*          Convert ISEED to four smallish positive integers. */

    i1 = abs(*iseed) % 177 + 1;
    j1 = abs(*iseed) % 167 + 1;
    k1 = abs(*iseed) % 157 + 1;
    l1 = abs(*iseed) % 147 + 1;

/*              Generate random bit pattern in array based on given seed. */

    for (ii = 1; ii <= 17; ++ii) {
	s = 0.f;
	t = .5f;
/*             Do for each of the bits of mantissa of word */
/*             Loop  over K bits, where K is defaulted to 24 but can */
/*               be changed by user call to UNIB(K) */
	i__1 = k;
	for (jj = 1; jj <= i__1; ++jj) {
	    m1 = i1 * j1 % 179 * k1 % 179;
	    i1 = j1;
	    j1 = k1;
	    k1 = m1;
	    l1 = (l1 * 53 + 1) % 169;
	    if (l1 * m1 % 64 >= 32) {
		s += t;
	    }
/* L3: */
	    t *= .5f;
	}
/* L2: */
	u[ii - 1] = s;
    }
    ret_val = (real) (*iseed);
    return ret_val;


L_unib:
    if (*kk <= 24) {
	k = 24;
    } else {
	k = *kk;
    }
    ret_val = (real) k;
    return ret_val;
} /* uni_ */

doublereal uni_(void)
{
    return uni_0_(0, (integer *)0, (integer *)0);
    }

doublereal ustart_(integer *iseed)
{
    return uni_0_(1, iseed, (integer *)0);
    }

doublereal unib_(integer *kk)
{
    return uni_0_(2, (integer *)0, kk);
    }

