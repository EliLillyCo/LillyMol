// Score a Catboost model based on the .cpp file generated
// by Catboost. That means that every model will have a different
// executable.

#include <string>
#include <vector>

#include "Foundational/accumulator/accumulator.h"
#include "Foundational/cmdline/cmdline.h"
#include "Foundational/data_source/iwstring_data_source.h"
#include "Foundational/iwmisc/proto_support.h"
#include "Foundational/iw_tdt/iw_tdt.h"

#include "Utilities/General/class_label_translation.pb.h"
#define FEATURE_SCALER_IMPLEMENTATION
#include "Utilities/General/scaler.h"

#include "Utilities/GFP_Tools/bit_subset.h"
#include "Utilities/GFP_Tools/gfp.h"
#include "Utilities/GFP_Tools/gfp_model.pb.h"
#include "Utilities/GFP_Tools/gfp_to_svm_lite.pb.h"

// The function generated by Catboost. Different for every model.
extern double ApplyCatboostModel(const std::vector<float>& features);

namespace gfp_catboost_score {

struct JobParameters {

  // Conversion from gfp bit numbers to feature numbers.
  bit_subset::BitXref bit_xref;

  // Vector that gets populated with feature numbers and
  // passed to ApplyCatboostModel.
  std::vector<float> features;

  Accumulator<double> acc_score;

  // The model being scored.
  GfpModel::CatboostModel model;

  // If this is a classification model, this will be set to two
  // class labels. Otherwise we assume this is a regression model
  // the the unscaling stored in `model` is used.
  resizable_array<IWString> label;

  int verbose = 0;

  char output_separator = ' ';
};

void
Usage(int rc) {
  exit(rc);
}

int
RegressionModel(double score,
                JobParameters& params,
                IWString_and_File_Descriptor& output) {
  output << static_cast<float>(score);

  return 1;
}

int
ClassificationModel(double score,
               JobParameters& params,
               IWString_and_File_Descriptor& output) {
  const int label = score <= 0.5 ? 0 : 1;

  output << params.label[label] << params.output_separator << static_cast<float>(score);

  return 1;
}

template <typename T>
void FlattenFeatures(std::vector<T>& features) {
  for (size_t i = 0; i < features.size(); ++i) {
    if (features[i] > 0.0) {
      features[i] = 1.0;
    }
  }
}

int
GFPCatboostScore(IW_General_Fingerprint& gfp,
                 JobParameters& params,
                 IWString_and_File_Descriptor& output) {
  static int first_call = true;
  if (first_call) {
    if (! params.bit_xref.InitialiseGfpKnown(gfp)) {
      cerr << "GFPCatboostScore:cannot initialise subset\n";
      return 0;
    }
    first_call = false;
    cerr << "InitialiseGfpKnown complete\n";
  }

  if (! params.bit_xref.PopulateFeatureVector(gfp, params.features)) {
    cerr << "GFPCatboostScore:PopulateFeatureVector failed\n";
    return 0;
  }

  if (params.model.metadata().flatten_sparse_fingerprints()) {
    FlattenFeatures(params.features);
  }

  const double score = ApplyCatboostModel(params.features);
  params.acc_score.extra(score);

  output << gfp.id() << params.output_separator;

  int rc;
  if (params.label.empty()) {
    rc = RegressionModel(score, params, output);
  } else {
    rc = ClassificationModel(score, params, output);
  }
  output << '\n';

  output.write_if_buffer_holds_more_than(8192);
  return rc;
}

int
GFPCatboostScore(IW_TDT& tdt,
                 JobParameters& params,
                 IWString_and_File_Descriptor& output) {
  IW_General_Fingerprint gfp;
  int fatal = 0;
  if (! gfp.construct_from_tdt(tdt, fatal)) {
    cerr << "Cannot parse " << tdt << '\n';
    return 0;
  }

  return GFPCatboostScore(gfp, params, output);
}

int
GFPCatboostScore(iwstring_data_source& input,
                 JobParameters& params,
                 IWString_and_File_Descriptor& output) {
  IW_TDT tdt;
  while (tdt.next(input)) {
    if (! GFPCatboostScore(tdt, params, output)) {
      cerr << "Fatal error processing " << tdt << '\n';
      return 0;
    }
  }

  return 1;
}

unsigned int
HighestValue(const google::protobuf::Map<unsigned int, unsigned int>& xref) {
  unsigned int maxval = 0;
  for (const auto& [key, value] : xref) {
    if (value > maxval) {
      maxval = value;
    }
  }
  return maxval;
}

int
GFPCatboostScore(const char * fname,
                 JobParameters& params,
                 IWString_and_File_Descriptor& output) {
  iwstring_data_source input(fname);
  if (! input.good()) {
    cerr << "Cannot open '" << fname << "'\n";
    return 0;
  }

  return GFPCatboostScore(input, params, output);
}

int
DetermineClassLabels(IWString& fname,
                     JobParameters& params) {
  std::optional<ClassLabelTranslation::ClassLabelTranslation> proto = 
     iwmisc::ReadBinaryProto<ClassLabelTranslation::ClassLabelTranslation>(fname);
  if (! proto) {
    cerr << "DetermineClassLabels:cannot read '" << fname << "'\n";
    return 0;
  }

  params.label.extend(2, "");

  for (const auto& [key, value] : proto->to_numeric()) {
    if (value == 0) {
      params.label[0] = key;
    } else if (value == 1) {
      params.label[1] = key;
    } else {
      cerr << "DetermineClassLabels:invalid index " << key << ',' << value << "\n";
      return 0;
    }
  }

  return 1;
}

int
GFPCatboostScore(int argc, char** argv) {
  Command_Line cl(argc, argv, "vM:");

  if (cl.unrecognised_options_encountered()) {
    cerr << "unrecognised_options_encountered\n";
    Usage(1);
  }

  if (! cl.option_present('M')) {
    cerr << "Must specify model proto file via the -M option\n";
    Usage(1);
  }

  JobParameters job_params;

  job_params.verbose = cl.option_count('v');

  bit_subset::BitXref bit_xref;
  GfpModel::CatboostModel model_proto;
  uint32_t highest_feature_number = 0;

  if (cl.option_present('M')) {
    IWString fname = cl.string_value('M');
    if (! iwmisc::ReadBinaryProto(fname, job_params.model)) {
      cerr << "Cannot read model proto '" << fname << "'\n";
      return 1;
    }

    const std::string xref_fname = job_params.model.bit_xref();
    if (xref_fname.empty()) {
      cerr << "Model has no bit_xref attribute\n";
      return 1;
    }

    const IWString dirname = iwmisc::IWDirname(fname);
    fname = dirname;
    fname << '/' << xref_fname;

    std::optional<GfpBitSubset::GfpBitToFeature> bit_xref_proto =
                iwmisc::ReadBinaryProto<GfpBitSubset::GfpBitToFeature>(fname);
    if (! bit_xref_proto) {
      cerr << "Cannot read bit_ref proto '" << fname << "'\n";
      return 1;
    }

    if (bit_xref_proto->xref().empty()) {
      cerr << "No data in bit xref\n";
      return 1;
    }

    if (! job_params.bit_xref.Build(*bit_xref_proto)) {
      cerr << "Cannot build BitXref from proto\n";
      return 1;
    }

    if (job_params.verbose) {
      cerr << "Bit xref read from '" << fname << "'\n";
    }
  
    highest_feature_number = job_params.bit_xref.HighestFeatureNumber();
    if (job_params.verbose) {
      cerr << "highest_feature_number " << highest_feature_number << '\n';
    }

    if (highest_feature_number == 0) {
      cerr << "highest_feature_number " << highest_feature_number << '\n';
      return 1;
    }

    if (!job_params.model.metadata().class_label_translation().empty()) {
      IWString fname;
      fname << dirname << '/' << job_params.model.metadata().class_label_translation();
      if (! DetermineClassLabels(fname, job_params)) {
        cerr << "Cannot initialise classification model\n";
        return 1;
      }
    }
  }

  job_params.features.resize(highest_feature_number);

  if (cl.empty()) {
    cerr << "Insufficient arguments\n";
    Usage(1);
  }

  IWString_and_File_Descriptor output(1);
  output << "ID" << job_params.output_separator << "pred_" << job_params.model.metadata().response_name();
  if (! job_params.label.empty()) {  // classification model.
    output << job_params.output_separator << "score";
  }
  output << '\n';

  for (const char * fname : cl) {
    if (! GFPCatboostScore(fname, job_params, output)) {
      cerr << "Fatal error processing '" << fname << "'\n";
      return 1;
    }
  }

  output.flush();

  if (job_params.verbose) {
    cerr << "Scored " << job_params.acc_score.n() << " molecules "
         << " scores btw " << static_cast<float>(job_params.acc_score.minval())
         << " and " << static_cast<float>(job_params.acc_score.maxval())
         << " mean " << static_cast<float>(job_params.acc_score.average()) << '\n';
  }

  return 0;
}

}  // namespace gfp_catboost_score

int
main(int argc, char ** argv) {
  GOOGLE_PROTOBUF_VERIFY_VERSION;
  return gfp_catboost_score::GFPCatboostScore(argc, argv);
}
